<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<link rel="Stylesheet" type="text/css" href="style.css">
<title>crash command</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
</head>
<body>

<h1> 目录</h1>
<div class="toc">
<ul>
<li><a href="#toc_0.0.1">ascii</a>
<li><a href="#toc_0.0.2">bt</a>
<li><a href="#toc_0.0.3">btop</a>
<li><a href="#toc_0.0.4">dev</a>
<li><a href="#toc_0.0.5">dis</a>
<li><a href="#toc_0.0.6">eval</a>
<li><a href="#toc_0.0.7">exit</a>
<li><a href="#toc_0.0.8">extend</a>
<li><a href="#toc_0.0.9">files</a>
<li><a href="#toc_0.0.10">foreach</a>
<li><a href="#toc_0.0.11">fuser</a>
<li><a href="#toc_0.0.12">ipcs</a>
<li><a href="#toc_0.0.13">irq</a>
<li><a href="#toc_0.0.14">kmem</a>
<li><a href="#toc_0.0.15">list</a>
<li><a href="#toc_0.0.16">log</a>
<li><a href="#toc_0.0.17">mach</a>
<li><a href="#toc_0.0.18">mod</a>
<li><a href="#toc_0.0.19">mount</a>
<li><a href="#toc_0.0.20">net</a>
<li><a href="#toc_0.0.21">p</a>
<li><a href="#toc_0.0.22">ps</a>
<li><a href="#toc_0.0.23">pte</a>
<li><a href="#toc_0.0.24">ptob</a>
<li><a href="#toc_0.0.25">ptov</a>
<li><a href="#toc_0.0.26">q</a>
<li><a href="#toc_0.0.27">rd</a>
<li><a href="#toc_0.0.28">repeat</a>
<li><a href="#toc_0.0.29">runq</a>
<li><a href="#toc_0.0.30">search</a>
<li><a href="#toc_0.0.31">set</a>
<li><a href="#toc_0.0.32">sig</a>
<li><a href="#toc_0.0.33">*</a>
<li><a href="#toc_0.0.34">struct</a>
<li><a href="#toc_0.0.35">swap</a>
<li><a href="#toc_0.0.36">sym</a>
<li><a href="#toc_0.0.37">sys</a>
<li><a href="#toc_0.0.38">task</a>
<li><a href="#toc_0.0.39">timer</a>
<li><a href="#toc_0.0.40">tree</a>
<li><a href="#toc_0.0.41">union</a>
<li><a href="#toc_0.0.42">vm</a>
<li><a href="#toc_0.0.43">vtop</a>
<li><a href="#toc_0.0.44">waitq</a>
<li><a href="#toc_0.0.45">whatis</a>
<li><a href="#toc_0.0.46">wr</a>
</ul>
</ul>
</ul>
</div>
<hr />

<h3 id="toc_0.0.1">ascii</h3>
<pre>
NAME
  ascii - translate a hexadecimal string to ASCII

SYNOPSIS
  ascii value ...

DESCRIPTION
  Translates 32-bit or 64-bit hexadecimal values to ASCII.  If no argument
  is entered, an ASCII chart is displayed.

EXAMPLES
  Translate the hexadecimal value of 0x62696c2f7273752f to ASCII:

    crash&gt; ascii 62696c2f7273752f
    62696c2f7273752f: /usr/lib

  Display an ASCII chart:

    crash&gt; ascii
 
          0    1   2   3   4   5   6   7
        +-------------------------------
      0 | NUL DLE  SP  0   @   P   '   p
      1 | SOH DC1  !   1   A   Q   a   q
      2 | STX DC2  "   2   B   R   b   r
      3 | ETX DC3  #   3   C   S   c   s
      4 | EOT DC4  $   4   D   T   d   t
      5 | ENQ NAK  %   5   E   U   e   u
      6 | ACK SYN  &amp;   6   F   V   f   v
      7 | BEL ETB  `   7   G   W   g   w
      8 |  BS CAN  (   8   H   X   h   x
      9 |  HT  EM  )   9   I   Y   i   y
      A |  LF SUB  *   :   J   Z   j   z
      B |  VT ESC  +   ;   K   [   k   {
      C |  FF  FS  ,   &lt;   L   \   l   |
      D |  CR  GS  _   =   M   ]   m   }
      E |  SO  RS  .   &gt;   N   ^   n   ~
      F |  SI  US  /   ?   O   -   o  DEL
</pre>

<h3 id="toc_0.0.2">bt</h3>
<pre>
NAME
  bt - backtrace

SYNOPSIS
  bt [-a|-g|-r|-t|-T|-l|-e|-E|-f|-F|-o|-O] [-R ref] [-s [-x|d]] [-I ip] [-S sp]
     [pid | task]

DESCRIPTION
  Display a kernel stack backtrace.  If no arguments are given, the stack
  trace of the current context will be displayed.

       -a  displays the stack traces of the active task on each CPU.
           (only applicable to crash dumps)
       -g  displays the stack traces of all threads in the thread group of
           the target task; the thread group leader will be displayed first.
       -r  display raw stack data, consisting of a memory dump of the two
           pages of memory containing the task_union structure.
       -t  display all text symbols found from the last known stack location
           to the top of the stack. (helpful if the back trace fails)
       -T  display all text symbols found from just above the task_struct or
           thread_info to the top of the stack. (helpful if the back trace
           fails or the -t option starts too high in the process stack).
       -l  show file and line number of each stack trace text location.
       -e  search the stack for possible kernel and user mode exception frames.
       -E  search the IRQ stacks (x86, x86_64 and ppc64), and the exception
           stacks (x86_64) for possible exception frames; all other arguments
           will be ignored since this is not a context-sensitive operation.
       -f  display all stack data contained in a frame; this option can be
           used to determine the arguments passed to each function; on ia64,
           the argument register contents are dumped.
       -F  similar to -f, except that the stack data is displayed symbolically
           when appropriate; if the stack data references a slab cache object,
           the name of the slab cache will be displayed in brackets; on ia64,
           the substitution is done to the argument register contents.
       -o  x86: use old backtrace method, permissible only on kernels that were
           compiled without the -fomit-frame_pointer.
           x86_64: use old backtrace method, which dumps potentially stale
           kernel text return addresses found on the stack.
       -O  x86: use old backtrace method by default, permissible only on kernels
           that were compiled without the -fomit-frame_pointer; subsequent usage
           of this option toggles the backtrace method.
           x86_64: use old backtrace method by default; subsequent usage of this
           option toggles the backtrace method.
   -R ref  display stack trace only if there is a reference to this symbol
           or text address.
       -s  display the symbol name plus its offset.
       -x  when displaying a symbol offset with the -s option, override the
           default output format with hexadecimal format.
       -d  when displaying a symbol offset with the -s option, override the
           default output format with decimal format.
    -I ip  use ip as the starting text location.
    -S sp  use sp as the starting stack frame address.
      pid  displays the stack trace(s) of this pid.
    taskp  displays the stack trace the the task referenced by this hexadecimal
           task_struct pointer.

  Multiple pid and taskp arguments may be specified.

  Note that all examples below are for x86 only.  The output format will differ
  for other architectures.  x86 backtraces from kernels that were compiled
  with the --fomit-frame-pointer CFLAG occasionally will drop stack frames,
  or display a stale frame reference.  When in doubt as to the accuracy of a
  backtrace, the -t or -T options may help fill in the blanks.

EXAMPLES
  Display the stack trace of the active task(s) when the kernel panicked:

    crash&gt; bt -a
    PID: 286    TASK: c0b3a000  CPU: 0   COMMAND: "in.rlogind"
    #0 [c0b3be90] crash_save_current_state at c011aed0
    #1 [c0b3bea4] panic at c011367c
    #2 [c0b3bee8] tulip_interrupt at c01bc820
    #3 [c0b3bf08] handle_IRQ_event at c010a551
    #4 [c0b3bf2c] do_8259A_IRQ at c010a319
    #5 [c0b3bf3c] do_IRQ at c010a653
    #6 [c0b3bfbc] ret_from_intr at c0109634
       EAX: 00000000  EBX: c0e68280  ECX: 00000000  EDX: 00000004  EBP: c0b3bfbc
       DS:  0018      ESI: 00000004  ES:  0018      EDI: c0e68284 
       CS:  0010      EIP: c012f803  ERR: ffffff09  EFLAGS: 00000246 
    #7 [c0b3bfbc] sys_select at c012f803
    #8 [c0b3bfc0] system_call at c0109598
       EAX: 0000008e  EBX: 00000004  ECX: bfffc9a0  EDX: 00000000 
       DS:  002b      ESI: bfffc8a0  ES:  002b      EDI: 00000000 
       SS:  002b      ESP: bfffc82c  EBP: bfffd224 
       CS:  0023      EIP: 400d032e  ERR: 0000008e  EFLAGS: 00000246  

  Display the stack traces of task f2814000 and PID 1592:

    crash&gt; bt f2814000 1592
    PID: 1018   TASK: f2814000  CPU: 1   COMMAND: "java"
     #0 [f2815db4] schedule at c011af85
     #1 [f2815de4] __down at c010600f
     #2 [f2815e14] __down_failed at c01061b3
     #3 [f2815e24] stext_lock (via drain_cpu_caches) at c025fa55
     #4 [f2815ec8] kmem_cache_shrink_nr at c013a53e
     #5 [f2815ed8] do_try_to_free_pages at c013f402
     #6 [f2815f04] try_to_free_pages at c013f8d2
     #7 [f2815f1c] _wrapped_alloc_pages at c01406bd
     #8 [f2815f40] __alloc_pages at c014079d
     #9 [f2815f60] __get_free_pages at c014083e
    #10 [f2815f68] do_fork at c011cebb
    #11 [f2815fa4] sys_clone at c0105ceb
    #12 [f2815fc0] system_call at c010740c
        EAX: 00000078  EBX: 00000f21  ECX: bc1ffbd8  EDX: bc1ffbe0
        DS:  002b      ESI: 00000000  ES:  002b      EDI: bc1ffd04
        SS:  002b      ESP: 0807316c  EBP: 080731bc
        CS:  0023      EIP: 4012881e  ERR: 00000078  EFLAGS: 00000296
 
    PID: 1592   TASK: c0cec000  CPU: 3   COMMAND: "httpd"
     #0 [c0ceded4] schedule at c011af85
     #1 [c0cedf04] pipe_wait at c0153083
     #2 [c0cedf58] pipe_read at c015317f
     #3 [c0cedf7c] sys_read at c0148be6
     #4 [c0cedfc0] system_call at c010740c
        EAX: 00000003  EBX: 00000004  ECX: bffed4a3  EDX: 00000001 
        DS:  002b      ESI: 00000001  ES:  002b      EDI: bffed4a3 
        SS:  002b      ESP: bffed458  EBP: bffed488 
        CS:  0023      EIP: 4024f1d4  ERR: 00000003  EFLAGS: 00000286 
 
  In order to examine each stack frame's contents use the bt -f option.
       -x  when displaying a symbol offset with the -s option, override the
           default output format with hexadecimal format.
       -d  when displaying a symbol offset with the -s option, override the
           default output format with decimal format.
    -I ip  use ip as the starting text location.
    -S sp  use sp as the starting stack frame address.
      pid  displays the stack trace(s) of this pid.
    taskp  displays the stack trace the the task referenced by this hexadecimal
           task_struct pointer.

  Multiple pid and taskp arguments may be specified.

  Note that all examples below are for x86 only.  The output format will differ
  for other architectures.  x86 backtraces from kernels that were compiled
  with the --fomit-frame-pointer CFLAG occasionally will drop stack frames,
  or display a stale frame reference.  When in doubt as to the accuracy of a
  backtrace, the -t or -T options may help fill in the blanks.

EXAMPLES
  Display the stack trace of the active task(s) when the kernel panicked:

    crash&gt; bt -a
    PID: 286    TASK: c0b3a000  CPU: 0   COMMAND: "in.rlogind"
    #0 [c0b3be90] crash_save_current_state at c011aed0
    #1 [c0b3bea4] panic at c011367c
    #2 [c0b3bee8] tulip_interrupt at c01bc820
    #3 [c0b3bf08] handle_IRQ_event at c010a551
    #4 [c0b3bf2c] do_8259A_IRQ at c010a319
    #5 [c0b3bf3c] do_IRQ at c010a653
    #6 [c0b3bfbc] ret_from_intr at c0109634
       EAX: 00000000  EBX: c0e68280  ECX: 00000000  EDX: 00000004  EBP: c0b3bfbc
       DS:  0018      ESI: 00000004  ES:  0018      EDI: c0e68284 
       CS:  0010      EIP: c012f803  ERR: ffffff09  EFLAGS: 00000246 
    #7 [c0b3bfbc] sys_select at c012f803
    #8 [c0b3bfc0] system_call at c0109598
       EAX: 0000008e  EBX: 00000004  ECX: bfffc9a0  EDX: 00000000 
       DS:  002b      ESI: bfffc8a0  ES:  002b      EDI: 00000000 
       SS:  002b      ESP: bfffc82c  EBP: bfffd224 
       CS:  0023      EIP: 400d032e  ERR: 0000008e  EFLAGS: 00000246  

  Display the stack traces of task f2814000 and PID 1592:

    crash&gt; bt f2814000 1592
    PID: 1018   TASK: f2814000  CPU: 1   COMMAND: "java"
     #0 [f2815db4] schedule at c011af85
     #1 [f2815de4] __down at c010600f
     #2 [f2815e14] __down_failed at c01061b3
     #3 [f2815e24] stext_lock (via drain_cpu_caches) at c025fa55
     #4 [f2815ec8] kmem_cache_shrink_nr at c013a53e
     #5 [f2815ed8] do_try_to_free_pages at c013f402
     #6 [f2815f04] try_to_free_pages at c013f8d2
     #7 [f2815f1c] _wrapped_alloc_pages at c01406bd
     #8 [f2815f40] __alloc_pages at c014079d
     #9 [f2815f60] __get_free_pages at c014083e
    #10 [f2815f68] do_fork at c011cebb
    #11 [f2815fa4] sys_clone at c0105ceb
    #12 [f2815fc0] system_call at c010740c
        EAX: 00000078  EBX: 00000f21  ECX: bc1ffbd8  EDX: bc1ffbe0
        DS:  002b      ESI: 00000000  ES:  002b      EDI: bc1ffd04
        SS:  002b      ESP: 0807316c  EBP: 080731bc
        CS:  0023      EIP: 4012881e  ERR: 00000078  EFLAGS: 00000296
 
    PID: 1592   TASK: c0cec000  CPU: 3   COMMAND: "httpd"
     #0 [c0ceded4] schedule at c011af85
     #1 [c0cedf04] pipe_wait at c0153083
     #2 [c0cedf58] pipe_read at c015317f
     #3 [c0cedf7c] sys_read at c0148be6
     #4 [c0cedfc0] system_call at c010740c
        EAX: 00000003  EBX: 00000004  ECX: bffed4a3  EDX: 00000001 
        DS:  002b      ESI: 00000001  ES:  002b      EDI: bffed4a3 
        SS:  002b      ESP: bffed458  EBP: bffed488 
        CS:  0023      EIP: 4024f1d4  ERR: 00000003  EFLAGS: 00000286 
 
  In order to examine each stack frame's contents use the bt -f option.
  From the extra frame data that is displayed, the arguments passed to each
  function can be determined.  Re-examining the PID 1592 trace above:
 
    crash&gt; bt -f 1592
    PID: 1592   TASK: c0cec000  CPU: 3   COMMAND: "httpd"
     #0 [c0ceded4] schedule at c011af85
        [RA: c0153088  SP: c0ceded4  FP: c0cedf04  SIZE: 52]
        c0ceded4: c0cedf00  c0cec000  ce1a6000  00000003  
        c0cedee4: c0cec000  f26152c0  cfafc8c0  c0cec000  
        c0cedef4: ef70a0a0  c0cec000  c0cedf28  c0cedf54  
        c0cedf04: c0153088  
     #1 [c0cedf04] pipe_wait at c0153083
        [RA: c0153184  SP: c0cedf08  FP: c0cedf58  SIZE: 84]
        c0cedf08: 00000000  c0cec000  00000000  00000000  
        c0cedf18: 00000000  c0a41fa0  c011d38b  c0394120  
        c0cedf28: 00000000  c0cec000  ceeebf30  ce4adf30  
        c0cedf38: 00000000  d4b60ce0  00000000  c0cedf58  
        c0cedf48: e204f820  ef70a040  00000001  c0cedf78  
        c0cedf58: c0153184  
     #2 [c0cedf58] pipe_read at c015317f
        [RA: c0148be8  SP: c0cedf5c  FP: c0cedf7c  SIZE: 36]
        c0cedf5c: ef70a040  c0cec000  00000000  00000000  
        c0cedf6c: 00000001  f27ae680  ffffffea  c0cedfbc  
        c0cedf7c: c0148be8  
     #3 [c0cedf7c] sys_read at c0148be6
        [RA: c0107413  SP: c0cedf80  FP: c0cedfc0  SIZE: 68]
        c0cedf80: f27ae680  bffed4a3  00000001  f27ae6a0  
        c0cedf90: 40160370  24000000  4019ba28  00000000  
        c0cedfa0: 00000000  fffffffe  bffba207  fffffffe  
        c0cedfb0: c0cec000  00000001  bffed4a3  bffed488  
        c0cedfc0: c0107413  
     #4 [c0cedfc0] system_call at c010740c
        EAX: 00000003  EBX: 00000004  ECX: bffed4a3  EDX: 00000001 
        DS:  002b      ESI: 00000001  ES:  002b      EDI: bffed4a3 
        SS:  002b      ESP: bffed458  EBP: bffed488 
        CS:  0023      EIP: 4024f1d4  ERR: 00000003  EFLAGS: 00000286 
        [RA: 4024f1d4  SP: c0cedfc4  FP: c0cedffc  SIZE: 60]
        c0cedfc4: 00000004  bffed4a3  00000001  00000001  
        c0cedfd4: bffed4a3  bffed488  00000003  0000002b  
        c0cedfe4: 0000002b  00000003  4024f1d4  00000023  
        c0cedff4: 00000286  bffed458  0000002b  
 
    Typically the arguments passed to a function will be the last values
    that were pushed onto the stack by the next higher-numbered function, i.e.,
    the lowest stack addresses in the frame above the called function's
    stack frame.  That can be verified by disassembling the calling function.
    For example, the arguments passed from sys_read() to pipe_read() above
    are the file pointer, the user buffer address, the count, and a pointer
    to the file structure's f_pos field.  Looking at the frame #3 data for
    sys_read(), the last four items pushed onto the stack (lowest addresses)
    are f27ae680, bffed4a3, 00000001, and f27ae6a0 -- which are the 4 arguments
    above, in that order.  Note that the first (highest address) stack content
    in frame #2 data for pipe_read() is c0148be8, which is the return address
    back to sys_read(). 
 
  Dump the text symbols found in the current context's stack:

    crash&gt; bt -t
    PID: 1357   TASK: c1aa0000  CPU: 0   COMMAND: "lockd"
          START: schedule at c01190e0
      [c1aa1f28] dput at c0157dbc
      [c1aa1f4c] schedule_timeout at c0124cd4
      [c1aa1f78] svc_recv at cb22c4d8 [sunrpc]
      [c1aa1f98] put_files_struct at c011eb21
      [c1aa1fcc] nlmclnt_proc at cb237bef [lockd]
      [c1aa1ff0] kernel_thread at c0105826
      [c1aa1ff8] nlmclnt_proc at cb237a60 [lockd]
 
  Search the current stack for possible exception frames:

    crash&gt; bt -e
    PID: 286    TASK: c0b3a000  CPU: 0   COMMAND: "in.rlogind"
    
     KERNEL-MODE EXCEPTION FRAME AT c0b3bf44:
       EAX: 00000000  EBX: c0e68280  ECX: 00000000  EDX: 00000004  EBP: c0b3bfbc
       DS:  0018      ESI: 00000004  ES:  0018      EDI: c0e68284 
       CS:  0010      EIP: c012f803  ERR: ffffff09  EFLAGS: 00000246 
    
     USER-MODE EXCEPTION FRAME AT c0b3bfc4:
       EAX: 0000008e  EBX: 00000004  ECX: bfffc9a0  EDX: 00000000 
       DS:  002b      ESI: bfffc8a0  ES:  002b      EDI: 00000000 
       SS:  002b      ESP: bfffc82c  EBP: bfffd224 
       CS:  0023      EIP: 400d032e  ERR: 0000008e  EFLAGS: 00000246 
 
  Display the back trace from a dumpfile that resulted from the execution
  of the crash utility's "sys -panic" command:

   crash&gt; bt
   PID: 12523  TASK: c610c000  CPU: 0   COMMAND: "crash"
    #0 [c610de64] die at c01076ec
    #1 [c610de74] do_invalid_op at c01079bc
    #2 [c610df2c] error_code (via invalid_op) at c0107256
       EAX: 0000001d  EBX: c024a4c0  ECX: c02f13c4  EDX: 000026f6  EBP: c610c000
       DS:  0018      ESI: 401de2e0  ES:  0018      EDI: c610c000
       CS:  0010      EIP: c011bbb4  ERR: ffffffff  EFLAGS: 00010296
    #3 [c610df68] panic at c011bbb4
    #4 [c610df78] do_exit at c011f1fe
    #5 [c610dfc0] system_call at c0107154
       EAX: 00000001  EBX: 00000000  ECX: 00001000  EDX: 401df154
       DS:  002b      ESI: 401de2e0  ES:  002b      EDI: 00000000
       SS:  002b      ESP: bffebf0c  EBP: bffebf38
       CS:  0023      EIP: 40163afd  ERR: 00000001  EFLAGS: 00000246
 
  Display the back trace from a dumpfile that resulted from an attempt to
  insmod the sample "crash.c" kernel module that comes as part of the
  Red Hat netdump package:

   crash&gt; bt
   PID: 1696   TASK: c74de000  CPU: 0   COMMAND: "insmod"
    #0 [c74dfdcc] die at c01076ec
    #1 [c74dfddc] do_page_fault at c0117bbc
    #2 [c74dfee0] error_code (via page_fault) at c0107256
       EAX: 00000013  EBX: cb297000  ECX: 00000000  EDX: c5962000  EBP: c74dff28
       DS:  0018      ESI: 00000000  ES:  0018      EDI: 00000000
       CS:  0010      EIP: cb297076  ERR: ffffffff  EFLAGS: 00010282
    #3 [c74dff1c] crash_init at cb297076 [crash]
    #4 [c74dff2c] sys_init_module at c011d233
    #5 [c74dffc0] system_call at c0107154
       EAX: 00000080  EBX: 08060528  ECX: 08076450  EDX: 0000000a
       DS:  002b      ESI: 0804b305  ES:  002b      EDI: 08074ed0
       SS:  002b      ESP: bffe9a90  EBP: bffe9ac8
       CS:  0023      EIP: 4012066e  ERR: 00000080  EFLAGS: 00000246
 
  Display the symbol name plus its offset in each frame, overriding
  the current output format with hexadecimal:

    crash&gt; bt -sx
    PID: 1499   TASK: ffff88006af43cc0  CPU: 2   COMMAND: "su"
     #0 [ffff8800664a1c90] machine_kexec+0x167 at ffffffff810327b7
     #1 [ffff8800664a1ce0] crash_kexec+0x60 at ffffffff810a9ec0
     #2 [ffff8800664a1db0] oops_end+0xb0 at ffffffff81504160
     #3 [ffff8800664a1dd0] general_protection+0x25 at ffffffff81503435
        [exception RIP: kmem_cache_alloc+120]
        RIP: ffffffff8113cf88  RSP: ffff8800664a1e88  RFLAGS: 00010086
        RAX: 0000000000000000  RBX: ff88006ef56840ff  RCX: ffffffff8114e9e4
        RDX: 0000000000000000  RSI: 00000000000080d0  RDI: ffffffff81796020
        RBP: ffffffff81796020   R8: ffff88000a3137a0   R9: 0000000000000000
        R10: ffff88007ac97300  R11: 0000000000000400  R12: 00000000000080d0
        R13: 0000000000000292  R14: 00000000000080d0  R15: 00000000000000c0
        ORIG_RAX: ffffffffffffffff  CS: 0010  SS: 0018
     #4 [ffff8800664a1ed0] get_empty_filp+0x74 at ffffffff8114e9e4
     #5 [ffff8800664a1ef0] sock_alloc_fd+0x23 at ffffffff8142f553
     #6 [ffff8800664a1f10] sock_map_fd+0x23 at ffffffff8142f693
     #7 [ffff8800664a1f50] sys_socket+0x43 at ffffffff814302a3
     #8 [ffff8800664a1f80] system_call_fastpath+0x16 at ffffffff81013042
        RIP: 00007f5720b368e7  RSP: 00007fff52b629a8  RFLAGS: 00010206
        RAX: 0000000000000029  RBX: ffffffff81013042  RCX: 0000000000000000
        RDX: 0000000000000009  RSI: 0000000000000003  RDI: 0000000000000010
        RBP: 000000000066f320   R8: 0000000000000001   R9: 0000000000000000
        R10: 0000000000000000  R11: 0000000000000202  R12: ffff88007ac97300
        R13: 0000000000000000  R14: 00007f571e104a80  R15: 00007f571e305048
        ORIG_RAX: 0000000000000029  CS: 0033  SS: 002b
</pre>

<h3 id="toc_0.0.3">btop</h3>
<pre>
NAME
  btop - bytes to page

SYNOPSIS
  btop address ...

DESCRIPTION
  This command translates a hexadecimal address to its page number.

EXAMPLES
    crash&gt; btop 512a000
    512a000: 512a
</pre>

<h3 id="toc_0.0.4">dev</h3>
<pre>
NAME
  dev - device data

SYNOPSIS
  dev [-i | -p | -d]

DESCRIPTION
  If no argument is entered, this command dumps character and block
  device data.

    -i  display I/O port usage; on 2.4 kernels, also display I/O memory usage.
    -p  display PCI device data.
    -d  display disk I/O statistics:
         TOTAL: total number of allocated in-progress I/O requests
          SYNC: I/O requests that are synchronous
         ASYNC: I/O requests that are asynchronous
          READ: I/O requests that are reads (older kernels)
         WRITE: I/O requests that are writes (older kernels)
           DRV: I/O requests that are in-flight in the device driver

EXAMPLES
  Display character and block device data:

    crash&gt; dev
    CHRDEV    NAME              CDEV    OPERATIONS
       1      mem             f79b83c0  memory_fops
       4      /dev/vc/0       c07bc560  console_fops
       4      tty             f7af5004  tty_fops
       4      ttyS            f7b02204  tty_fops
       5      /dev/tty        c07bc440  tty_fops
       5      /dev/console    c07bc4a0  console_fops
       5      /dev/ptmx       c07bc500  ptmx_fops
       6      lp              c5797e40  lp_fops
       7      vcs             f7b03d40  vcs_fops
      10      misc            f7f68640  misc_fops
      13      input           f79b8840  input_fops
      21      sg              f7f12840  sg_fops
      29      fb              f7f8c640  fb_fops
     128      ptm             f7b02604  tty_fops
     136      pts             f7b02404  tty_fops
     162      raw             c0693e40  raw_fops
     180      usb             f79b8bc0  usb_fops
     189      usb_device      c06a0300  usbfs_device_file_operations
     216      rfcomm          f5961a04  tty_fops
     254      pcmcia          f79b82c0  ds_fops
    
    BLKDEV    NAME             GENDISK  OPERATIONS
       1      ramdisk         f7b23480  rd_bd_op
       8      sd              f7cab280  sd_fops
       9      md              f7829b80  md_fops
      11      sr              f75c24c0  sr_bdops
      65      sd               (none)  
      66      sd               (none)  
      67      sd               (none)  
      68      sd               (none)  
      69      sd               (none)  
      70      sd               (none)  
      71      sd               (none)  
     128      sd               (none)  
     129      sd               (none)  
     130      sd               (none)  
     131      sd               (none)  
     132      sd               (none)  
     133      sd               (none)  
     134      sd               (none)  
     135      sd               (none)  
     253      device-mapper   c57a0ac0  dm_blk_dops
     254      mdp              (none)  

  Display PCI data:

    crash&gt; dev -p
    PCI_DEV  BU:SL.FN CLASS: VENDOR-DEVICE
    c00051c0 00:00.0  Host bridge: Intel 440BX - 82443BX Host
    c0005250 00:01.0  PCI bridge: Intel 440BX - 82443BX AGP
    c00052e0 00:07.0  ISA bridge: Intel 82371AB PIIX4 ISA
    c0005370 00:07.1  IDE interface: Intel 82371AB PIIX4 IDE
    c0005400 00:07.2  USB Controller: Intel 82371AB PIIX4 USB
    c0005490 00:07.3  Bridge: Intel 82371AB PIIX4 ACPI
    c0005520 00:11.0  Ethernet controller: 3Com 3C905B 100bTX
    c00055b0 00:13.0  PCI bridge: DEC DC21152
    c0005640 01:00.0  VGA compatible controller: NVidia [PCI_DEVICE 28]
    c00056d0 02:0a.0  SCSI storage controller: Adaptec AIC-7890/1
    c0005760 02:0e.0  SCSI storage controller: Adaptec AIC-7880U

  Display I/O port and I/O memory usage:

    crash&gt; dev -i
    RESOURCE    RANGE    NAME
    c03036d4  0000-ffff  PCI IO
    c0302594  0000-001f  dma1
    c03025b0  0020-003f  pic1
    c03025cc  0040-005f  timer
    c03025e8  0060-006f  keyboard
    c0302604  0080-008f  dma page reg
    c0302620  00a0-00bf  pic2
    c030263c  00c0-00df  dma2
    c0302658  00f0-00ff  fpu
    c122ff20  0170-0177  ide1
    c122f240  0213-0213  isapnp read
    c122ff40  02f8-02ff  serial(auto)
    c122ff00  0376-0376  ide1
    c03186e8  03c0-03df  vga+
    c122ff60  03f8-03ff  serial(auto)
    c123851c  0800-083f  Intel Corporation 82371AB PIIX4 ACPI
    c1238538  0840-085f  Intel Corporation 82371AB PIIX4 ACPI
    c122f220  0a79-0a79  isapnp write
    c122f200  0cf8-0cff  PCI conf1
    c1238858  dc00-dc7f  3Com Corporation 3c905B 100BaseTX [Cyclone]
    c122fc00  dc00-dc7f  00:11.0
    c12380c8  dce0-dcff  Intel Corporation 82371AB PIIX4 USB
    c1238d1c  e000-efff  PCI Bus #02
    c1237858  e800-e8ff  Adaptec AIC-7880U
    c1237458  ec00-ecff  Adaptec AHA-2940U2/W / 7890
    c1239cc8  ffa0-ffaf  Intel Corporation 82371AB PIIX4 IDE
    
    RESOURCE        RANGE        NAME
    c03036f0  00000000-ffffffff  PCI mem
    c0004000  00000000-0009ffff  System RAM
    c03026ac  000a0000-000bffff  Video RAM area
    c03026fc  000c0000-000c7fff  Video ROM
    c0302718  000c9800-000cdfff  Extension ROM
    c0302734  000ce000-000ce7ff  Extension ROM
    c0302750  000ce800-000cffff  Extension ROM
    c03026e0  000f0000-000fffff  System ROM
    c0004040  00100000-07ffdfff  System RAM
    c0302674  00100000-0028682b  Kernel code
    c0302690  0028682c-0031c63f  Kernel data
    c0004060  07ffe000-07ffffff  reserved
    c1239058  ec000000-efffffff  Intel Corporation 440BX/ZX - 82443BX/ZX Host
                                 bridge
    c1238d54  f1000000-f1ffffff  PCI Bus #02
    c1239554  f2000000-f5ffffff  PCI Bus #01
    c1237074  f4000000-f5ffffff  nVidia Corporation Riva TnT2 [NV5]
    c1238d38  fa000000-fbffffff  PCI Bus #02
    c1237874  faffe000-faffefff  Adaptec AIC-7880U
    c127ec40  faffe000-faffefff  aic7xxx
    c1237474  fafff000-faffffff  Adaptec AHA-2940U2/W / 7890
    c127eec0  fafff000-faffffff  aic7xxx
    c1239538  fc000000-fdffffff  PCI Bus #01
    c1237058  fc000000-fcffffff  nVidia Corporation Riva TnT2 [NV5]
    c1238874  fe000000-fe00007f  3Com Corporation 3c905B 100BaseTX [Cyclone]
    c0004080  fec00000-fec0ffff  reserved
    c00040a0  fee00000-fee0ffff  reserved
    c00040c0  ffe00000-ffffffff  reserved

  Display disk I/O statistics:

    crash&gt; dev -d
    MAJOR GENDISK            NAME     REQUEST_QUEUE      TOTAL  READ WRITE   DRV
        2 ffff81012d8a5000   fd0      ffff81012dc053c0      12     0    12     0
       22 ffff81012dc6b000   hdc      ffff81012d8ae340       2     2     0     0
        8 ffff81012dd71000   sda      ffff81012d8af040       6     0     6     6
        8 ffff81012dc77000   sdb      ffff81012d8b5740       0     0     0     0
        8 ffff81012d8d0c00   sdc      ffff81012d8ae9c0       0     0     0     0
</pre>

<h3 id="toc_0.0.5">dis</h3>
<pre>
NAME
  dis - disassemble

SYNOPSIS
  dis [-rludx][-b [num]] [address | symbol | (expression)] [count]

DESCRIPTION
  This command disassembles source code instructions starting (or ending) at
  a text address that may be expressed by value, symbol or expression:

            -r  (reverse) displays all instructions from the start of the 
                routine up to and including the designated address.
            -l  displays source code line number data in addition to the 
                disassembly output.
            -u  address is a user virtual address in the current context;
                otherwise the address is assumed to be a kernel virtual address.
                If this option is used, then -r and -l are ignored.
            -x  override default output format with hexadecimal format.
            -d  override default output format with decimal format.
      -b [num]  modify the pre-calculated number of encoded bytes to skip after
                a kernel BUG ("ud2a") instruction; with no argument, displays
                the current number of bytes being skipped. (x86 and x86_64 only)
       address  starting hexadecimal text address.
        symbol  symbol of starting text address.  On ppc64, the symbol
                preceded by '.' is used.
  (expression)  expression evaluating to a starting text address.
         count  the number of instructions to be disassembled (default is 1).
                If no count argument is entered, and the starting address
                is entered as a text symbol, then the whole routine will be
                disassembled.  The count argument is ignored when used with
                the -r option.

EXAMPLES
  Disassemble the sys_signal() routine without, and then with, line numbers:

    crash&gt; dis sys_signal
    0xc0112c88 &lt;sys_signal&gt;:        push   %ebp
    0xc0112c89 &lt;sys_signal+1&gt;:      mov    %esp,%ebp
    0xc0112c8b &lt;sys_signal+3&gt;:      sub    $0x28,%esp
    0xc0112c8e &lt;sys_signal+6&gt;:      mov    0xc(%ebp),%eax
    0xc0112c91 &lt;sys_signal+9&gt;:      mov    %eax,0xffffffec(%ebp)
    0xc0112c94 &lt;sys_signal+12&gt;:     movl   $0xc0000000,0xfffffff0(%ebp)
    0xc0112c9b &lt;sys_signal+19&gt;:     lea    0xffffffd8(%ebp),%eax
    0xc0112c9e &lt;sys_signal+22&gt;:     push   %eax
    0xc0112c9f &lt;sys_signal+23&gt;:     lea    0xffffffec(%ebp),%eax
    0xc0112ca2 &lt;sys_signal+26&gt;:     push   %eax
    0xc0112ca3 &lt;sys_signal+27&gt;:     pushl  0x8(%ebp)
    0xc0112ca6 &lt;sys_signal+30&gt;:     call   0xc01124b8 &lt;do_sigaction&gt;
    0xc0112cab &lt;sys_signal+35&gt;:     test   %eax,%eax
    0xc0112cad &lt;sys_signal+37&gt;:     jne    0xc0112cb2 &lt;sys_signal+42&gt;
    0xc0112caf &lt;sys_signal+39&gt;:     mov    0xffffffd8(%ebp),%eax
    0xc0112cb2 &lt;sys_signal+42&gt;:     leave
    0xc0112cb3 &lt;sys_signal+43&gt;:     ret
 
    crash&gt; dis -l sys_signal
    /usr/src/linux-2.2.5/kernel/signal.c: 1074
    0xc0112c88 &lt;sys_signal&gt;:        push   %ebp
    0xc0112c89 &lt;sys_signal+1&gt;:      mov    %esp,%ebp
    0xc0112c8b &lt;sys_signal+3&gt;:      sub    $0x28,%esp
    0xc0112c8e &lt;sys_signal+6&gt;:      mov    0xc(%ebp),%eax
    /usr/src/linux-2.2.5/kernel/signal.c: 1078
    0xc0112c91 &lt;sys_signal+9&gt;:      mov    %eax,0xffffffec(%ebp)
    /usr/src/linux-2.2.5/kernel/signal.c: 1079
    0xc0112c94 &lt;sys_signal+12&gt;:     movl   $0xc0000000,0xfffffff0(%ebp)
    /usr/src/linux-2.2.5/kernel/signal.c: 1081
    0xc0112c9b &lt;sys_signal+19&gt;:     lea    0xffffffd8(%ebp),%eax
    0xc0112c9e &lt;sys_signal+22&gt;:     push   %eax
    0xc0112c9f &lt;sys_signal+23&gt;:     lea    0xffffffec(%ebp),%eax
    0xc0112ca2 &lt;sys_signal+26&gt;:     push   %eax
    0xc0112ca3 &lt;sys_signal+27&gt;:     pushl  0x8(%ebp)
    0xc0112ca6 &lt;sys_signal+30&gt;:     call   0xc01124b8 &lt;do_sigaction&gt;
    /usr/src/linux-2.2.5/kernel/signal.c: 1083
    0xc0112cab &lt;sys_signal+35&gt;:     test   %eax,%eax
    0xc0112cad &lt;sys_signal+37&gt;:     jne    0xc0112cb2 &lt;sys_signal+42&gt;
    0xc0112caf &lt;sys_signal+39&gt;:     mov    0xffffffd8(%ebp),%eax
    /usr/src/linux-2.2.5/kernel/signal.c: 1084
    0xc0112cb2 &lt;sys_signal+42&gt;:     leave
    0xc0112cb3 &lt;sys_signal+43&gt;:     ret
 
  Given a return address expression of "do_no_page+65", find out the 
  function that do_no_page() calls by using the reverse flag:

    crash&gt; dis -r (do_no_page+65)
    0xc011ea68 &lt;do_no_page&gt;:        push   %ebp
    0xc011ea69 &lt;do_no_page+1&gt;:      mov    %esp,%ebp
    0xc011ea6b &lt;do_no_page+3&gt;:      push   %edi
    0xc011ea6c &lt;do_no_page+4&gt;:      push   %esi
    0xc011ea6d &lt;do_no_page+5&gt;:      push   %ebx
    0xc011ea6e &lt;do_no_page+6&gt;:      mov    0xc(%ebp),%ebx
    0xc011ea71 &lt;do_no_page+9&gt;:      mov    0x10(%ebp),%edx
    0xc011ea74 &lt;do_no_page+12&gt;:     mov    0x14(%ebp),%edi
    0xc011ea77 &lt;do_no_page+15&gt;:     mov    0x28(%ebx),%eax
    0xc011ea7a &lt;do_no_page+18&gt;:     test   %eax,%eax
    0xc011ea7c &lt;do_no_page+20&gt;:     je     0xc011ea85 &lt;do_no_page+29&gt;
    0xc011ea7e &lt;do_no_page+22&gt;:     mov    0x18(%eax),%ecx
    0xc011ea81 &lt;do_no_page+25&gt;:     test   %ecx,%ecx
    0xc011ea83 &lt;do_no_page+27&gt;:     jne    0xc011eab0 &lt;do_no_page+72&gt;
    0xc011ea85 &lt;do_no_page+29&gt;:     mov    $0xffffe000,%eax
    0xc011ea8a &lt;do_no_page+34&gt;:     and    %esp,%eax
    0xc011ea8c &lt;do_no_page+36&gt;:     decl   0x30(%eax)
    0xc011ea8f &lt;do_no_page+39&gt;:     jns    0xc011ea9a &lt;do_no_page+50&gt;
    0xc011ea91 &lt;do_no_page+41&gt;:     lock btrl $0x0,0xc022fb60
    0xc011ea9a &lt;do_no_page+50&gt;:     push   %edi
    0xc011ea9b &lt;do_no_page+51&gt;:     mov    0x18(%ebp),%esi
    0xc011ea9e &lt;do_no_page+54&gt;:     push   %esi
    0xc011ea9f &lt;do_no_page+55&gt;:     push   %ebx
    0xc011eaa0 &lt;do_no_page+56&gt;:     mov    0x8(%ebp),%esi
    0xc011eaa3 &lt;do_no_page+59&gt;:     push   %esi
    0xc011eaa4 &lt;do_no_page+60&gt;:     call   0xc011e9e4 &lt;do_anonymous_page&gt;
    0xc011eaa9 &lt;do_no_page+65&gt;:     jmp    0xc011eb47 &lt;do_no_page+223&gt;
    
  Disassemble 10 instructions starting at user virtual address 0x81ec624:

    crash&gt; dis -u 81ec624 10
    0x81ec624:      push   %ebp
    0x81ec625:      mov    %esp,%ebp
    0x81ec627:      sub    $0x18,%esp
    0x81ec62a:      movl   $0x1,0x8(%ebp)
    0x81ec631:      mov    0x82f9040,%eax
    0x81ec636:      mov    0x10(%eax),%edx
    0x81ec639:      and    $0x100,%edx
    0x81ec63f:      mov    0x14(%eax),%ecx
    0x81ec642:      and    $0x0,%ecx
    0x81ec645:      mov    %ecx,%eax
 
  Override the current decimal output radix format:

    crash&gt; dis sys_read 10 -x
    0xffffffff8001178f &lt;sys_read&gt;:  push   %r13
    0xffffffff80011791 &lt;sys_read+0x2&gt;:      mov    %rsi,%r13
    0xffffffff80011794 &lt;sys_read+0x5&gt;:      push   %r12
    0xffffffff80011796 &lt;sys_read+0x7&gt;:      mov    $0xfffffffffffffff7,%r12
    0xffffffff8001179d &lt;sys_read+0xe&gt;:      push   %rbp
    0xffffffff8001179e &lt;sys_read+0xf&gt;:      mov    %rdx,%rbp
    0xffffffff800117a1 &lt;sys_read+0x12&gt;:     push   %rbx
    0xffffffff800117a2 &lt;sys_read+0x13&gt;:     sub    $0x18,%rsp
    0xffffffff800117a6 &lt;sys_read+0x17&gt;:     lea    0x14(%rsp),%rsi
    0xffffffff800117ab &lt;sys_read+0x1c&gt;:     callq  0xffffffff8000b5b4 &lt;fget_light&gt;
</pre>

<h3 id="toc_0.0.6">eval</h3>
<pre>
NAME
  eval - evaluate

SYNOPSIS
  eval [-b][-l] (expression) | value

DESCRIPTION
  This command evaluates an expression or numeric value, and displays its
  result in hexadecimal, decimal, octal and binary. If the resultant value
  is an integral number of gigabytes, megabytes, or kilobytes, a short-hand
  translation of the number will also be shown next to the hexadecimal
  value.  If the most significant bit is set, the decimal display will show
  both unsigned and signed (negative) values.  Expressions must of the format
  (x operator y), where "x" and "y" may be either numeric values or
  symbols.  The list of operators are:

                     +  -  &amp;  |  ^  *  %  /  &lt;&lt;  &gt;&gt;

  Enclosing the expression within parentheses is optional except when the
  "|", "&lt;&lt;" or "&gt;&gt;" operators are used.  The single "value" argument may
  be a number or symbol.  Number arguments must be hexadecimal or decimal.
  A leading "0x" identifies a number as hexadecimal, but is not required
  when obvious.  Numbers may be followed by the letters "k" or "K", "m"
  or "M", and "g" or "G", which multiplies the value by a factor of 1024,
  1 megabyte or 1 gigabyte, respectively.  Numeric arguments may be preceded
  by the one's complement operator ~.
 
    -b  Indicate which bit positions in the resultant value are set.
    -l  Numeric arguments are presumed to be 64-bit values, and the result
        will be expressed as a 64-bit value. (ignored on 64-bit processors)
        However, if either operand or the resultant value are 64-bit values,
        then the result will be also be expressed as a 64-bit value.
 
 The -b and -l options must precede the expression or value arguments.

EXAMPLES
   crash&gt; eval 128m
   hexadecimal: 8000000  (128MB)
       decimal: 134217728  
         octal: 1000000000
        binary: 00001000000000000000000000000000
    
   crash&gt; eval 128 * 1m
   hexadecimal: 8000000  (128MB)
       decimal: 134217728  
         octal: 1000000000
        binary: 00001000000000000000000000000000
    
   crash&gt; eval (1 &lt;&lt; 27)
   hexadecimal: 8000000  (128MB)
       decimal: 134217728  
         octal: 1000000000
        binary: 00001000000000000000000000000000
   
   crash&gt; eval (1 &lt;&lt; 32)
   hexadecimal: 100000000  (4GB)
       decimal: 4294967296
         octal: 40000000000
        binary: 0000000000000000000000000000000100000000000000000000000000000000
 
   crash&gt; eval -b 41dc065
   hexadecimal: 41dc065
       decimal: 69058661  
         octal: 407340145
        binary: 00000100000111011100000001100101
      bits set: 26 20 19 18 16 15 14 6 5 2 0 
 
   crash&gt; eval -lb 64g
   hexadecimal: 1000000000  (64GB)
       decimal: 68719476736
         octal: 1000000000000
        binary: 0000000000000000000000000001000000000000000000000000000000000000
      bits set: 36
</pre>

<h3 id="toc_0.0.7">exit</h3>
<pre>
NAME
  exit - exit this session

SYNOPSIS
  exit  

DESCRIPTION
  Bail out of the current crash session.

NOTE
  This command is equivalent to the "q" command.
</pre>

<h3 id="toc_0.0.8">extend</h3>
<pre>
NAME
  extend - extend the crash command set

SYNOPSIS
  extend [shared-object ...] | [-u [shared-object ...]]

DESCRIPTION
  This command dynamically loads or unloads crash extension shared object
  libraries:

    shared-object     load the specified shared object file; more than one
                      one object file may be entered.
    -u shared-object  unload the specified shared object file; if no file
                      arguments are specified, unload all objects.

  If the shared-object filename is not expressed with a fully-qualified
  pathname, the following directories will be searched in the order shown,
  and the first instance of the file that is found will be selected:

     1. the current working directory
     2. the directory specified in the CRASH_EXTENSIONS environment variable
     3. /usr/lib64/crash/extensions (64-bit architectures)
     4. /usr/lib/crash/extensions

  If no arguments are entered, the current set of shared object files and 
  a list of their commands will be displayed.  The registered commands
  contained in each shared object file will appear automatically in the 
  "help" command screen.

  An example of a shared object prototype file, and how to compile it
  into a shared object, is appended below.

EXAMPLES
  Load two shared object files:

    crash&gt; extend extlib1.so extlib2.so
    ./extlib1.so: shared object loaded
    ./extlib2.so: shared object loaded

  Display the current set of shared object files and their commands:

    crash&gt; extend
    SHARED OBJECT  COMMANDS
    ./extlib1.so   echo util bin
    ./extlib2.so   smp show

  Unload one of the shared object files:

    crash&gt; extend -u extlib1.so
    ./extlib1.so: shared object unloaded

  Unload all currently-loaded object files:

    crash&gt; extend -u
    ./extlib2.so: shared object unloaded

CREATING A SHARED OBJECT
  The extend command loads shared object files using dlopen(3), which in
  turn calls the shared object's constructor function.  The shared object's
  constructor function should register its command set by calling 
  register_extension(), passing it a pointer to an array of one or more
  structures of the following type:
 
    struct command_table_entry {
            char *name;
            cmd_func_t func;
            char **help_data,
            ulong flags;
    };
 
  Each command_table_entry structure contains the ASCII name of a command,
  the command's function address, a pointer to an array of help data strings,
  and a flags field.  The help_data field is optional; if it is non-NULL, it
  should point to an array of character strings used by the "help"
  command, and during command failures.  The flags field currently has two
  available bit settings, REFRESH_TASK_TABLE, which should be set if it is 
  preferable to reload the current set of running processes just prior to 
  executing the command (on a live system) and MINIMAL, which should be 
  set if the command should be available in minimal mode.  Terminate the array
  of command_table_entry structures with an entry with a NULL command name.  
 
  Below is an example shared object file consisting of just one command, 
  called "echo", which simply echoes back all arguments passed to it.
  Note the comments contained within it for further details.  Cut and paste
  the following output into a file, and call it, for example, "echo.c".
  Then compiled in either of two manners.  Either manually like so:
 
 gcc -shared -rdynamic -o echo.so echo.c -fPIC -D&lt;machine-type&gt; $(TARGET_CFLAGS)
 
  where &lt;machine-type&gt; must be one of the MACHINE_TYPE #define's in defs.h,
  and where $(TARGET_CFLAGS) is the same as it is declared in the top-level
  Makefile after a build is completed.  Or alternatively, the "echo.c" file
  can be copied into the "extensions" subdirectory, and compiled automatically
  like so:
 
  make extensions
 
  The echo.so file may be dynamically linked into crash during runtime, or
  during initialization by putting "extend echo.so" into a .crashrc file
  located in the current directory, or in the user's $HOME directory.
  
---------------------------------- cut here ----------------------------------
 
#include "defs.h"      /* From the crash source top-level directory */

void echo_init(void);    /* constructor function */
void echo_fini(void);    /* destructor function (optional) */

void cmd_echo(void);     /* Declare the commands and their help data. */
char *help_echo[];

static struct command_table_entry command_table[] = {
        { "echo", cmd_echo, help_echo, 0},          /* One or more commands, */
        { NULL },                                     /* terminated by NULL, */
};


void __attribute__((constructor))
echo_init(void) /* Register the command set. */
{ 
        register_extension(command_table);
}
 
/* 
 *  This function is called if the shared object is unloaded. 
 *  If desired, perform any cleanups here. 
 */
void __attribute__((destructor))
echo_fini(void) { }


/* 
 *  Arguments are passed to the command functions in the global args[argcnt]
 *  array.  See getopt(3) for info on dash arguments.  Check out defs.h and
 *  other crash commands for usage of the myriad of utility routines available
 *  to accomplish what your task.
 */
void
cmd_echo(void)
{
        int c;

        while ((c = getopt(argcnt, args, "")) != EOF) {
                switch(c)
                {
                default:
                        argerrs++;
                        break;
                }
        }

        if (argerrs)
                cmd_usage(pc-&gt;curcmd, SYNOPSIS);

        while (args[optind]) 
                fprintf(fp, "%s ", args[optind++]);

        fprintf(fp, "\n");
}

/* 
 *  The optional help data is simply an array of strings in a defined format.
 *  For example, the "help echo" command will use the help_echo[] string
 *  array below to create a help page that looks like this:
 * 
 *    NAME
 *      echo - echoes back its arguments
 *
 *    SYNOPSIS
 *      echo arg ...
 *
 *    DESCRIPTION
 *      This command simply echoes back its arguments.
 *
 *    EXAMPLE
 *      Echo back all command arguments:
 *
 *        crash&gt; echo hello, world
 *        hello, world
 *
 */
 
char *help_echo[] = {
        "echo",                        /* command name */
        "echoes back its arguments",   /* short description */
        "arg ...",                     /* argument synopsis, or " " if none */
 
        "  This command simply echoes back its arguments.",
        "\nEXAMPLE",
        "  Echo back all command arguments:\n",
        "    crash&gt; echo hello, world",
        "    hello, world",
        NULL
};
</pre>

<h3 id="toc_0.0.9">files</h3>
<pre>
NAME
  files - open files

SYNOPSIS
  files [-d dentry] | [-R reference] [pid | taskp] ... 

DESCRIPTION
  This command displays information about open files of a context.
  It prints the context's current root directory and current working
  directory, and then for each open file descriptor it prints a pointer
  to its file struct, a pointer to its dentry struct, a pointer to the
  inode, the file type, and the pathname.  If no arguments are entered,
  the current context is used.  The -R option, typically invoked from
  "foreach files", searches for references to a supplied number, address,
  or filename argument, and prints only the essential information leading
  up to and including the reference.  The -d option is not context
  specific, and only shows the data requested.

     -d dentry  given a hexadecimal dentry address, display its inode,
                super block, file type, and full pathname.
  -R reference  search for references to this file descriptor number,
                filename, or dentry, inode, or file structure address.
           pid  a process PID.
         taskp  a hexadecimal task_struct pointer.

EXAMPLES
  Display the open files of the current context:

    crash&gt; files
    PID: 720    TASK: c67f2000  CPU: 1   COMMAND: "innd"
    ROOT: /    CWD: /var/spool/news/articles
     FD    FILE     DENTRY    INODE    TYPE  PATH
      0  c6b9c740  c7cc45a0  c7c939e0  CHR   /dev/null
      1  c6b9c800  c537bb20  c54d0000  REG   /var/log/news/news
      2  c6df9600  c537b420  c5c36360  REG   /var/log/news/errlog
      3  c74182c0  c6ede260  c6da3d40  PIPE
      4  c6df9720  c696c620  c69398c0  SOCK
      5  c6b9cc20  c68e7000  c6938d80  SOCK
      6  c6b9c920  c7cc45a0  c7c939e0  CHR   /dev/null
      7  c6b9c680  c58fa5c0  c58a1200  REG   /var/lib/news/history
      8  c6df9f00  c6ede760  c6da3200  PIPE
      9  c6b9c6e0  c58fa140  c5929560  REG   /var/lib/news/history.dir
     10  c7fa9320  c7fab160  c7fafd40  CHR   /dev/console
     11  c6b9c7a0  c58fa5c0  c58a1200  REG   /var/lib/news/history
     12  c377ec60  c58fa5c0  c58a1200  REG   /var/lib/news/history
     13  c4528aa0  c58fa6c0  c52fbb00  REG   /var/lib/news/history.pag
     14  c6df9420  c68e7700  c6938360  SOCK
     15  c6df9360  c68e7780  c6938120  SOCK
     16  c6b9c0e0  c68e7800  c6772000  SOCK
     17  c6b9c200  c6b5f9c0  c6b5cea0  REG   /var/lib/news/active
     21  c6b9c080  c6ede760  c6da3200  PIPE
 
  Display the files opened by the "crond" daemon, which is PID 462:

  crash&gt; files 462
    PID: 462    TASK: f7220000  CPU: 2   COMMAND: "crond"
    ROOT: /    CWD: /var/spool
     FD    FILE     DENTRY    INODE    TYPE  PATH
      0  f7534ae0  f7538de0  f7518dc0  CHR   /dev/console
      1  f7368f80  f72c7a40  f72f27e0  FIFO  pipe:/[1456]
      2  f74f3c80  f72c79c0  f72f2600  FIFO  pipe:/[1457]
      3  f7368b60  f72a5be0  f74300c0  REG   /var/run/crond.pid
      4  f7534360  f73408c0  f72c2840  REG   /var/log/cron
      7  f7368ce0  f72c7940  f72f2420  FIFO  pipe:/[1458]
      8  f7295de0  f72c7940  f72f2420  FIFO  pipe:/[1458]
     21  f74f36e0  f747cdc0  f747e840  CHR   /dev/null
 
  The -R option is typically invoked from "foreach files".  This example
  shows all tasks that have "/dev/pts/4" open:

    crash&gt; foreach files -R pts/4
    PID: 18633  TASK: c310a000  CPU: 0   COMMAND: "crash"
    ROOT: /    CWD: /home/CVS_pool/crash 
     FD    FILE     DENTRY    INODE    TYPE  PATH
      0  c1412850  c2cb96d0  c2cad430  CHR   /dev/pts/4
      1  c1412850  c2cb96d0  c2cad430  CHR   /dev/pts/4
      2  c1412850  c2cb96d0  c2cad430  CHR   /dev/pts/4
    
    PID: 18664  TASK: c2392000  CPU: 1   COMMAND: "less"
    ROOT: /    CWD: /home/CVS_pool/crash 
     FD    FILE     DENTRY    INODE    TYPE  PATH
      1  c1412850  c2cb96d0  c2cad430  CHR   /dev/pts/4
      2  c1412850  c2cb96d0  c2cad430  CHR   /dev/pts/4
    
    PID: 23162  TASK: c5088000  CPU: 1   COMMAND: "bash"
    ROOT: /    CWD: /home/CVS_pool/crash 
     FD    FILE     DENTRY    INODE    TYPE  PATH
      0  c1412850  c2cb96d0  c2cad430  CHR   /dev/pts/4
      1  c1412850  c2cb96d0  c2cad430  CHR   /dev/pts/4
      2  c1412850  c2cb96d0  c2cad430  CHR   /dev/pts/4
    255  c1412850  c2cb96d0  c2cad430  CHR   /dev/pts/4
    
    PID: 23159  TASK: c10fc000  CPU: 1   COMMAND: "xterm"
    ROOT: /    CWD: /homes/anderson/ 
     FD    FILE     DENTRY    INODE    TYPE  PATH
      5  c1560da0  c2cb96d0  c2cad430  CHR   /dev/pts/4
 
  Display information about the dentry at address f745fd60:

    crash&gt; files -d f745fd60
     DENTRY    INODE    SUPERBLK  TYPE  PATH
     f745fd60  f7284640  f73a3e00  REG   /var/spool/lpd/lpd.lock
</pre>

<h3 id="toc_0.0.10">foreach</h3>
<pre>
NAME
  foreach - display command data for multiple tasks in the system

SYNOPSIS
  foreach [[pid | taskp | name | state | [kernel | user]] ...]
          command [flag] [argument]

DESCRIPTION
  This command allows for a an examination of various kernel data associated
  with any, or all, tasks in the system, without having to set the context
  to each targeted task.

      pid  perform the command(s) on this PID.
    taskp  perform the command(s) on task referenced by this hexadecimal
           task_struct pointer.
     name  perform the command(s) on all tasks with this name.  If the
           task name can be confused with a foreach command name, then
           precede the name string with a "\".  If the name string is
           enclosed within "'" characters, then the encompassed string
           must be a POSIX extended regular expression that will be used
           to match task names.
     user  perform the command(s) on all user (non-kernel) threads.
   kernel  perform the command(s) on all kernel threads.
   active  perform the command(s) on the active thread on each CPU.
    state  perform the command(s) on all tasks in the specified state, which
           may be one of: RU, IN, UN, ST, ZO, TR, SW or DE.

  If none of the task-identifying arguments above are entered, the command
  will be performed on all tasks.

  command  select one or more of the following commands to be run on the tasks
           selected, or on all tasks:

              bt  run the "bt" command  (optional flags: -r -t -l -e -R -f -F
                  -o -s -x -d)
              vm  run the "vm" command  (optional flags: -p -v -m -R -d -x)
            task  run the "task" command  (optional flags: -R -d -x)
           files  run the "files" command  (optional flag: -R)
             net  run the "net" command  (optional flags: -s -S -R -d -x)
             set  run the "set" command
              ps  run the "ps" command  (optional flags: -G -s -p -c -t -l -a
                  -g -r)
             sig  run the "sig" command (optional flag: -g)
            vtop  run the "vtop" command  (optional flags: -c -u -k)

     flag  Pass this optional flag to the command selected.
 argument  Pass this argument to the command selected.
 
  A header containing the PID, task address, cpu and command name will be
  pre-pended before the command output for each selected task.  Consult the
  help page of each of the command types above for details.

EXAMPLES
  Display the stack traces for all tasks:

    crash&gt; foreach bt
    PID: 4752   TASK: c7680000  CPU: 1   COMMAND: "xterm"
     #0 [c7681edc] schedule at c01135f6
        (void)
     #1 [c7681f34] schedule_timeout at c01131ff
        (24)
     #2 [c7681f64] do_select at c0132838
        (5, c7681fa4, c7681fa0)
     #3 [c7681fbc] sys_select at c0132dad
        (5, 8070300, 8070380, 0, 0)
     #4 [bffffb0c] system_call at c0109944
        EAX: 0000008e  EBX: 00000005  ECX: 08070300  EDX: 08070380 
        DS:  002b      ESI: 00000000  ES:  002b      EDI: 00000000 
        SS:  002b      ESP: bffffadc  EBP: bffffb0c 
        CS:  0023      EIP: 402259ee  ERR: 0000008e  EFLAGS: 00000246 
    
    PID: 557    TASK: c5600000  CPU: 0   COMMAND: "nfsd"
     #0 [c5601f38] schedule at c01135f6
        (void)
     #1 [c5601f90] schedule_timeout at c01131ff
        (c5600000)
     #2 [c5601fb8] svc_recv at c805363a
        (c0096f40, c5602800, 7fffffff, 100, c65c9f1c)
     #3 [c5601fec] (nfsd module) at c806e303
        (c5602800, c5602800, c0096f40, 6c6e0002, 50)
     #4 [c65c9f24] kernel_thread at c010834f
        (0, 0, ext2_file_inode_operations)
    
    PID: 824    TASK: c7c84000  CPU: 0   COMMAND: "mingetty"
    ...

  Display the task_struct structure for each "bash" command:

    crash&gt; foreach bash task
    ...

  Display the open files for all tasks:

    crash&gt; foreach files
    ...

  Display the state of tasks whose name contains a match to "event.*":

    crash&gt; foreach 'event.*' task -R state
    PID: 99     TASK: ffff8804750d5500  CPU: 0   COMMAND: "events/0"
      state = 1,
    
    PID: 100    TASK: ffff8804750d4ac0  CPU: 1   COMMAND: "events/1"
      state = 1,
    
    PID: 101    TASK: ffff8804750d4080  CPU: 2   COMMAND: "events/2"
      state = 1,
    ...

  Display the stack traces for all blocked (TASK_UNINTERRUPTIBLE) tasks:

    crash&gt; foreach UN bt
    PID: 428    TASK: ffff880036b6c560  CPU: 1   COMMAND: "jbd2/dm-1-8"
     #0 [ffff880035779a70] __schedule at ffffffff815df272
     #1 [ffff880035779b08] schedule at ffffffff815dfacf
     #2 [ffff880035779b18] io_schedule at ffffffff815dfb7f
     #3 [ffff880035779b38] sleep_on_page at ffffffff81119a4e
     #4 [ffff880035779b48] __wait_on_bit at ffffffff815e039f
     #5 [ffff880035779b98] wait_on_page_bit at ffffffff81119bb8
     #6 [ffff880035779be8] filemap_fdatawait_range at ffffffff81119ccc
     #7 [ffff880035779cd8] filemap_fdatawait at ffffffff81119d8b
     #8 [ffff880035779ce8] jbd2_journal_commit_transaction at ffffffff8123a99c
     #9 [ffff880035779e58] kjournald2 at ffffffff8123ee7b
    #10 [ffff880035779ee8] kthread at ffffffff8108fb9c
    #11 [ffff880035779f48] kernel_thread_helper at ffffffff815ebaf4
    ...
</pre>

<h3 id="toc_0.0.11">fuser</h3>
<pre>
NAME
  fuser - file users

SYNOPSIS
  fuser [pathname | inode]

DESCRIPTION
  This command displays the tasks using specified files or sockets.
  Tasks will be listed that reference the file as the current working
  directory, root directory, an open file descriptor, or that mmap the
  file.  If the file is held open in the kernel by the lockd server on
  behalf of a client discretionary file lock, the client hostname is
  listed.

    pathname  the full pathname of the file.
    inode     the hexadecimal inode address for the file.

EXAMPLES
  Display the tasks using file /usr/lib/libkfm.so.2.0.0

    crash&gt; fuser /usr/lib/libkfm.so.2.0.0
     PID    TASK    COMM            USAGE
     779  c5e82000  "kwm"           mmap
     808  c5a8e000  "krootwm"       mmap
     806  c5b42000  "kfm"           mmap
     809  c5dde000  "kpanel"        mmap
</pre>

<h3 id="toc_0.0.12">ipcs</h3>
<pre>
NAME
  ipcs - System V IPC facilities

SYNOPSIS
  ipcs [-smMq] [-n pid|task] [id | addr]

DESCRIPTION
  This command provides information on the System V IPC facilities.  With no
  arguments, the command will display kernel usage of all three factilities.
  
       -s  show semaphore arrays.
       -m  show shared memory segments.
       -M  show shared memory segments with additional details.
       -q  show message queues.
       id  show the data associated with this resource ID.
     addr  show the data associated with this virtual address of a
           shmid_kernel, sem_array or msq_queue.

  For kernels supporting namespaces, the -n option may be used to
  display the IPC facilities with respect to the namespace of a
  specified task:

  -n pid   a process PID.
  -n task  a hexadecimal task_struct pointer.

EXAMPLES
  Display all IPC facilities:

    crash&gt; ipcs
    SHMID_KERNEL     KEY      SHMID      UID   PERMS BYTES      NATTCH STATUS
    ffff880473a28310 00000000 0          0     666   90000      1       
    ffff880473a28490 00000001 32769      0     666   90000      1       
    ffff880473a28250 00000002 65538      0     666   90000      1       
    
    SEM_ARRAY        KEY      SEMID      UID   PERMS NSEMS     
    ffff88047200f9d0 00000000 0          0     600   1         
    ffff88046f826910 00000000 32769      0     600   1         
    
    MSG_QUEUE        KEY      MSQID      UID   PERMS USED-BYTES   MESSAGES
    ffff8100036bb8d0 000079d7 0          3369  666   16640        104
    ffff8100036bb3d0 000079d8 32769      3369  666   12960        81
    ffff810026d751d0 000079d9 65538      3369  666   10880        68
    
  Display shared memory usage with detailed information:

    crash&gt; ipcs -M
    SHMID_KERNEL     KEY      SHMID      UID   PERMS BYTES      NATTCH STATUS
    ffff880473a28310 00000000 0          0     666   90000      1       
    PAGES ALLOCATED/RESIDENT/SWAPPED: 22/1/0
    INODE: ffff88047239cd98
    
    SHMID_KERNEL     KEY      SHMID      UID   PERMS BYTES      NATTCH STATUS
    ffff880473a28490 00000001 32769      0     666   90000      1       
    PAGES ALLOCATED/RESIDENT/SWAPPED: 22/1/0
    INODE: ffff88047239c118
    
    SHMID_KERNEL     KEY      SHMID      UID   PERMS BYTES      NATTCH STATUS
    ffff880473a28250 00000002 65538      0     666   90000      1       
    PAGES ALLOCATED/RESIDENT/SWAPPED: 22/1/0
    INODE: ffff880470503758
    
  Display the shared memory data associated with shmid_kernel ffff880473a28250:

    crash&gt; ipcs -M ffff880473a28250
    SHMID_KERNEL     KEY      SHMID      UID   PERMS BYTES      NATTCH STATUS
    ffff880473a28250 00000002 65538      0     666   90000      1       
    PAGES ALLOCATED/RESIDENT/SWAPPED: 22/1/0
    INODE: ffff880470503758
</pre>

<h3 id="toc_0.0.13">irq</h3>
<pre>
NAME
  irq - IRQ data

SYNOPSIS
  irq [[[index ...] | -u ] | -d | -b | -a | -s [-c cpu]]

DESCRIPTION
  This command collaborates the data in an irq_desc_t, along with its
  associated hw_interrupt_type and irqaction structure data, into a
  consolidated per-IRQ display.  For kernel versions 2.6.37 and later
  the display consists of the irq_desc/irq_data address, its irqaction
  address(es), and the irqaction name strings.  Alternatively, the
  intel interrupt descriptor table, bottom half data, cpu affinity for
  in-use irqs, or kernel irq stats may be displayed.  If no index value
  argument(s) nor any options are entered, the IRQ data for all IRQs will
  be displayed.

    index   a valid IRQ index.
       -u   dump data for in-use IRQs only.
       -d   dump the intel interrupt descriptor table.
       -b   dump bottom half data.
       -a   dump cpu affinity for in-use IRQs.
       -s   dump the kernel irq stats; if no cpu specified with -c, the
            irq stats of all cpus will be displayed.
   -c cpu   only usable with the -s option, dump the irq stats of the 
            specified cpu[s]; cpu can be specified as "1,3,5", "1-3",
            "1,3,5-7,10", "all", or "a" (shortcut for "all").

EXAMPLES
  Display the relevant data for IRQ 18 from a pre-2.6.37 kernel:

    crash&gt; irq 18
        IRQ: 18
     STATUS: 0 
    HANDLER: c02301e0  &lt;ioapic_level_irq_type&gt;
             typename: c01f9e0c  "IO-APIC-level"
              startup: c0110234  &lt;unmask_IO_APIC_irq&gt;
             shutdown: c01101cc  &lt;mask_IO_APIC_irq&gt;
               handle: c0110518  &lt;do_level_ioapic_IRQ&gt;
               enable: c0110234  &lt;unmask_IO_APIC_irq&gt;
              disable: c01101cc  &lt;mask_IO_APIC_irq&gt;
     ACTION: c009c6b0
              handler: c01ce818  &lt;do_aic7xxx_isr&gt;
                flags: 4000000  (SA_SHIRQ)
                 mask: 0
                 name: c0217780  "aic7xxx"
               dev_id: c0090078
                 next: c009c770
     ACTION: c009c770
              handler: c01ce818  &lt;do_aic7xxx_isr&gt;
                flags: 4000000  (SA_SHIRQ)
                 mask: 0
                 name: c0217780  "aic7xxx"
               dev_id: c0091078
                 next: 0
      DEPTH: 0

  Display the relevant data for IRQ 21 from a 2.6.37 kernel:

    crash&gt; irq 21
     IRQ   IRQ_DESC/_DATA      IRQACTION      NAME
     21   ffff88003787f780  ffff8800379a8b40  "ehci_hcd:usb2"
                            ffff8800379cbac0  "uhci_hcd:usb5"
                            ffff8800379cb140  "uhci_hcd:usb7"
 
  Display the intel interrupt descriptor table entries:

    crash&gt; irq -d
      [0] divide_error
      [1] debug
      [2] nmi
      [3] int3
      [4] overflow
      [5] bounds
      [6] invalid_op
      [7] device_not_available
      [8] double_fault
      [9] coprocessor_segment_overrun
     [10] invalid_TSS
     [11] segment_not_present
     [12] stack_segment
     [13] general_protection
     [14] page_fault
     [15] spurious_interrupt_bug
     [16] coprocessor_error
     [17] alignment_check
     [18] ignore_int
     [19] ignore_int
     [20] ignore_int
     [21] ignore_int
    ...

    [250] IRQ0xda_interrupt
    [251] IRQ0xdb_interrupt
    [252] IRQ0xdc_interrupt
    [253] IRQ0xdd_interrupt
    [254] IRQ0xde_interrupt
    [255] spurious_interrupt

  Display the bottom half data:

    crash&gt; irq -b
    SOFTIRQ_VEC      ACTION     
        [0]     ffffffff81068f60  &lt;tasklet_hi_action&gt; 
        [1]     ffffffff81071b80  &lt;run_timer_softirq&gt; 
        [2]     ffffffff813e6f30  &lt;net_tx_action&gt; 
        [3]     ffffffff813ee370  &lt;net_rx_action&gt; 
        [4]     ffffffff81211a60  &lt;blk_done_softirq&gt; 
        [5]     ffffffff812122f0  &lt;blk_iopoll_softirq&gt; 
        [6]     ffffffff81069090  &lt;tasklet_action&gt; 
        [7]     ffffffff81058830  &lt;run_rebalance_domains&gt; 
        [8]     ffffffff81087f00  &lt;run_hrtimer_softirq&gt; 
        [9]     ffffffff810ca7a0  &lt;rcu_process_callbacks&gt; 

  Display the cpu affinity for in-use IRQs:

    crash&gt; irq -a
    IRQ NAME                 AFFINITY
      0 timer                0-23
      1 i8042                0-23
      8 rtc0                 0-23
      9 acpi                 0-23
     16 ehci_hcd:usb2,uhci_hcd:usb3,uhci_hcd:usb6 0,6,18
     17 uhci_hcd:usb4,uhci_hcd:usb7 0-23
     18 ehci_hcd:usb1,uhci_hcd:usb5,uhci_hcd:usb8,ioc0 0,11,23
     24 dmar0                0
     35 pciehp               0-23
     36 pciehp               0-23
     37 pciehp               0-23
     38 pciehp               0-23
     39 megasas              0-5,12-17
     40 lpfc:sp              0-5,12-17
     41 lpfc:fp              0,6-11,18-23
     42 lpfc:sp              0,6-11,18-23
     43 lpfc:fp              0,6-11,18-23
    ...

     80 ioat-msix            0-23
     81 ioat-msix            0-23
     82 ioat-msix            0-23
     83 ioat-msix            0-23
     84 ioat-msix            0-23
     85 ioat-msix            0-23
     86 ioat-msix            0-23
     87 ioat-msix            0-23
     88 eth4                 0,17

  Display the kernel irq stats:

    crash&gt;irq -c 0,2 -s
               CPU0       CPU2 
      0: 2068161471          0 IR-IO-APIC-edge     timer
      1:          9          0 IR-IO-APIC-edge     i8042
      8:          1          0 IR-IO-APIC-edge     rtc0
      9:          0          0 IR-IO-APIC-fasteoi  acpi
     16:         36          0 IR-IO-APIC-fasteoi  ehci_hcd:usb2
    ...

     85:          3          0 IR-PCI-MSI-edge     ioat-msix
     86:          3          0 IR-PCI-MSI-edge     ioat-msix
     87:          3          0 IR-PCI-MSI-edge     ioat-msix
     88:         24        295 IR-PCI-MSI-edge     eth4
</pre>

<h3 id="toc_0.0.14">kmem</h3>
<pre>
NAME
  kmem - kernel memory

SYNOPSIS
  kmem [-f|-F|-p|-c|-C|-i|-s|-S|-v|-V|-n|-z-o] [slab] [[-P] address]
       [-g [flags]] [-I slab[,slab]]

DESCRIPTION
  This command displays information about the use of kernel memory.

        -f  displays the contents of the system free memory headers.
            also verifies that the page count equals nr_free_pages.
        -F  same as -f, but also dumps all pages linked to that header.
        -p  displays basic information about each page in the system 
            mem_map[] array.
        -c  walks through the page_hash_table and verifies page_cache_size.
        -C  same as -c, but also dumps all pages in the page_hash_table.
        -i  displays general memory usage information
        -s  displays basic kmalloc() slab data.
        -S  displays all kmalloc() slab data, including all slab objects,
            and whether each object is in use or is free.  If CONFIG_SLUB,
            slab data for each per-cpu slab is displayed, along with the
            address of each kmem_cache_node, its count of full and partial
            slabs, and a list of all tracked slabs.
        -v  displays the mapped virtual memory regions allocated by vmalloc().
        -V  displays the kernel vm_stat table if it exists, the cumulative
            page_states counter values if they exist, and/or the cumulative
            vm_event_states counter values if they exist.
        -n  display memory node data (if supported).
        -z  displays per-zone memory statistics.
        -o  displays each cpu's offset value that is added to per-cpu symbol
            values to translate them into kernel virtual addresses.
        -g  displays the enumerator value of all bits in the page structure's
            "flags" field.
     flags  when used with -g, translates all bits in this hexadecimal page
            structure flags value into its enumerator values.
      slab  when used with -s or -S, limits the command to only the slab cache
            of name "slab".  If the slab argument is "list", then
            all slab cache names and addresses are listed.
   -I slab  when used with -s or -S, one or more slab cache names in a
            comma-separated list may be specified as slab caches to ignore.
        -P  declares that the following address argument is a physical address.
   address  when used without any flag, the address can be a kernel virtual,
            or physical address; a search is made through the symbol table,
            the kmalloc() slab subsystem, the free list, the page_hash_table,
            the vmalloc() region subsystem, the current set of task_structs
            and kernel stacks, and the mem_map array.  If found in any of
            those areas, the information will be dumped in the same manner as
            if the location-specific flags were used; if contained within a
            curent task_struct or kernel stack, that task's context will be
            displayed.
   address  when used with -s or -S, searches the kmalloc() slab subsystem
            for the slab containing of this virtual address, showing whether
            it is in use or free.
   address  when used with -f, the address can be either a page pointer,
            a physical address, or a kernel virtual address; the free_area
            header containing the page (if any) is displayed.
   address  when used with -p, the address can be either a page pointer, a
            physical address, or a kernel virtual address; its basic mem_map
            page information is displayed.
   address  when used with -c, the address must be a page pointer address;
            the page_hash_table entry containing the page is displayed.
   address  when used with -l, the address must be a page pointer address;
            the page address is displayed if it is contained with the list.
   address  when used with -v, the address can be a mapped kernel virtual
            address or physical address; the mapped region containing the
            address is displayed.

  All address arguments above must be expressed in hexadecimal format.

EXAMPLES
  Display memory usage information:

    crash&gt; kmem -i
                  PAGES        TOTAL      PERCENTAGE
     TOTAL MEM    63602     248.4 MB         ----
          FREE      993       3.9 MB    1% of TOTAL MEM
          USED    62609     244.6 MB   98% of TOTAL MEM
        SHARED    34035     132.9 MB   53% of TOTAL MEM
       BUFFERS    10928      42.7 MB   17% of TOTAL MEM
        CACHED    35249     137.7 MB   55% of TOTAL MEM
          SLAB     2823        11 MB    4% of TOTAL MEM
    
    TOTAL HIGH        0            0    0% of TOTAL MEM
     FREE HIGH        0            0    0% of TOTAL HIGH
     TOTAL LOW    63602     248.4 MB  100% of TOTAL MEM
      FREE LOW      993       3.9 MB    1% of TOTAL LOW
    
    TOTAL SWAP   129792       507 MB         ----
     SWAP USED    14727      57.5 MB   11% of TOTAL SWAP
     SWAP FREE   115065     449.5 MB   88% of TOTAL SWAP
    
    ZONE  NAME      FREE   ACTIVE  INACTIVE_DIRTY  INACTIVE_CLEAN  MIN/LOW/HIGH
      0   DMA        240     1166               7             161  128/256/384 
      1   Normal     753    17009           27834               0  255/510/765 
      2   HighMem      0        0               0               0     0/0/0    
 
  Display and verify free memory data:

    crash&gt; kmem -f
    NODE
      0
    ZONE  NAME        SIZE    FREE  MEM_MAP   START_PADDR  START_MAPNR
      0   DMA         4096    3372  c4000040       0            0     
    AREA  SIZE  FREE_AREA_STRUCT  BLOCKS  PAGES
      0     4k      c02eb004           2      2
      1     8k      c02eb010           3      6
      2    16k      c02eb01c           5     20
      3    32k      c02eb028           4     32
      4    64k      c02eb034           5     80
      5   128k      c02eb040           3     96
      6   256k      c02eb04c           3    192
      7   512k      c02eb058           1    128
      8  1024k      c02eb064           1    256
      9  2048k      c02eb070           5   2560
 
    ZONE  NAME        SIZE    FREE  MEM_MAP   START_PADDR  START_MAPNR
      1   Normal    225280  202269  c4044040    1000000        4096   
    AREA  SIZE  FREE_AREA_STRUCT  BLOCKS  PAGES
      0     4k      c02eb0b8           1      1
      1     8k      c02eb0c4           2      4
      2    16k      c02eb0d0           0      0
      3    32k      c02eb0dc           1      8
      4    64k      c02eb0e8           1     16
      5   128k      c02eb0f4           0      0
      6   256k      c02eb100           0      0
      7   512k      c02eb10c           0      0
      8  1024k      c02eb118           0      0
      9  2048k      c02eb124         395 202240
 
    ZONE  NAME        SIZE    FREE  MEM_MAP   START_PADDR  START_MAPNR
      2   HighMem   819200  748686  c4ee0040    38000000      229376  
    AREA  SIZE  FREE_AREA_STRUCT  BLOCKS  PAGES
      0     4k      c02eb16c          10     10
      1     8k      c02eb178           2      4
      2    16k      c02eb184           0      0
      3    32k      c02eb190           2     16
      4    64k      c02eb19c           1     16
      5   128k      c02eb1a8           1     32
      6   256k      c02eb1b4           1     64
      7   512k      c02eb1c0           0      0
      8  1024k      c02eb1cc           0      0
      9  2048k      c02eb1d8        1462 748544
    
    nr_free_pages: 954327  (verified)
 
  Dump all the base addresses of each free memory area from above:

    crash&gt; kmem -F
    NODE
      0
    ZONE  NAME        SIZE    FREE  MEM_MAP   START_PADDR  START_MAPNR
      0   DMA         4096    3372  c4000040       0            0     
    AREA  SIZE  FREE_AREA_STRUCT
      0     4k      c02eb004      
    c400ded8
    c4042528
    AREA  SIZE  FREE_AREA_STRUCT
      1     8k      c02eb010      
    c400de50
    c400cee8
    c40424a0
    AREA  SIZE  FREE_AREA_STRUCT
      2    16k      c02eb01c      
    c400dd40
    c400cf70
    c40425b0
    c400f7d0
    c40028a0
    AREA  SIZE  FREE_AREA_STRUCT
      3    32k      c02eb028      
    c4042280
    c400f8e0
    c4002680
    c4000260
    AREA  SIZE  FREE_AREA_STRUCT
      4    64k      c02eb034      
    c400d080
    c4041e40
    ...
 
  Dump the mem_map[] array:

    crash&gt; kmem -p
      PAGE    PHYSICAL   MAPPING    INDEX CNT FLAGS
    f5c51200     10000         0         0  1 80 slab
    f5c51220     11000         0         0  1 80 slab
    f5c51240     12000         0         0  1 80 slab
    f5c51260     13000         0         0  1 80 slab
    f5c51280     14000         0         0  1 80 slab
    f5c512a0     15000         0         0  1 80 slab
    f5c512c0     16000         0         0  1 80 slab
    f5c512e0     17000         0         0  1 80 slab
    f5c51300     18000         0         0  1 80 slab
    f5c51320     19000         0         0  1 80 slab
    f5c51340     1a000         0         0  1 80 slab
    f5c51360     1b000         0         0  1 80 slab
    f5c51380     1c000  e6c6a754     13b67  2 868 uptodate,lru,active,private
    f5c513a0     1d000         0         0  1 80 slab
    f5c513c0     1e000         0         0  1 80 slab
    f5c513e0     1f000         0         0  1 80 slab
    f5c51400     20000  e6c6a754     13bbb  2 868 uptodate,lru,active,private
    f5c51420     21000         0         0  1 80 slab
    f5c51440     22000         0         0  1 80 slab
    ...
    
  Use the commands above with a page pointer or a physical address argument:

    crash&gt; kmem -f c40425b0
    NODE 
      0 
    ZONE  NAME        SIZE    FREE  MEM_MAP   START_PADDR  START_MAPNR
      0   DMA         4096    3372  c4000040       0            0     
    AREA  SIZE  FREE_AREA_STRUCT 
      2    16k      c02eb01c      
    c40425b0  (c40425b0 is 1st of 4 pages) 
 
    crash&gt; kmem -p c25a9c00
      PAGE     PHYSICAL   MAPPING    INDEX CNT FLAGS
    c25a9c00    1fe0000  f429d2e4   21fe3eb  2 800828 uptodate,lru,private
 
    crash&gt; kmem -p 1fe0000
      PAGE     PHYSICAL   MAPPING    INDEX CNT FLAGS
    c25a9c00    1fe0000  f429d2e4   21fe3eb  2 800828 uptodate,lru,private
 
  Display the mapped memory regions allocated by vmalloc():

    crash&gt; kmem -v
    VMAP_AREA  VM_STRUCT     ADDRESS RANGE        SIZE
    f7048e00   f7048e40   f7dfe000 - f7e00000     8192
    f7048ec0   f7048f00   f7e00000 - f7e05000    20480
    f7151fc0   f7159540   f7e06000 - f7e08000     8192
    f704da80   f704dac0   f7e0a000 - f7e0c000     8192
    f704d980   f704d9c0   f7e0e000 - f7e10000     8192
    f724f1c0   f724f200   f7e12000 - f7e14000     8192
    f704d840   f704d880   f7e14000 - f7e17000    12288
    f704d400   f704d440   f7e18000 - f7e1d000    20480
    f73f5840   f73f5880   f7e1e000 - f7e2a000    49152
    f6334480   f63344c0   f7e2c000 - f7e2e000     8192
    f635d600   f635d640   f7e4a000 - f7e5b000    69632
    f41b4700   f5771a40   f7e6e000 - f7e70000     8192
    f622f6c0   f622f700   f7e71000 - f7e79000    32768
    f63a9f00   f63a9f40   f7e84000 - f7e87000    12288
    f63a9d00   f63a9d40   f7e8f000 - f7e91000     8192
    f5546480   f39db800   f7eb8000 - f7ec2000    40960
    f5ce9640   f5777e80   f7ec6000 - f7ed1000    45056
    f63a9b00   f63a9b40   f7ed1000 - f7efd000   180224
    f63a9800   f63a9840   f7f1d000 - f7f26000    36864
    f63a9640   f63a9880   f7f43000 - f7f52000    61440
    f5771f00   f4183840   f7f53000 - f7f64000    69632
    f5ce9a00   f30c4a00   f7fcf000 - f801e000   323584
    f63a93c0   f63a9400   f805d000 - f8132000   872448
    f63a91c0   f63a95c0   f814b000 - f8150000    20480
    f63a9140   f63a9180   f8151000 - f8352000  2101248
    f624eb00   f624eb40   f8353000 - f8355000     8192
    f563eb40   f563eb80   f8356000 - f835e000    32768
    f63d5ec0   f63d5f00   f8360000 - f8371000    69632
    f63d5cc0   f6287b80   f83c2000 - f84c3000  1052672
    ...
 
  Dump the vm_table contents:

    crash&gt; kmem -V
           NR_ANON_PAGES: 38989
          NR_FILE_MAPPED: 3106
           NR_FILE_PAGES: 169570
                 NR_SLAB: 32439
            NR_PAGETABLE: 1181
           NR_FILE_DIRTY: 4633
            NR_WRITEBACK: 0
         NR_UNSTABLE_NFS: 0
               NR_BOUNCE: 0
                NUMA_HIT: 63545992
               NUMA_MISS: 0
            NUMA_FOREIGN: 0
     NUMA_INTERLEAVE_HIT: 24002
              NUMA_LOCAL: 63545992
              NUMA_OTHER: 0
 
  Determine (and verify) the page cache size:

    crash&gt; kmem -c
    page_cache_size: 18431 (verified)
 
  Dump all pages in the page_hash_table:

    crash&gt; kmem -C
    page_hash_table[0]
    c0325b40
    c03a0598
    c03b4070
    c0364c28
    c0357690
    c02ef338
    c02d7c60
    c02c11e0
    c02a3d70
    page_hash_table[1]
    c0394ce8
    c03c4218
    c03b4048
    c0364c00
    c0357668
    c02d6e50
    c02d7dc8
    c02c0cb8
    c02db630
    c02ebad0
    page_hash_table[2]
    c037e808
    c034e248
    c03b4020
    c02ec868
    c03baa60
    ...
    page_hash_table[2047]
    c033a798
    c0390b48
    c03b4098
    c0364890
    c03576b8
    c02d2c38
    c02d7c88
    c02de5d8
    
    page_cache_size: 18437 (verified)
    
  Find the page_hash_table entry containing page c03576b8:

    crash&gt; kmem -c c03576b8
    page_hash_table[2047]
    c03576b8
 
  Display kmalloc() slab data:

    crash&gt; kmem -s
    CACHE     NAME                OBJSIZE  ALLOCATED     TOTAL  SLABS  SSIZE
    c02eadc0 kmem_cache               232         58        68      4     4k
    f79c2888 ip_vs_conn               128          0         0      0     4k
    f79c2970 tcp_tw_bucket             96          0         0      0     4k
    f79c2a58 tcp_bind_bucket           32         12       565      5     4k
    f79c2b40 tcp_open_request          64          0        59      1     4k
    f79c2c28 inet_peer_cache           64          1        59      1     4k
    f79c2d10 ip_fib_hash               32         11       339      3     4k
    f79c2df8 ip_dst_cache             160          8       120      5     4k
    f79c2ee0 arp_cache                128          1        30      1     4k
    c8402970 blkdev_requests           96      30208     37800    945     4k
    c8402a58 nfs_read_data            384          0         0      0     4k
    c8402b40 nfs_write_data           384          0         0      0     4k
    c8402c28 nfs_page                  96          0         0      0     4k
    c8402d10 dnotify cache             20          0         0      0     4k
    c8402df8 file lock cache           92          3       336      8     4k
    c8402ee0 fasync cache              16          0         0      0     4k
    c84027a0 uid_cache                 32          3       339      3     4k
    c84026b8 skbuff_head_cache        160        320       624     26     4k
    c84025d0 sock                     832         32       180     20     8k
    c84024e8 sigqueue                 132          0       203      7     4k
    c8402400 cdev_cache                64         19       472      8     4k
    c8402318 bdev_cache                64          8       236      4     4k
    c8402230 mnt_cache                 96         11       120      3     4k
    c8402148 inode_cache              480        817       848    106     4k
    c8402060 dentry_cache             128       1352      1470     49     4k
    c8403ee0 filp                      96        244       440     11     4k
    c8403df8 names_cache             4096          0        12     12     4k
    c8403d10 buffer_head               96      14936     16000    400     4k
    c8403c28 mm_struct                128         25       240      8     4k
    c8403b40 vm_area_struct            64        393      1298     22     4k
    c8403a58 fs_cache                  64         30       472      8     4k
    c8403970 files_cache              416         30       135     15     4k
    c8403888 signal_act              1312         32        99     33     4k
    c84037a0 size-131072(DMA)      131072          0         0      0   128k
    c84036b8 size-131072           131072          1         1      1   128k
    c84035d0 size-65536(DMA)        65536          0         0      0    64k
    c84034e8 size-65536             65536          0         0      0    64k
    c8403400 size-32768(DMA)        32768          0         0      0    32k
    c8403318 size-32768             32768          0         1      1    32k
    c8403230 size-16384(DMA)        16384          0         0      0    16k
    c8403148 size-16384             16384          0         0      0    16k
    c8403060 size-8192(DMA)          8192          0         0      0     8k
    c8401ee0 size-8192               8192          1         2      2     8k
    c8401df8 size-4096(DMA)          4096          0         0      0     4k
    c8401d10 size-4096               4096         30        30     30     4k
    c8401c28 size-2048(DMA)          2048          0         0      0     4k
    c8401b40 size-2048               2048         37       132     66     4k
    c8401a58 size-1024(DMA)          1024          0         0      0     4k
    c8401970 size-1024               1024        301       328     82     4k
    c8401888 size-512(DMA)            512          0         0      0     4k
    c84017a0 size-512                 512        141       168     21     4k
    c84016b8 size-256(DMA)            256          0         0      0     4k
    c84015d0 size-256                 256         80       435     29     4k
    c84014e8 size-128(DMA)            128          0         0      0     4k
    c8401400 size-128                 128        508       840     28     4k
    c8401318 size-64(DMA)              64          0         0      0     4k
    c8401230 size-64                   64        978      1357     23     4k
    c8401148 size-32(DMA)              32          0         0      0     4k
    c8401060 size-32                   32       1244      1808     16     4k
 
  Display all slab data in the "arp_cache" cache:

    crash&gt; kmem -S arp_cache
    CACHE     NAME                OBJSIZE  ALLOCATED     TOTAL  SLABS  SSIZE
    f79c2ee0 arp_cache                128          1        30      1     4k
    SLAB      MEMORY    TOTAL  ALLOCATED  FREE
    f729d000  f729d0a0     30          1    29
    FREE / [ALLOCATED]
       f729d0a0  (cpu 7 cache)
       f729d120  (cpu 7 cache)
       f729d1a0  (cpu 7 cache)
       f729d220  (cpu 7 cache)
       f729d2a0  (cpu 7 cache)
       f729d320  (cpu 7 cache)
       f729d3a0  (cpu 7 cache)
       f729d420  (cpu 7 cache)
       f729d4a0  (cpu 7 cache)
       f729d520  (cpu 7 cache)
       f729d5a0  (cpu 7 cache)
       f729d620  (cpu 7 cache)
       f729d6a0  (cpu 7 cache)
       f729d720  (cpu 7 cache)
       f729d7a0  (cpu 7 cache)
       f729d820  (cpu 7 cache)
       f729d8a0  (cpu 7 cache)
       f729d920  (cpu 7 cache)
       f729d9a0  (cpu 7 cache)
       f729da20  (cpu 7 cache)
       f729daa0  (cpu 7 cache)
       f729db20  (cpu 7 cache)
       f729dba0  (cpu 7 cache)
       f729dc20  (cpu 7 cache)
       f729dca0  (cpu 7 cache)
       f729dd20  (cpu 7 cache)
       f729dda0  (cpu 7 cache)
       f729de20  (cpu 7 cache)
       f729dea0  (cpu 3 cache)
      [f729df20]
 
  Search the kmalloc() slab subsystem for address c3fbdb60:

    crash&gt; kmem -s c3fbdb60
    CACHE     NAME                OBJSIZE  ALLOCATED     TOTAL  SLABS  SSIZE
    c8402970 blkdev_requests           96      30208     37800    945     4k
    SLAB      MEMORY    TOTAL  ALLOCATED  FREE
    c3fbd020  c3fbd0e0     40         40     0
    FREE / [ALLOCATED]
      [c3fbdb60]
 
  Make a generic search (no flags) for the same address c3fbdb60:

    crash&gt; kmem c3fbdb60 
    CACHE     NAME                OBJSIZE  ALLOCATED     TOTAL  SLABS  SSIZE
    c8402970 blkdev_requests           96      30208     37800    945     4k
    SLAB      MEMORY    TOTAL  ALLOCATED  FREE
    c3fbd020  c3fbd0e0     40         40     0 
    FREE / [ALLOCATED]
      [c3fbdb60]
 
      PAGE     PHYSICAL   MAPPING    INDEX CNT FLAGS
    c410ee74    3fbd000         0         0  1 slab

  Display memory node data (if supported):

    crash&gt; kmem -n
    NODE    SIZE    PGLIST_DATA   BOOTMEM_DATA   NODE_ZONES
      0    130933     c0332ee0      c0403a44      c0332ee0
                                                  c03333e0
                                                  c03338e0
    MEM_MAP   START_PADDR  START_MAPNR
    c1000030       0            0
    
    ZONE  NAME        SIZE   MEM_MAP  START_PADDR  START_MAPNR
      0   DMA         4096  c1000030            0            0
      1   Normal    126837  c1038030      1000000         4096
      2   HighMem        0         0            0            0

  Translate a page structure's flags field contents:

    crash&gt; kmem -g 4080
    FLAGS: 4080
      PAGE-FLAG        BIT  VALUE
      PG_slab            7  0000080
      PG_head           14  0004000
    crash&gt;
</pre>

<h3 id="toc_0.0.15">list</h3>
<pre>
NAME
  list - linked list

SYNOPSIS
  list [[-o] offset][-e end][-s struct[.member[,member]] -[xd]] [-r|-h|-H] start

DESCRIPTION
  This command dumps the contents of a linked list.  The entries in a linked
  list are typically data structures that are tied together in one of two
  formats:
 
  1. A starting address points to a data structure; that structure contains
     a member that is a pointer to the next structure, and so on.  This type
     of a singly-linked list typically ends when a "next" pointer value 
     contains one of the following:

       (a) a NULL pointer.
       (b) a pointer to the start address.
       (c) a pointer to the first item pointed to by the start address.
       (d) a pointer to its containing structure.
  
  2. Most Linux lists of data structures are doubly-linked using "list_head"
     structures that are embedded members of the data structures in the list:
 
       struct list_head {
           struct list_head *next, *prev;
       };
 
     The linked list is typically headed by an external, standalone list_head,
     which is simply initialized to point to itself, signifying that the list
     is empty:
 
       #define LIST_HEAD_INIT(name) { &amp;(name), &amp;(name) } 
       #define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)
 
     In the case of list_head-linked lists, the "list_head.next" pointer is
     the address of a list_head structure that is embedded in the next data
     structure in the list, and not the address of the next data structure 
     itself.  The starting point of the list may be:

       (a) an external, standalone, LIST_HEAD().
       (b) a list_head that is embedded within a data structure of the same
           type as the whole linked list.
       (c) a list_head that is embedded within a data structure that is
           different than the type of structures in the the linked list.
 
     The list typically ends when the embedded "list_head.next" pointer of
     a data structure in the linked list points back to the LIST_HEAD()
     address.  However, some list_head-linked lists have no defined starting
     point, but just link back onto themselves in a circular manner.

  This command can handle both types of linked list; in both cases the list
  of addresses that are dumped are the addresses of the data structures
  themselves.

  The arguments are as follows:

  [-o] offset  The offset within the structure to the "next" pointer
               (default is 0).  If non-zero, the offset may be entered
               in either of two manners:

               1. In "structure.member" format; the "-o" is not necessary.
               2. A number of bytes; the "-o" is only necessary on processors
                  where the offset value could be misconstrued as a kernel
                  virtual address.

       -e end  If the list ends in a manner unlike the typical manners that
               are described above, an explicit ending address value may be
               entered.
    -s struct  For each address in list, format and print as this type of
               structure; use the "struct.member" format in order to display
               a particular member of the structure.  To display multiple
               members of a structure, use a comma-separated list of members.
           -x  Override the default output format with hexadecimal format.
           -d  Override the default output format with decimal format.
           -r  For a list linked with list_head structures, traverse the list
               in the reverse order by using the "prev" pointer instead
               of "next".
 
  The meaning of the "start" argument, which can be expressed symbolically,
  in hexadecimal format, or an expression evaluating to an address, depends
  upon whether the -h or -H option is pre-pended:
 
      start  The address of the first data structure in the list.
   -H start  The address of a list_head structure, typically that of an
             external, standalone LIST_HEAD().  The list typically ends 
             when the embedded "list_head.next" of a data structure in 
             the linked list points back to this "start" address.
   -h start  The address of a data structure which contains an embedded
             list_head.  The list typically ends when the embedded
             "list_head.next" of a data structure in the linked list 
             points back to the embedded list_head contained in the data
             structure whose address is this "start" argument.

WARNING 
  When the "-h start" option is used, it is possible that the list_head-linked
  list will:
 
    1. pass through an external standalone LIST_HEAD(), or
    2. pass through a list_head that is the actual starting list_head, but is
       contained within a data structure that is not the same type as all of
       the other data structures in the list.
 
  When that occurs, the data structure address displayed for that list_head
  will be incorrect, because the "-h start" option presumes that all
  list_head structures in the list are contained within the same type of
  data structure.  Furthermore, if the "-s struct[.member[,member]" option
  is used, it will display bogus data for that particular list_head.

EXAMPLES
  Note that each task_struct is linked to its parent's task_struct via the
  p_pptr member:
 
    crash&gt; struct task_struct.p_pptr
    struct task_struct {
       [136] struct task_struct *p_pptr;
    }
 
  That being the case, given a task_struct pointer of c169a000, show its 
  parental hierarchy back to the "init_task" (the "swapper" task):

    crash&gt; list task_struct.p_pptr c169a000
    c169a000
    c0440000
    c50d0000
    c0562000
    c0d28000
    c7894000
    c6a98000
    c009a000
    c0252000

  Given that the "task_struct.p_pptr" offset is 136 bytes, the same
  result could be accomplished like so:

    crash&gt; list 136 c169a000
    c169a000
    c0440000
    c50d0000
    c0562000
    c0d28000
    c7894000
    c6a98000
    c009a000
    c0252000
 
  The list of currently-registered file system types are headed up by a
  struct file_system_type pointer named "file_systems", and linked by
  the "next" field in each file_system_type structure.  The following
  sequence displays the structure address followed by the name and 
  fs_flags members of each registered file system type:
 
    crash&gt; p file_systems
    file_systems = $1 = (struct file_system_type *) 0xc03adc90
    crash&gt; list file_system_type.next -s file_system_type.name,fs_flags c03adc90
    c03adc90
      name = 0xc02c05c8 "rootfs",
      fs_flags = 0x30,
    c03abf94
      name = 0xc02c0319 "bdev",
      fs_flags = 0x10,
    c03acb40
      name = 0xc02c07c4 "proc",
      fs_flags = 0x8,
    c03e9834
      name = 0xc02cfc83 "sockfs",
      fs_flags = 0x10,
    c03ab8e4
      name = 0xc02bf512 "tmpfs",
      fs_flags = 0x20,
    c03ab8c8
      name = 0xc02c3d6b "shm",
      fs_flags = 0x20,
    c03ac394
      name = 0xc02c03cf "pipefs",
      fs_flags = 0x10,
    c03ada74
      name = 0xc02c0e6b "ext2",
      fs_flags = 0x1,
    c03adc74
      name = 0xc02c0e70 "ramfs",
      fs_flags = 0x20,
    c03ade74
      name = 0xc02c0e76 "hugetlbfs",
      fs_flags = 0x20,
    c03adf8c
      name = 0xc02c0f84 "iso9660",
      fs_flags = 0x1,
    c03aec14
      name = 0xc02c0ffd "devpts",
      fs_flags = 0x8,
    c03e93f4
      name = 0xc02cf1b9 "pcihpfs",
      fs_flags = 0x28,
    e0831a14
      name = 0xe082f89f "ext3",
      fs_flags = 0x1,
    e0846af4
      name = 0xe0841ac6 "usbdevfs",
      fs_flags = 0x8,
    e0846b10
      name = 0xe0841acf "usbfs",
      fs_flags = 0x8,
    e0992370
      name = 0xe099176c "autofs",
      fs_flags = 0x0,
    e2dcc030
      name = 0xe2dc8849 "nfs",
      fs_flags = 0x48000,
 
  In some kernels, the system run queue is a linked list headed up by the
  "runqueue_head", which is defined like so:
 
    static LIST_HEAD(runqueue_head);
 
  The run queue linking is done with the "run_list" member of the task_struct:
 
    crash&gt; struct task_struct.run_list
    struct task_struct {
        [60] struct list_head run_list;
    }
 
  Therefore, to view the list of task_struct addresses in the run queue,
  either of the following commands will work:

    crash&gt; list task_struct.run_list -H runqueue_head
    f79ac000
    f7254000
    f7004000
    crash&gt; list 60 -H runqueue_head
    f79ac000
    f7254000
    f7004000
 
  In some kernel versions, the vfsmount structures of the mounted
  filesystems are linked by the LIST_HEAD "vfsmntlist", which uses the
  mnt_list list_head of each vfsmount structure in the list.  To dump each
  vfsmount structure in the list, append the -s option:

    crash&gt; list -H vfsmntlist vfsmount.mnt_list -s vfsmount
    c3fc9e60
    struct vfsmount {
      mnt_hash = {
        next = 0xc3fc9e60, 
        prev = 0xc3fc9e60
      }, 
      mnt_parent = 0xc3fc9e60, 
      mnt_mountpoint = 0xc3fc5dc0, 
      mnt_root = 0xc3fc5dc0, 
      mnt_instances = {
        next = 0xc3f60a74, 
        prev = 0xc3f60a74
      }, 
      mnt_sb = 0xc3f60a00, 
      mnt_mounts = {
        next = 0xf7445e08, 
        prev = 0xf7445f88
      }, 
      mnt_child = {
        next = 0xc3fc9e88, 
        prev = 0xc3fc9e88
      }, 
      mnt_count = {
        counter = 209
      }, 
      mnt_flags = 0, 
      mnt_devname = 0xc8465b20 "/dev/root", 
      mnt_list = {
        next = 0xf7445f9c, 
        prev = 0xc02eb828
      }, 
      mnt_owner = 0
    }
    f7445f60
    struct vfsmount {
    ...
 
  The task_struct of every task in the system is linked into a circular list
  by its embedded "tasks" list_head.  Show the task_struct addresses and the
  pids of all tasks in the system using "-h" option, starting with the 
  task_struct at ffff88012b98e040:

    crash&gt; list task_struct.tasks -s task_struct.pid -h ffff88012b98e040
    ffff88012b98e040
      pid = 14187
    ffff8801277be0c0
      pid = 14248
    ffffffff81a2d020
      pid = 0
    ffff88012d7dd4c0
      pid = 1
    ffff88012d7dca80
      pid = 2
    ffff88012d7dc040
      pid = 3
    ffff88012d7e9500
      pid = 4
    ...
    ffff88012961a100
      pid = 14101
    ffff880129017580
      pid = 14134
    ffff8801269ed540
      pid = 14135
    ffff880128256080
      pid = 14138
    ffff88012b8f4100
      pid = 14183
</pre>

<h3 id="toc_0.0.16">log</h3>
<pre>
NAME
  log - dump system message buffer

SYNOPSIS
  log [-tdm]

DESCRIPTION
  This command dumps the kernel log_buf contents in chronological order.  The
  command supports the older log_buf formats, which may or may not contain a
  timestamp inserted prior to each message, as well as the newer variable-length
  record format, where the timestamp is contained in each log entry's header.
  
    -t  Display the message text without the timestamp; only applicable to the
        variable-length record format.
    -d  Display the dictionary of key/value pair properties that are optionally
        appended to a message by the kernel's dev_printk() function; only
        applicable to the variable-length record format.
    -m  Display the message log level in brackets preceding each message.  For
        the variable-length record format, the level will be displayed in 
        hexadecimal, and depending upon the kernel version, also contains the
        facility or flags bits.
 

EXAMPLES
  Dump the kernel message buffer:

    crash&gt; log
    Linux version 2.2.5-15smp (root@mclinux1) (gcc version egcs-2.91.66 19990
    314/Linux (egcs-1.1.2 release)) #1 SMP Thu Aug 26 11:04:37 EDT 1999
    Intel MultiProcessor Specification v1.4
        Virtual Wire compatibility mode.
    OEM ID: DELL     Product ID: WS 410       APIC at: 0xFEE00000
    Processor #0 Pentium(tm) Pro APIC version 17
    Processor #1 Pentium(tm) Pro APIC version 17
    I/O APIC #2 Version 17 at 0xFEC00000.
    Processors: 2
    mapped APIC to ffffe000 (fee00000)
    mapped IOAPIC to ffffd000 (fec00000)
    Detected 447696347 Hz processor.
    Console: colour VGA+ 80x25
    Calibrating delay loop... 445.64 BogoMIPS
    ...
      8K byte-wide RAM 5:3 Rx:Tx split, autoselect/Autonegotiate interface.
      MII transceiver found at address 24, status 782d.
      Enabling bus-master transmits and whole-frame receives.
    Installing knfsd (copyright (C) 1996 okir@monad.swb.de).
    nfsd_init: initialized fhcache, entries=256
    ...
 
  Do the same thing, but also show the log level preceding each message:

    crash&gt; log -m
    &lt;4&gt;Linux version 2.2.5-15smp (root@mclinux1) (gcc version egcs-2.91.66 19990
    314/Linux (egcs-1.1.2 release)) #1 SMP Thu Aug 26 11:04:37 EDT 1999
    &lt;4&gt;Intel MultiProcessor Specification v1.4
    &lt;4&gt;    Virtual Wire compatibility mode.
    &lt;4&gt;OEM ID: DELL     Product ID: WS 410       APIC at: 0xFEE00000
    &lt;4&gt;Processor #0 Pentium(tm) Pro APIC version 17
    &lt;4&gt;Processor #1 Pentium(tm) Pro APIC version 17
    &lt;4&gt;I/O APIC #2 Version 17 at 0xFEC00000.
    &lt;4&gt;Processors: 2
    &lt;4&gt;mapped APIC to ffffe000 (fee00000)
    &lt;4&gt;mapped IOAPIC to ffffd000 (fec00000)
    &lt;4&gt;Detected 447696347 Hz processor.
    &lt;4&gt;Console: colour VGA+ 80x25
    &lt;4&gt;Calibrating delay loop... 445.64 BogoMIPS
    ...
    &lt;6&gt;  8K byte-wide RAM 5:3 Rx:Tx split, autoselect/Autonegotiate interface.
    &lt;6&gt;  MII transceiver found at address 24, status 782d.
    &lt;6&gt;  Enabling bus-master transmits and whole-frame receives.
    &lt;6&gt;Installing knfsd (copyright (C) 1996 okir@monad.swb.de).
    &lt;7&gt;nfsd_init: initialized fhcache, entries=256
    ... 
 
  On a system with the variable-length record format, and whose log_buf has been
  filled and wrapped around, display the log with timestamp data:

    crash&gt; log
    [    0.467730] pci 0000:ff:02.0: [8086:2c10] type 00 class 0x060000
    [    0.467749] pci 0000:ff:02.1: [8086:2c11] type 00 class 0x060000
    [    0.467769] pci 0000:ff:02.4: [8086:2c14] type 00 class 0x060000
    [    0.467788] pci 0000:ff:02.5: [8086:2c15] type 00 class 0x060000
    [    0.467809] pci 0000:ff:03.0: [8086:2c18] type 00 class 0x060000
    [    0.467828] pci 0000:ff:03.1: [8086:2c19] type 00 class 0x060000
    ...
 
  Display the same message text as above, without the timestamp data:

    crash&gt; log -t
    pci 0000:ff:02.0: [8086:2c10] type 00 class 0x060000
    pci 0000:ff:02.1: [8086:2c11] type 00 class 0x060000
    pci 0000:ff:02.4: [8086:2c14] type 00 class 0x060000
    pci 0000:ff:02.5: [8086:2c15] type 00 class 0x060000
    pci 0000:ff:03.0: [8086:2c18] type 00 class 0x060000
    pci 0000:ff:03.1: [8086:2c19] type 00 class 0x060000
    ...
 
  Display the same message text as above, with appended dictionary data:

    crash&gt; log -td
    pci 0000:ff:02.0: [8086:2c10] type 00 class 0x060000
    SUBSYSTEM=pci
    DEVICE=+pci:0000:ff:02.0
    pci 0000:ff:02.1: [8086:2c11] type 00 class 0x060000
    SUBSYSTEM=pci
    DEVICE=+pci:0000:ff:02.1
    pci 0000:ff:02.4: [8086:2c14] type 00 class 0x060000
    SUBSYSTEM=pci
    DEVICE=+pci:0000:ff:02.4
    pci 0000:ff:02.5: [8086:2c15] type 00 class 0x060000
    SUBSYSTEM=pci
    DEVICE=+pci:0000:ff:02.5
    pci 0000:ff:03.0: [8086:2c18] type 00 class 0x060000
    SUBSYSTEM=pci
    DEVICE=+pci:0000:ff:03.0
    pci 0000:ff:03.1: [8086:2c19] type 00 class 0x060000
    SUBSYSTEM=pci
    DEVICE=+pci:0000:ff:03.1
    ...
</pre>

<h3 id="toc_0.0.17">mach</h3>
<pre>
NAME
  mach - machine specific data

SYNOPSIS
  mach [-m | -c -[xd]]

DESCRIPTION
  This command displays data specific to a machine type.

    -m  Display the physical memory map (x86, x86_64 and ia64 only).
    -c  Display each cpu's cpuinfo structure (x86, x86_64 and ia64 only).
        Display each cpu's x8664_pda structure (x86_64 only),
        Display the hwrpb_struct, and each cpu's percpu_struct (alpha only).
    -x  override default output format with hexadecimal format.
    -d  override default output format with decimal format.

EXAMPLES
    crash&gt; mach
           MACHINE TYPE: i686
            MEMORY SIZE: 512 MB
                   CPUS: 2
             HYPERVISOR: KVM
        PROCESSOR SPEED: 1993 Mhz
                     HZ: 100
              PAGE SIZE: 4096
    KERNEL VIRTUAL BASE: c0000000
    KERNEL VMALLOC BASE: e0800000
      KERNEL STACK SIZE: 8192
 
  Display the system physical memory map:

    crash&gt; mach -m
          PHYSICAL ADDRESS RANGE         TYPE
    0000000000000000 - 00000000000a0000  E820_RAM
    00000000000f0000 - 0000000000100000  E820_RESERVED
    0000000000100000 - 000000001ff75000  E820_RAM
    000000001ff75000 - 000000001ff77000  E820_NVS
    000000001ff77000 - 000000001ff98000  E820_ACPI
    000000001ff98000 - 0000000020000000  E820_RESERVED
    00000000fec00000 - 00000000fec90000  E820_RESERVED
    00000000fee00000 - 00000000fee10000  E820_RESERVED
    00000000ffb00000 - 0000000100000000  E820_RESERVED
</pre>

<h3 id="toc_0.0.18">mod</h3>
<pre>
NAME
  mod - module information and loading of symbols and debugging data

SYNOPSIS
  mod -s module [objfile] | -d module | -S [directory] [-D|-t|-r|-R|-o|-g]

DESCRIPTION
  With no arguments, this command displays basic information of the currently
  installed modules, consisting of the module address, name, size, the
  object file name (if known), and whether the module was compiled with
  CONFIG_KALLSYMS.
 
  The arguments are concerned with with the loading or deleting of symbolic
  and debugging data from a module's object file.  A modules's object file
  always contains symbolic data (symbol names and addresses), but contains
  debugging data only if the module was compiled with the -g CFLAG.  In
  addition, the module may have compiled with CONFIG_KALLSYMS, which means
  that the module's symbolic data will have been loaded into the kernel's
  address space when it was installed.  If the module was not compiled with
  CONFIG_KALLSYMS, then only the module's exported symbols will be loaded
  into the kernel's address space.  Therefore, for the purpose of this
  command, it should noted that a kernel module may have been compiled in
  one of following manners:

  1. If the module was built without CONFIG_KALLSYMS and without the -g CFLAG,
     then the loading of the module's additional non-exported symbols can
     be accomplished with this command.
  2. If the module was built with CONFIG_KALLSYMS, but without the -g CFLAG,
     then there is no benefit in loading the symbols from the module object
     file, because all of the module's symbols will have been loaded into the
     kernel's address space when it was installed.
  3. If the module was built with CONFIG_KALLSYMS and with the the -g CFLAG,
     then the loading of the module's debugging data can be accomplished
     with this command.
  4. If the module was built without CONFIG_KALLSYMS but with the -g CFLAG,
     then the loading of the both module's symbolic and debugging data can
     be accomplished with this command.
 
  -s module [objfile]  Loads symbolic and debugging data from the object file
                       for the module specified.  If no objfile argument is
                       appended, a search will be made for an object file
                       consisting of the module name with a .o or .ko suffix,
                       starting at the /lib/modules/&lt;release&gt; directory on
                       the host system, or if not found there, starting at the
                       directory containing the kernel namelist file.  If an
                       objfile argument is appended, then that file will be
                       used.
            -d module  Deletes the symbolic and debugging data of the module
                       specified.
       -S [directory]  Load symbolic and debugging data from the object file
                       for all loaded modules.  For each module, a search
                       will be made for an object file consisting of the
                       module name with a .o or .ko suffix, starting at the
                       /lib/modules/&lt;release&gt; directory of the host system,
                       or if not found there, starting at the directory
                       containing the kernel namelist file.  If a directory
                       argument is appended, then the search will be restricted
                       to that directory.
                   -D  Deletes the symbolic and debugging data of all modules.
                   -t  Display the contents of the module's "taints" bitmask
                       if it is non-zero.  When possible, the "taints" bits
                       are translated to symbolic letters of the taint type;
                       otherwise the hexadecimal value is shown.  In older
                       kernels, the contents of the "license_gplok" field is
                       displayed in hexadecimal; the field may be either a 
                       bitmask or a boolean, depending upon the kernel version.
                       The relevant kernel sources should be consulted for the
                       meaning of the letter(s) or hexadecimal bit value(s). 
                       For modules that have a "gpgsig_ok" field that is zero
                       (unsigned), the notation "(U)" is shown.
                   -r  Passes the -readnow flag to the embedded gdb module,
                       which will override the two-stage strategy that it uses
                       for reading symbol tables from module object files.
                   -R  Reinitialize module data. All currently-loaded symbolic
                       and debugging data will be deleted, and the installed
                       module list will be updated (live system only).
                   -g  When used with -s or -S, add a module object's section
                       start and end addresses to its symbol list.
                   -o  Load module symbols with old mechanism.
 
  If the crash session was invoked with the "--mod &lt;directory&gt;" option, or
  a CRASH_MODULE_PATH environment variable exists, then /lib/modules/&lt;release&gt;
  will be overridden as the default directory tree that is searched for module
  object files.
 
  After symbolic and debugging data have been loaded, backtraces and text
  disassembly will be displayed appropriately.  Depending upon the processor
  architecture, data may also printed symbolically with the "p" command;
  at a minimum, the "rd" command may be used with module data symbols.
 
  If crash can recognize that the set of modules has changed while running a
  session on a live kernel, the module data will be reinitialized the next
  time this command is run; the -r option forces the reinitialization.

EXAMPLES
  Display the currently-installed modules:

    crash&gt; mod
     MODULE   NAME         SIZE  OBJECT FILE
    c8019000  soundcore    2788  (not loaded)
    c801b000  soundlow      336  (not loaded)
    c801d000  sound       59864  (not loaded)
    c802d000  ad1848      15728  (not loaded)
    c8032000  uart401      6000  (not loaded)
    c8035000  cs4232       2472  (not loaded)
    c8043000  opl3        11048  (not loaded)
    c8047000  3c59x       18152  (not loaded)
    c804d000  sunrpc      53796  (not loaded)
    c805c000  lockd       31528  (not loaded)
    c8065000  nfsd       151896  (not loaded)
    c8092000  nfs         29752  (not loaded)
 
  Display the currently-installed modules on a system where all modules were
  compiled with CONFIG_KALLSYMS:
 
    crash&gt; mod
     MODULE   NAME              SIZE  OBJECT FILE
    e080d000  jbd              57016  (not loaded)  [CONFIG_KALLSYMS]
    e081e000  ext3             92360  (not loaded)  [CONFIG_KALLSYMS]
    e0838000  usbcore          83168  (not loaded)  [CONFIG_KALLSYMS]
    e0850000  usb-uhci         27532  (not loaded)  [CONFIG_KALLSYMS]
    e085a000  ehci-hcd         20904  (not loaded)  [CONFIG_KALLSYMS]
    e0865000  input             6208  (not loaded)  [CONFIG_KALLSYMS]
    e086a000  hid              22404  (not loaded)  [CONFIG_KALLSYMS]
    e0873000  mousedev          5688  (not loaded)  [CONFIG_KALLSYMS]
    e0878000  keybdev           2976  (not loaded)  [CONFIG_KALLSYMS]
    e08fd000  cdrom            34144  (not loaded)  [CONFIG_KALLSYMS]
    e0909000  ide-cd           35776  (not loaded)  [CONFIG_KALLSYMS]
    e0915000  scsi_mod        117928  (not loaded)  [CONFIG_KALLSYMS]
    e0935000  ide-scsi         12752  (not loaded)  [CONFIG_KALLSYMS]
    e093c000  microcode         5248  (not loaded)  [CONFIG_KALLSYMS]
    e0943000  sr_mod           18136  (not loaded)  [CONFIG_KALLSYMS]
    e0956000  floppy           59056  (not loaded)  [CONFIG_KALLSYMS]
    e0966000  sg               38060  (not loaded)  [CONFIG_KALLSYMS]
    e0971000  ip_tables        16544  (not loaded)  [CONFIG_KALLSYMS]
    e097d000  iptable_filter    2412  (not loaded)  [CONFIG_KALLSYMS]
    e097f000  e1000            76096  (not loaded)  [CONFIG_KALLSYMS]
    e09ba000  autofs           13780  (not loaded)  [CONFIG_KALLSYMS]
    e09c1000  parport          39072  (not loaded)  [CONFIG_KALLSYMS]
    e09ce000  lp                9220  (not loaded)  [CONFIG_KALLSYMS]
    e09d4000  parport_pc       19204  (not loaded)  [CONFIG_KALLSYMS]
    e09e2000  agpgart          59128  (not loaded)  [CONFIG_KALLSYMS]
    e0a1a000  radeon          117156  (not loaded)  [CONFIG_KALLSYMS]
    e2dc7000  sunrpc           91996  (not loaded)  [CONFIG_KALLSYMS]
    e2de1000  lockd            60624  (not loaded)  [CONFIG_KALLSYMS]
    e2df3000  nfs              96880  (not loaded)  [CONFIG_KALLSYMS]
 
  Load the symbolic and debugging data of all modules:

    crash&gt; mod -S
     MODULE   NAME         SIZE  OBJECT FILE
    c8019000  soundcore    2788  /lib/modules/2.2.5-15/misc/soundcore.o
    c801b000  soundlow      336  /lib/modules/2.2.5-15/misc/soundlow.o
    c801d000  sound       59864  /lib/modules/2.2.5-15/misc/sound.o
    c802d000  ad1848      15728  /lib/modules/2.2.5-15/misc/ad1848.o
    c8032000  uart401      6000  /lib/modules/2.2.5-15/misc/uart401.o
    c8035000  cs4232       2472  /lib/modules/2.2.5-15/misc/cs4232.o
    c8043000  opl3        11048  /lib/modules/2.2.5-15/misc/opl3.o
    c8047000  3c59x       18152  /lib/modules/2.2.5-15/net/3c59x.o
    c804d000  sunrpc      53796  /lib/modules/2.2.5-15/misc/sunrpc.o
    c805c000  lockd       31528  /lib/modules/2.2.5-15/fs/lockd.o
    c8065000  nfsd       151896  /lib/modules/2.2.5-15/fs/nfsd.o
    c8092000  nfs         29752  /lib/modules/2.2.5-15/fs/nfs.o
    
  Load the symbolic and debugging data of the soundcore module from its
  known location:
 
    crash&gt; mod -s soundcore
     MODULE   NAME         SIZE  OBJECT FILE
    c8019000  soundcore    2788  /lib/modules/2.2.5-15/misc/soundcore.o
    
  Delete the current symbolic and debugging data of the soundcore module, 
  and then re-load it from a specified object file:
 
    crash&gt; mod -d soundcore
    crash&gt; mod -s soundcore /tmp/soundcore.o
     MODULE   NAME         SIZE  OBJECT FILE
    c8019000  soundcore    2788  /tmp/soundcore.o
 
  After installing a new kernel module on a live system, reinitialize the
  installed module list:

    crash&gt; !insmod mdacon
    crash&gt; mod
    mod: NOTE: modules have changed on this system -- reinitializing
     MODULE   NAME         SIZE  OBJECT FILE
    c8019000  soundcore    2788  (not loaded)
    c801b000  soundlow      336  (not loaded)
    c801d000  sound       59864  (not loaded)
    c802d000  ad1848      15728  (not loaded)
    c8032000  uart401      6000  (not loaded)
    c8035000  cs4232       2472  (not loaded)
    c8043000  opl3        11048  (not loaded)
    c8047000  3c59x       18152  (not loaded)
    c804d000  sunrpc      53796  (not loaded)
    c805c000  lockd       31528  (not loaded)
    c8065000  nfs         29752  (not loaded)
    c806e000  autofs       9316  (not loaded)
    c8072000  nfsd       151896  (not loaded)
    c80a1000  mdacon       3556  (not loaded)
 
  Display modules that are "tainted", where in this case
  where they are proprietary and unsigned:
 
    crash&gt; mod -t
    NAME      TAINT
    vxspec    P(U)
    vxportal  P(U)
    fdd       P(U)
    vxfs      P(U)
    vxdmp     P(U)
    vxio      P(U)
    vxglm     P(U)
    vxgms     P(U)
    vxodm     P(U)
</pre>

<h3 id="toc_0.0.19">mount</h3>
<pre>
NAME
  mount - mounted filesystem data

SYNOPSIS
  mount [-f][-i] [-n pid|task] [mount|vfsmount|superblock|dev|dir|dentry|inode]

DESCRIPTION
  This command displays basic information about the currently-mounted
  filesystems.  The per-filesystem dirty inode list or list of open
  files for the filesystem may also be displayed.

     -f  dump dentries and inodes for open files in each filesystem.
     -i  dump all dirty inodes associated with each filesystem; only
         supported on kernels prior to Linux 2.6.32.

  For kernels supporting namespaces, the -n option may be used to
  display the mounted filesystems with respect to the namespace of a
  specified task:

     -n pid   a process PID.
     -n task  a hexadecimal task_struct pointer.

  Specific filesystems may be selected using the following forms:

    vfsmount  hexadecimal address of a filesystem vfsmount structure.
       mount  hexadecimal address of a filesystem mount structure (Linux 3.3
              and later).
  superblock  hexadecimal address of a filesystem super_block structure.
         dev  device name of a filesystem.
         dir  directory where a filesystem is mounted.
      dentry  hexadecimal address of an open dentry of a filesystem.
       inode  hexadecimal address of an open inode of a filesystem.
 
  The first column of the command output displays the filesystem's vfsmount
  structure address for kernels prior to Linux 3.3.  For Linux 3.3 and later
  kernels, the first column displays the filesystem's mount structure address,
  which contains an embedded vfsmount structure.

EXAMPLES
  Display mounted filesystem data:

    crash&gt; mount
    VFSMOUNT SUPERBLK TYPE   DEVNAME   DIRNAME
    c0089ea0 c0088a00 ext2   /dev/root /    
    c0089cf0 c0088c00 proc   /proc     /proc
    c0089e10 c0088800 ext2   /dev/sda5 /boot
    c0089d80 c0088600 ext2   /dev/sda6 /usr
    c0089f30 c0088400 devpts none      /dev/pts
    c3f4b010 c0088200 ext2   /dev/sda1 /home
 
  On Linux 3.3 and later kernels, the filesystem's mount structure address
  is shown:

    crash&gt; mount
         MOUNT           SUPERBLK     TYPE   DEVNAME   DIRNAME
    ffff880212fb8200 ffff880212fc0800 rootfs rootfs    /   
    ffff88020ffbea00 ffff880212fc2000 proc   proc      proc
    ffff880211db7f00 ffff88020e01a800 sysfs  sysfs     /sys
    ffff88020ffe1300 ffff880212a40000 devtmpfs devtmpfs /dev
    ffff88020ff15000 ffff880212bbc800 devpts devpts    /dev/pts
    ffff88020e542800 ffff88020e62b800 tmpfs  tmpfs     /dev/shm
    ...
 
  Display the open files associated with each mounted filesystem:

    crash&gt; mount -f
    VFSMOUNT SUPERBLK TYPE   DEVNAME   DIRNAME
    c7fb2b80 c7fb3200 ext2   /dev/root /
    OPEN FILES:
     DENTRY    INODE    TYPE  PATH
    c6d02200  c6d0f7a0  REG   usr/X11R6/lib/libX11.so.6.1
    c6d02100  c6d0f9e0  REG   usr/X11R6/lib/libXext.so.6.3
    c6d02000  c6d0fc20  REG   usr/X11R6/lib/libICE.so.6.3
    c6d02680  c6d0f320  REG   usr/X11R6/bin/xfs
    c7106580  c70c5440  CHR   dev/psaux
    ...
 
  Display the dirty inodes associated with each mounted filesystem:

    crash&gt; mount -i
    VFSMOUNT SUPERBLK TYPE   DEVNAME   DIRNAME
    c0089ea0 c0088a00 ext2   /dev/root /
    DIRTY INODES
    c7ad4008
    c2233438
    c72c4008
    c7d6b548
    c3af1a98
    c7d6b768
    c3c4e228
    ...
 
  Display the mounted filesystem containing inode c5000aa8:

    crash&gt; mount c5000aa8
    VFSMOUNT SUPERBLK TYPE   DEVNAME   DIRNAME
    c0089f30 c0088600 ext2   /dev/sda6 /usr 
 
  Display the mounted filesystem containing inode ffff8801f4245e40:

    crash&gt; mount ffff8801f4245e40
         MOUNT           SUPERBLK     TYPE   DEVNAME  DIRNAME
    ffff88020ffbea00 ffff880212fc2000 proc   proc     /proc
</pre>

<h3 id="toc_0.0.20">net</h3>
<pre>
NAME
  net - network command

SYNOPSIS
  net [-a] [[-s | -S [-xd]] [-R ref] [pid | taskp]] [-n addr]

DESCRIPTION
  Display various network related data:

      -a  display the ARP cache.
      -s  display open network socket/sock addresses, their family and type,
          and for INET and INET6 families, their source and destination
          addresses and ports.
      -S  displays open network socket/sock addresses followed by a dump
          of both structures.
      -x  override default output format with hexadecimal format.
      -d  override default output format with decimal format.
  -n addr translates an IPv4 address expressed as a decimal or hexadecimal
          value into a standard numbers-and-dots notation.
  -R ref  socket or sock address, or file descriptor.
     pid  a process PID.
   taskp  a hexadecimal task_struct pointer.

  If no arguments are entered, the list of network devices, names and IP
  addresses are displayed.  The -R option, typically invoked from "foreach net",
  and in conjunction with the -s or -S options, searches for references to a
  socket address, sock address, or a file descriptor; if found, only the
  referenced fd/socket/sock data will be displayed.

EXAMPLES
  Display the network device list:

    crash&gt; net
     DEVICE   NAME   IP ADDRESS(ES)
    c0249f20  lo     127.0.0.1
    c7fe6d80  eth0   10.1.8.20
 
  Dump the ARP cache:

    crash&gt; net -a
    NEIGHBOUR      IP ADDRESS     HW TYPE   HW ADDRESS         DEVICE  STATE
    f38d1b00       10.16.64.14    ETHER     00:16:3e:4b:a5:4a  eth1    STALE
    f38d1080       0.0.0.0        UNKNOWN   00 00 00 00 00 00  lo      NOARP
    f38d1bc0       10.16.71.254   ETHER     00:00:0c:07:ac:00  eth1    REACHABLE
    f38d1200       10.16.64.21    ETHER     00:16:3e:51:d8:09  eth1    REACHABLE
   
  Display the sockets for PID 2517, using both -s and -S output formats:

    crash&gt; net -s 2517
    PID: 2517   TASK: c1598000  CPU: 1   COMMAND: "rlogin"
    FD   SOCKET     SOCK    FAMILY:TYPE         SOURCE-PORT     DESTINATION-PORT
     3  c57375dc  c1ff1850  INET:STREAM      10.1.8.20-1023      10.1.16.62-513
    
    crash&gt; net -S 2517
    PID: 2517   TASK: c1598000  CPU: 1   COMMAND: "rlogin"
    FD   SOCKET     SOCK
     3  c57375dc  c1ff1850
    
    struct socket {
      state = SS_CONNECTED,
      flags = 131072,
      ops = 0xc023f820,
      inode = 0xc5737540,
      fasync_list = 0x0,
      file = 0xc58892b0,
      sk = 0xc1ff1850,
      wait = 0xc14d9ed4,
      type = 1,
      passcred = 0 '\000',
      tli = 0 '\000'
    }
    struct sock {
      sklist_next = 0xc1ff12f0,
      sklist_prev = 0xc216bc00,
      bind_next = 0x0,
      bind_pprev = 0xc0918448,
      daddr = 1041236234,
      rcv_saddr = 336068874,
      dport = 258,
      num = 1023,
      bound_dev_if = 0,
      next = 0x0,
      pprev = 0xc0286dd4,
      state = 1 '\001',
      zapped = 0 '\000',
      sport = 65283,
      family = 2,
      reuse = 0 '\000',
      ...
   Translate the rcv_saddr from above into dotted-decimal notation:

    crash&gt; net -n 1041236234
    10.1.16.62
 
  From "foreach", find all tasks with references to socket c08ea3cc:

    crash&gt; foreach net -s -R c08ea3cc
    PID: 2184   TASK: c7026000  CPU: 1   COMMAND: "klines.kss"
    FD   SOCKET     SOCK    FAMILY:TYPE         SOURCE-PORT     DESTINATION-PORT
     5  c08ea3cc  c50d3c80  INET:STREAM        0.0.0.0-1026         0.0.0.0-0
    
    PID: 2200   TASK: c670a000  CPU: 1   COMMAND: "kpanel"
    FD   SOCKET     SOCK    FAMILY:TYPE         SOURCE-PORT     DESTINATION-PORT
     5  c08ea3cc  c50d3c80  INET:STREAM        0.0.0.0-1026         0.0.0.0-0
    
    PID: 2201   TASK: c648a000  CPU: 1   COMMAND: "kbgndwm"
    FD   SOCKET     SOCK    FAMILY:TYPE         SOURCE-PORT     DESTINATION-PORT
     5  c08ea3cc  c50d3c80  INET:STREAM        0.0.0.0-1026         0.0.0.0-0
    
    PID: 19294  TASK: c250a000  CPU: 0   COMMAND: "prefdm"
    FD   SOCKET     SOCK    FAMILY:TYPE         SOURCE-PORT     DESTINATION-PORT
     5  c08ea3cc  c50d3c80  INET:STREAM        0.0.0.0-1026         0.0.0.0-0
    
    PID: 2194   TASK: c62dc000  CPU: 1   COMMAND: "kaudioserver"
    FD   SOCKET     SOCK    FAMILY:TYPE         SOURCE-PORT     DESTINATION-PORT
     5  c08ea3cc  c50d3c80  INET:STREAM        0.0.0.0-1026         0.0.0.0-0
    
    PID: 2195   TASK: c6684000  CPU: 1   COMMAND: "maudio"
    FD   SOCKET     SOCK    FAMILY:TYPE         SOURCE-PORT     DESTINATION-PORT
     5  c08ea3cc  c50d3c80  INET:STREAM        0.0.0.0-1026         0.0.0.0-0
    
    PID: 2196   TASK: c6b58000  CPU: 1   COMMAND: "kwmsound"
    FD   SOCKET     SOCK    FAMILY:TYPE         SOURCE-PORT     DESTINATION-PORT
     5  c08ea3cc  c50d3c80  INET:STREAM        0.0.0.0-1026         0.0.0.0-0
    
    PID: 2197   TASK: c6696000  CPU: 0   COMMAND: "kfm"
    FD   SOCKET     SOCK    FAMILY:TYPE         SOURCE-PORT     DESTINATION-PORT
     5  c08ea3cc  c50d3c80  INET:STREAM        0.0.0.0-1026         0.0.0.0-0
    
    PID: 2199   TASK: c65ec000  CPU: 0   COMMAND: "krootwm"
    FD   SOCKET     SOCK    FAMILY:TYPE         SOURCE-PORT     DESTINATION-PORT
     5  c08ea3cc  c50d3c80  INET:STREAM        0.0.0.0-1026         0.0.0.0-0
    
    PID: 694    TASK: c1942000  CPU: 0   COMMAND: "prefdm"
    FD   SOCKET     SOCK    FAMILY:TYPE         SOURCE-PORT     DESTINATION-PORT
     5  c08ea3cc  c50d3c80  INET:STREAM        0.0.0.0-1026         0.0.0.0-0
    
    PID: 698    TASK: c6a2c000  CPU: 1   COMMAND: "X"
    FD   SOCKET     SOCK    FAMILY:TYPE         SOURCE-PORT     DESTINATION-PORT
     5  c08ea3cc  c50d3c80  INET:STREAM        0.0.0.0-1026         0.0.0.0-0
    
    PID: 2159   TASK: c4a5a000  CPU: 1   COMMAND: "kwm"
    FD   SOCKET     SOCK    FAMILY:TYPE         SOURCE-PORT     DESTINATION-PORT
     5  c08ea3cc  c50d3c80  INET:STREAM        0.0.0.0-1026         0.0.0.0-0
</pre>

<h3 id="toc_0.0.21">p</h3>
<pre>
NAME
  p - print the value of an expression

SYNOPSIS
  p [-x|-d][-u] [expression | symbol[:cpuspec]]

DESCRIPTION
  This command passes its arguments on to gdb "print" command for evaluation.

    expression  an expression to be evaluated.
        symbol  a kernel symbol.
      :cpuspec  CPU specification for a per-cpu symbol:
                  :             CPU of the currently selected task.
                  :a[ll]        all CPUs.
                  :#[-#][,...]  CPU list(s), e.g. "1,3,5", "1-3",
                                or "1,3,5-7,10".
            -x  override default output format with hexadecimal format.
            -d  override default output format with decimal format.
            -u  the expression evaluates to a user address reference.

  The default output format is decimal, but that can be changed at any time
  with the two built-in aliases "hex" and "dec".  Alternatively, there
  are two other built-in aliases, "px" and "pd", which force the command
  output to be displayed in hexadecimal or decimal, without changing the
  default mode. 

EXAMPLES
  Print the contents of jiffies:

    crash&gt; p jiffies
    jiffies = $6 = 166532620
    crash&gt; px jiffies
    jiffies = $7 = 0x9ed174b
    crash&gt; pd jiffies
    jiffies = $8 = 166533160
 
  Print the contents of the vm_area_struct "init_mm":

    crash&gt; p init_mm
    init_mm = $5 = {
      mmap = 0xc022d540, 
      mmap_avl = 0x0, 
      mmap_cache = 0x0, 
      pgd = 0xc0101000, 
      count = {
        counter = 0x6
      }, 
      map_count = 0x1, 
      mmap_sem = {
        count = {
          counter = 0x1
        }, 
        waking = 0x0, 
        wait = 0x0
      }, 
      context = 0x0, 
      start_code = 0xc0000000, 
      end_code = 0xc022b4c8, 
      start_data = 0x0, 
      end_data = 0xc0250388, 
      start_brk = 0x0, 
      brk = 0xc02928d8, 
      start_stack = 0x0, 
      arg_start = 0x0, 
      arg_end = 0x0, 
      env_start = 0x0, 
      env_end = 0x0, 
      rss = 0x0, 
      total_vm = 0x0, 
      locked_vm = 0x0, 
      def_flags = 0x0, 
      cpu_vm_mask = 0x0, 
      swap_cnt = 0x0, 
      swap_address = 0x0, 
      segments = 0x0
    }

  If a per-cpu symbol is entered as a argument, its data type
  and all of its per-cpu addresses are displayed:
 
    crash&gt; p irq_stat
    PER-CPU DATA TYPE:
      irq_cpustat_t irq_stat;
    PER-CPU ADDRESSES:
      [0]: ffff88021e211540
      [1]: ffff88021e251540
      [2]: ffff88021e291540
      [3]: ffff88021e2d1540
 
  To display the contents a per-cpu symbol for CPU 1, append
  a cpu-specifier:
 
    crash&gt; p irq_stat:1
    per_cpu(irq_stat, 1) = $29 = {
      __softirq_pending = 0, 
      __nmi_count = 209034, 
      apic_timer_irqs = 597509876, 
      irq_spurious_count = 0, 
      icr_read_retry_count = 2, 
      x86_platform_ipis = 0, 
      apic_perf_irqs = 209034, 
      apic_irq_work_irqs = 0, 
      irq_resched_count = 264922233, 
      irq_call_count = 7036692, 
      irq_tlb_count = 4750442, 
      irq_thermal_count = 0, 
      irq_threshold_count = 0
    }
</pre>

<h3 id="toc_0.0.22">ps</h3>
<pre>
NAME
  ps - display process status information

SYNOPSIS
  ps [-k|-u|-G][-s][-p|-c|-t|-l|-a|-g|-r] [pid | taskp | command] ...

DESCRIPTION
  This command displays process status for selected, or all, processes
  in the system.  If no arguments are entered, the process data is
  is displayed for all processes.  Specific processes may be selected
  by using the following identifier formats:

       pid  a process PID.
     taskp  a hexadecimal task_struct pointer.
   command  a command name.  If a command name is made up of letters that
            are all numerical values, precede the name string with a "\".
            If the command string is enclosed within "'" characters, then
            the encompassed string must be a POSIX extended regular expression
            that will be used to match task names.
 
  The process list may be further restricted by the following options:

        -k  restrict the output to only kernel threads.
        -u  restrict the output to only user tasks.
        -G  display only the thread group leader in a thread group.
 
  The process identifier types may be mixed.  For each task, the following
  items are displayed:
 
    1. the process PID.
    2. the parent process PID.
    3. the CPU number that the task ran on last.
    4. the task_struct address or the kernel stack pointer of the process.
       (see -s option below)
    5. the task state (RU, IN, UN, ZO, ST, TR, DE, SW).
    6. the percentage of physical memory being used by this task.
    7. the virtual address size of this task in kilobytes.
    8. the resident set size of this task in kilobytes.
    9. the command name.
 
  The default output shows the task_struct address of each process under a
  column titled "TASK".  This can be changed to show the kernel stack 
  pointer under a column titled "KSTACKP".
 
       -s  replace the TASK column with the KSTACKP column.
 
  On SMP machines, the active task on each CPU will be highlighted by an
  angle bracket ("&gt;") preceding its information.
 
  Alternatively, information regarding parent-child relationships,
  per-task time usage data, argument/environment data, thread groups,
  or resource limits may be displayed:
 
       -p  display the parental hierarchy of selected, or all, tasks.
       -c  display the children of selected, or all, tasks.
       -t  display the task run time, start time, and cumulative user
           and system times.
       -l  display the task last_run or timestamp value, whichever applies,
           of selected, or all, tasks; the list is sorted with the most
           recently-run task (largest last_run/timestamp) shown first,
           followed by the task's current state.
       -a  display the command line arguments and environment strings of
           selected, or all, user-mode tasks.
       -g  display tasks by thread group, of selected, or all, tasks.
       -r  display resource limits (rlimits) of selected, or all, tasks.

EXAMPLES
  Show the process status of all current tasks:

    crash&gt; ps
       PID    PPID  CPU   TASK    ST  %MEM   VSZ   RSS  COMM
    &gt;     0      0   3  c024c000  RU   0.0     0     0  [swapper]
    &gt;     0      0   0  c0dce000  RU   0.0     0     0  [swapper]
          0      0   1  c0fa8000  RU   0.0     0     0  [swapper]
    &gt;     0      0   2  c009a000  RU   0.0     0     0  [swapper]
          1      0   1  c0098000  IN   0.0  1096   476  init
          2      1   1  c0090000  IN   0.0     0     0  [kflushd]
          3      1   1  c000e000  IN   0.0     0     0  [kpiod]
          4      1   3  c000c000  IN   0.0     0     0  [kswapd]
          5      1   1  c0008000  IN   0.0     0     0  [mdrecoveryd]
        253      1   2  fbc4c000  IN   0.0  1088   376  portmap
        268      1   2  fbc82000  IN   0.1  1232   504  ypbind
        274    268   2  fa984000  IN   0.1  1260   556  ypbind
        321      1   1  fabf6000  IN   0.1  1264   608  syslogd
        332      1   1  fa9be000  RU   0.1  1364   736  klogd
        346      1   2  fae88000  IN   0.0  1112   472  atd
        360      1   2  faeb2000  IN   0.1  1284   592  crond
        378      1   2  fafd6000  IN   0.1  1236   560  inetd
        392      1   0  fb710000  IN   0.1  2264  1468  named
        406      1   3  fb768000  IN   0.1  1284   560  lpd
        423      1   1  fb8ac000  IN   0.1  1128   528  rpc.statd
        434      1   2  fb75a000  IN   0.0  1072   376  rpc.rquotad
        445      1   2  fb4a4000  IN   0.0  1132   456  rpc.mountd
        460      1   1  fa938000  IN   0.0     0     0  [nfsd]
        461      1   1  faa86000  IN   0.0     0     0  [nfsd]
        462      1   0  fac48000  IN   0.0     0     0  [nfsd]
        463      1   0  fb4ca000  IN   0.0     0     0  [nfsd]
        464      1   0  fb4c8000  IN   0.0     0     0  [nfsd]
        465      1   2  fba6e000  IN   0.0     0     0  [nfsd]
        466      1   1  fba6c000  IN   0.0     0     0  [nfsd]
        467      1   2  fac04000  IN   0.0     0     0  [nfsd]
        468    461   2  fa93a000  IN   0.0     0     0  [lockd]
        469    468   2  fa93e000  IN   0.0     0     0  [rpciod]
        486      1   0  fab54000  IN   0.1  1596   880  amd
        523      1   2  fa84e000  IN   0.1  1884  1128  sendmail
        538      1   0  fa82c000  IN   0.0  1112   416  gpm
        552      1   3  fa70a000  IN   0.1  2384  1220  httpd
        556    552   3  fa776000  IN   0.1  2572  1352  httpd
        557    552   2  faba4000  IN   0.1  2572  1352  httpd
        558    552   1  fa802000  IN   0.1  2572  1352  httpd
        559    552   3  fa6ee000  IN   0.1  2572  1352  httpd
        560    552   3  fa700000  IN   0.1  2572  1352  httpd
        561    552   0  fa6f0000  IN   0.1  2572  1352  httpd
        562    552   3  fa6ea000  IN   0.1  2572  1352  httpd
        563    552   0  fa67c000  IN   0.1  2572  1352  httpd
        564    552   3  fa674000  IN   0.1  2572  1352  httpd
        565    552   3  fa66a000  IN   0.1  2572  1352  httpd
        582      1   2  fa402000  IN   0.2  2968  1916  xfs
        633      1   2  fa1ec000  IN   0.2  5512  2248  innd
        636      1   3  fa088000  IN   0.1  2536   804  actived
        676      1   0  fa840000  IN   0.0  1060   384  mingetty
        677      1   1  fa590000  IN   0.0  1060   384  mingetty
        678      1   2  fa3b8000  IN   0.0  1060   384  mingetty
        679      1   0  fa5b8000  IN   0.0  1060   384  mingetty
        680      1   1  fa3a4000  IN   0.0  1060   384  mingetty
        681      1   2  fa30a000  IN   0.0  1060   384  mingetty
        683      1   3  fa5d8000  IN   0.0  1052   280  update
        686    378   1  fa3aa000  IN   0.1  2320  1136  in.rlogind
        687    686   2  f9e52000  IN   0.1  2136  1000  login
        688    687   0  f9dec000  IN   0.1  1732   976  bash
    &gt;   700    688   1  f9d62000  RU   0.0  1048   256  gen12
 
  Display the parental hierarchy of the "crash" process on a live system:

    crash&gt; ps -p 4249
    PID: 0      TASK: c0252000  CPU: 0   COMMAND: "swapper"
     PID: 1      TASK: c009a000  CPU: 1   COMMAND: "init"
      PID: 632    TASK: c73b6000  CPU: 1   COMMAND: "prefdm"
       PID: 637    TASK: c5a4a000  CPU: 1   COMMAND: "prefdm"
        PID: 649    TASK: c179a000  CPU: 0   COMMAND: "kwm"
         PID: 683    TASK: c1164000  CPU: 0   COMMAND: "kfm"
          PID: 1186   TASK: c165a000  CPU: 0   COMMAND: "xterm"
           PID: 1188   TASK: c705e000  CPU: 1   COMMAND: "bash"
            PID: 4249   TASK: c6b9a000  CPU: 0   COMMAND: "crash"
 
  Display all children of the "kwm" window manager:

    crash&gt; ps -c kwm
      PID: 649    TASK: c179a000  CPU: 0   COMMAND: "kwm"
      PID: 682    TASK: c2d58000  CPU: 1   COMMAND: "kwmsound"
      PID: 683    TASK: c1164000  CPU: 1   COMMAND: "kfm"
      PID: 685    TASK: c053c000  CPU: 0   COMMAND: "krootwm"
      PID: 686    TASK: c13fa000  CPU: 0   COMMAND: "kpanel"
      PID: 687    TASK: c13f0000  CPU: 1   COMMAND: "kbgndwm"
 
  Display all threads in a firefox session:

    crash&gt; ps firefox
       PID    PPID  CPU       TASK        ST  %MEM     VSZ    RSS  COMM
      21273  21256   6  ffff81003ec15080  IN  46.3 1138276 484364  firefox
      21276  21256   6  ffff81003f49e7e0  IN  46.3 1138276 484364  firefox
      21280  21256   0  ffff81003ec1d7e0  IN  46.3 1138276 484364  firefox
      21286  21256   6  ffff81000b0d1820  IN  46.3 1138276 484364  firefox
      21287  21256   2  ffff81000b0d10c0  IN  46.3 1138276 484364  firefox
      26975  21256   5  ffff81003b5c1820  IN  46.3 1138276 484364  firefox
      26976  21256   5  ffff810023232820  IN  46.3 1138276 484364  firefox
      26977  21256   4  ffff810021a11820  IN  46.3 1138276 484364  firefox
      26978  21256   5  ffff810003159040  IN  46.3 1138276 484364  firefox
      26979  21256   5  ffff81003a058820  IN  46.3 1138276 484364  firefox
 
  Display only the thread group leader in the firefox session:

    crash&gt; ps -G firefox
       PID    PPID  CPU       TASK        ST  %MEM     VSZ    RSS  COMM
      21273  21256   0  ffff81003ec15080  IN  46.3 1138276 484364  firefox
 
  Show the time usage data for pid 10318:

    crash&gt; ps -t 10318
    PID: 10318  TASK: f7b85550  CPU: 5   COMMAND: "bash"
        RUN TIME: 1 days, 01:35:32
      START TIME: 5209
           UTIME: 95
           STIME: 57
 
  Show the process status of PID 1, task f9dec000, and all nfsd tasks:

    crash&gt; ps 1 f9dec000 nfsd
       PID    PPID  CPU   TASK    ST  %MEM   VSZ   RSS  COMM
          1      0   1  c0098000  IN   0.0  1096   476  init
        688    687   0  f9dec000  IN   0.1  1732   976  bash
        460      1   1  fa938000  IN   0.0     0     0  [nfsd]
        461      1   1  faa86000  IN   0.0     0     0  [nfsd]
        462      1   0  fac48000  IN   0.0     0     0  [nfsd]
        463      1   0  fb4ca000  IN   0.0     0     0  [nfsd]
        464      1   0  fb4c8000  IN   0.0     0     0  [nfsd]
        465      1   2  fba6e000  IN   0.0     0     0  [nfsd]
        466      1   1  fba6c000  IN   0.0     0     0  [nfsd]
        467      1   2  fac04000  IN   0.0     0     0  [nfsd]
 
  Show all kernel threads:

    crash&gt; ps -k
       PID    PPID  CPU   TASK    ST  %MEM   VSZ   RSS  COMM
          0      0   1  c0fac000  RU   0.0     0     0  [swapper]
          0      0   0  c0252000  RU   0.0     0     0  [swapper]
          2      1   1  c0fa0000  IN   0.0     0     0  [kflushd]
          3      1   1  c03de000  IN   0.0     0     0  [kpiod]
          4      1   1  c03dc000  IN   0.0     0     0  [kswapd]
          5      1   0  c0092000  IN   0.0     0     0  [mdrecoveryd]
        336      1   0  c4a9a000  IN   0.0     0     0  [rpciod]
        337      1   0  c4830000  IN   0.0     0     0  [lockd]
        487      1   1  c4ba6000  IN   0.0     0     0  [nfsd]
        488      1   0  c18c6000  IN   0.0     0     0  [nfsd]
        489      1   0  c0cac000  IN   0.0     0     0  [nfsd]
        490      1   0  c056a000  IN   0.0     0     0  [nfsd]
        491      1   0  c0860000  IN   0.0     0     0  [nfsd]
        492      1   1  c0254000  IN   0.0     0     0  [nfsd]
        493      1   0  c0a86000  IN   0.0     0     0  [nfsd]
        494      1   0  c0968000  IN   0.0     0     0  [nfsd]
 
  Show all tasks sorted by their task_struct's last_run or timestamp value,
  whichever applies:

    crash&gt; ps -l
    [280195] [RU]  PID: 2      TASK: c1468000  CPU: 0   COMMAND: "keventd"
    [280195] [IN]  PID: 1986   TASK: c5af4000  CPU: 0   COMMAND: "sshd"
    [280195] [IN]  PID: 2039   TASK: c58e6000  CPU: 0   COMMAND: "sshd"
    [280195] [RU]  PID: 2044   TASK: c5554000  CPU: 0   COMMAND: "bash"
    [280195] [RU]  PID: 2289   TASK: c70c0000  CPU: 0   COMMAND: "s"
    [280190] [IN]  PID: 1621   TASK: c54f8000  CPU: 0   COMMAND: "cupsd"
    [280184] [IN]  PID: 5      TASK: c154c000  CPU: 0   COMMAND: "kswapd"
    [280184] [IN]  PID: 6      TASK: c7ff6000  CPU: 0   COMMAND: "kscand"
    [280170] [IN]  PID: 0      TASK: c038e000  CPU: 0   COMMAND: "swapper"
    [280166] [IN]  PID: 2106   TASK: c0c0c000  CPU: 0   COMMAND: "sshd"
    [280166] [IN]  PID: 2162   TASK: c03a4000  CPU: 0   COMMAND: "vmstat"
    [280160] [IN]  PID: 1      TASK: c154a000  CPU: 0   COMMAND: "init"
    [280131] [IN]  PID: 3      TASK: c11ce000  CPU: 0   COMMAND: "kapmd"
    [280117] [IN]  PID: 1568   TASK: c5a8c000  CPU: 0   COMMAND: "smartd"
    [280103] [IN]  PID: 1694   TASK: c4c66000  CPU: 0   COMMAND: "ntpd"
    [280060] [IN]  PID: 8      TASK: c7ff2000  CPU: 0   COMMAND: "kupdated"
    [279767] [IN]  PID: 1720   TASK: c4608000  CPU: 0   COMMAND: "sendmail"
    [279060] [IN]  PID: 13     TASK: c69f4000  CPU: 0   COMMAND: "kjournald"
    [278657] [IN]  PID: 1523   TASK: c5ad4000  CPU: 0   COMMAND: "ypbind"
    [277712] [IN]  PID: 2163   TASK: c06e0000  CPU: 0   COMMAND: "sshd"
    [277711] [IN]  PID: 2244   TASK: c4cdc000  CPU: 0   COMMAND: "ssh"
    [277261] [IN]  PID: 1391   TASK: c5d8e000  CPU: 0   COMMAND: "syslogd"
    [276837] [IN]  PID: 1990   TASK: c58d8000  CPU: 0   COMMAND: "bash"
    [276802] [IN]  PID: 1853   TASK: c3828000  CPU: 0   COMMAND: "atd"
    [276496] [IN]  PID: 1749   TASK: c4480000  CPU: 0   COMMAND: "cannaserver"
    [274931] [IN]  PID: 1760   TASK: c43ac000  CPU: 0   COMMAND: "crond"
    [246773] [IN]  PID: 1844   TASK: c38d8000  CPU: 0   COMMAND: "xfs"
    [125620] [IN]  PID: 2170   TASK: c48dc000  CPU: 0   COMMAND: "bash"
    [119059] [IN]  PID: 1033   TASK: c64be000  CPU: 0   COMMAND: "kjournald"
    [110916] [IN]  PID: 1663   TASK: c528a000  CPU: 0   COMMAND: "sshd"
    [ 86122] [IN]  PID: 2112   TASK: c0da6000  CPU: 0   COMMAND: "bash"
    [ 13637] [IN]  PID: 1891   TASK: c67ae000  CPU: 0   COMMAND: "sshd"
    [ 13636] [IN]  PID: 1894   TASK: c38ec000  CPU: 0   COMMAND: "bash"
    [  7662] [IN]  PID: 1885   TASK: c6478000  CPU: 0   COMMAND: "mingetty"
    [  7662] [IN]  PID: 1886   TASK: c62da000  CPU: 0   COMMAND: "mingetty"
    [  7662] [IN]  PID: 1887   TASK: c5f8c000  CPU: 0   COMMAND: "mingetty"
    [  7662] [IN]  PID: 1888   TASK: c5f88000  CPU: 0   COMMAND: "mingetty"
    [  7662] [IN]  PID: 1889   TASK: c5f86000  CPU: 0   COMMAND: "mingetty"
    [  7662] [IN]  PID: 1890   TASK: c6424000  CPU: 0   COMMAND: "mingetty"
    [  7661] [IN]  PID: 4      TASK: c154e000  CPU: 0   COMMAND: "ksoftirqd/0"
    [  7595] [IN]  PID: 1872   TASK: c2e7e000  CPU: 0   COMMAND: "inventory.pl"
    [  6617] [IN]  PID: 1771   TASK: c435a000  CPU: 0   COMMAND: "jserver"
    [  6307] [IN]  PID: 1739   TASK: c48f8000  CPU: 0   COMMAND: "gpm"
    [  6285] [IN]  PID: 1729   TASK: c4552000  CPU: 0   COMMAND: "sendmail"
    [  6009] [IN]  PID: 1395   TASK: c6344000  CPU: 0   COMMAND: "klogd"
    [  5820] [IN]  PID: 1677   TASK: c4d74000  CPU: 0   COMMAND: "xinetd"
    [  5719] [IN]  PID: 1422   TASK: c5d04000  CPU: 0   COMMAND: "portmap"
    [  4633] [IN]  PID: 1509   TASK: c5ed4000  CPU: 0   COMMAND: "apmd"
    [  4529] [IN]  PID: 1520   TASK: c5d98000  CPU: 0   COMMAND: "ypbind"
    [  4515] [IN]  PID: 1522   TASK: c5d32000  CPU: 0   COMMAND: "ypbind"
    [  4373] [IN]  PID: 1441   TASK: c5d48000  CPU: 0   COMMAND: "rpc.statd"
    [  4210] [IN]  PID: 1352   TASK: c5b30000  CPU: 0   COMMAND: "dhclient"
    [  1184] [IN]  PID: 71     TASK: c65b6000  CPU: 0   COMMAND: "khubd"
    [   434] [IN]  PID: 9      TASK: c11de000  CPU: 0   COMMAND: "mdrecoveryd"
    [    48] [IN]  PID: 7      TASK: c7ff4000  CPU: 0   COMMAND: "bdflush"
 
  Show the kernel stack pointer of each user task:

    crash&gt; ps -us
       PID    PPID  CPU  KSTACKP  ST  %MEM   VSZ   RSS  COMM
          1      0   0  c009bedc  IN   0.0  1096    52  init
        239      1   0  c15e7ed8  IN   0.2  1332   224  pump
        280      1   1  c7cbdedc  IN   0.2  1092   208  portmap
        295      1   0  c7481edc  IN   0.0  1232     0  ypbind
        301    295   0  c7c7bf28  IN   0.1  1260   124  ypbind
        376      1   1  c5053f28  IN   0.0  1316    40  automount
        381      1   0  c34ddf28  IN   0.2  1316   224  automount
        391      1   1  c2777f28  IN   0.2  1316   224  automount
    ...
 
  Display the argument and environment data for the automount task:

    crash&gt; ps -a automount
    PID: 3948   TASK: f722ee30  CPU: 0   COMMAND: "automount"
    ARG: /usr/sbin/automount --timeout=60 /net program /etc/auto.net
    ENV: SELINUX_INIT=YES
         CONSOLE=/dev/console
         TERM=linux
         INIT_VERSION=sysvinit-2.85
         PATH=/sbin:/usr/sbin:/bin:/usr/bin
         LC_MESSAGES=en_US
         RUNLEVEL=3
         runlevel=3
         PWD=/
         LANG=ja_JP.UTF-8
         PREVLEVEL=N
         previous=N
         HOME=/
         SHLVL=2
         _=/usr/sbin/automount
 
  Display the tasks in the thread group containing task c20ab0b0:

    crash&gt; ps -g c20ab0b0
    PID: 6425   TASK: f72f50b0  CPU: 0   COMMAND: "firefox-bin"
      PID: 6516   TASK: f71bf1b0  CPU: 0   COMMAND: "firefox-bin"
      PID: 6518   TASK: d394b930  CPU: 0   COMMAND: "firefox-bin"
      PID: 6520   TASK: c20aa030  CPU: 0   COMMAND: "firefox-bin"
      PID: 6523   TASK: c20ab0b0  CPU: 0   COMMAND: "firefox-bin"
      PID: 6614   TASK: f1f181b0  CPU: 0   COMMAND: "firefox-bin"
 
  Display the tasks in the thread group for each instance of the
  program named "multi-thread":

    crash&gt; ps -g multi-thread
    PID: 2522   TASK: 1003f0dc7f0       CPU: 1   COMMAND: "multi-thread"
      PID: 2523   TASK: 10037b13030       CPU: 1   COMMAND: "multi-thread"
      PID: 2524   TASK: 1003e064030       CPU: 1   COMMAND: "multi-thread"
      PID: 2525   TASK: 1003e13a7f0       CPU: 1   COMMAND: "multi-thread"
    
    PID: 2526   TASK: 1002f82b7f0       CPU: 1   COMMAND: "multi-thread"
      PID: 2527   TASK: 1003e1737f0       CPU: 1   COMMAND: "multi-thread"
      PID: 2528   TASK: 10035b4b7f0       CPU: 1   COMMAND: "multi-thread"
      PID: 2529   TASK: 1003f0c37f0       CPU: 1   COMMAND: "multi-thread"
      PID: 2530   TASK: 10035597030       CPU: 1   COMMAND: "multi-thread"
      PID: 2531   TASK: 100184be7f0       CPU: 1   COMMAND: "multi-thread"
 
  Display the resource limits of "bash" task 13896:

    crash&gt; ps -r 13896
    PID: 13896  TASK: cf402000  CPU: 0   COMMAND: "bash"
       RLIMIT     CURRENT       MAXIMUM
          CPU   (unlimited)   (unlimited)
        FSIZE   (unlimited)   (unlimited)
         DATA   (unlimited)   (unlimited)
        STACK    10485760     (unlimited)
         CORE   (unlimited)   (unlimited)
          RSS   (unlimited)   (unlimited)
        NPROC      4091          4091
       NOFILE      1024          1024
      MEMLOCK      4096          4096
           AS   (unlimited)   (unlimited)
        LOCKS   (unlimited)   (unlimited)
 
  Search for task names matching a POSIX regular expression:

     crash&gt; ps 'migration*'
        PID    PPID  CPU       TASK        ST  %MEM    VSZ    RSS  COMM
           8      2   0  ffff8802128a2e20  IN   0.0      0      0  [migration/0]
          10      2   1  ffff880212969710  IN   0.0      0      0  [migration/1]
          15      2   2  ffff880212989710  IN   0.0      0      0  [migration/2]
          20      2   3  ffff8802129a9710  IN   0.0      0      0  [migration/3]
</pre>

<h3 id="toc_0.0.23">pte</h3>
<pre>
NAME
  pte - translate a page table entry

SYNOPSIS
  pte contents ...

DESCRIPTION
  This command translates the hexadecimal contents of a PTE into its physical
  page address and page bit settings.  If the PTE references a swap location,
  the swap device and offset are displayed.

EXAMPLES

    crash&gt; pte d8e067
     PTE    PHYSICAL  FLAGS
    d8e067   d8e000   (PRESENT|RW|USER|ACCESSED|DIRTY)
 
    crash&gt; pte 13f600
     PTE      SWAP     OFFSET
    13f600  /dev/hda2   5104
</pre>

<h3 id="toc_0.0.24">ptob</h3>
<pre>
NAME
  ptob - page to bytes

SYNOPSIS
  ptob page_number ...

DESCRIPTION
  This command translates a page frame number to its byte value.

EXAMPLES
    crash&gt; ptob 512a
    512a: 512a000
</pre>

<h3 id="toc_0.0.25">ptov</h3>
<pre>
NAME
  ptov - physical to virtual

SYNOPSIS
  ptov address ...

DESCRIPTION
  This command translates a hexadecimal physical address into a kernel 
  virtual address.

EXAMPLES
  Translate physical address 56e000 into a kernel virtual address:

    crash&gt; ptov 56e000
    VIRTUAL   PHYSICAL
    c056e000  56e000
</pre>

<h3 id="toc_0.0.26">q</h3>
<pre>
NAME
  q - exit this session

SYNOPSIS
  q  

DESCRIPTION
  Bail out of the current crash session.

NOTE
  This command is equivalent to the "exit" command.
</pre>

<h3 id="toc_0.0.27">rd</h3>
<pre>
NAME
  rd - read memory

SYNOPSIS
  rd [-adDsSupxmfN][-8|-16|-32|-64][-o offs][-e addr][-r file][address|symbol]
     [count]

DESCRIPTION
  This command displays the contents of memory, with the output formatted
  in several different manners.  The starting address may be entered either
  symbolically or by address.  The default output size is the size of a long
  data type, and the default output format is hexadecimal.  When hexadecimal
  output is used, the output will be accompanied by an ASCII translation.

       -p  address argument is a physical address.
       -u  address argument is a user virtual address; only required on
           processors with common user and kernel virtual address spaces.
       -m  address argument is a xen host machine address.
       -f  address argument is a dumpfile offset.
       -d  display output in signed decimal format (default is hexadecimal).
       -D  display output in unsigned decimal format (default is hexadecimal).
       -s  displays output symbolically when appropriate.
       -S  displays output symbolically when appropriate; if the address
           references a slab cache object, the name of the slab cache will
           be displayed in brackets.
       -x  do not display ASCII translation at end of each line.
       -8  display output in 8-bit values.
      -16  display output in 16-bit values.
      -32  display output in 32-bit values (default on 32-bit machines).
      -64  display output in 64-bit values (default on 64-bit machines).
       -a  display output in ASCII characters if the memory contains printable
           ASCII characters; if no count argument is entered, stop at the first
           non-printable character.
       -N  display output in network byte order (only valid for 16- and 32-bit
           values)
  -o offs  offset the starting address by offs.
  -e addr  display memory until reaching specified ending hexadecimal address.
  -r file  dumps raw data to the specified output file; the number of bytes that
           are copied to the file must be specified either by a count argument
           or by the -e option.
  address  starting hexadecimal address:
             1  the default presumes a kernel virtual address.
             2. -p specifies a physical address.
             3. -u specifies a user virtual address, but is only necessary on
                processors with common user and kernel virtual address spaces.
   symbol  symbol of starting address to read.
    count  number of memory locations to display; if entered, it must be the
           last argument on the command line; if not entered, the count defaults
           to 1, or unlimited for -a; when used with the -r option, it is the
           number of bytes to be written to the file.

EXAMPLES
  Display the kernel's version string:

    crash&gt; rd -a linux_banner
    c082a020:  Linux version 2.6.32-119.el6.i686 (mockbuild@hs20-bc2-4.buil
    c082a05c:  d.redhat.com) (gcc version 4.4.4 20100726 (Red Hat 4.4.4-13)
    c082a098:   (GCC) ) #1 SMP Tue Mar 1 18:16:57 EST 2011

  Display the same block of memory, first without symbols, again
  with symbols, and then with symbols and slab cache references:

    crash&gt; rd dff12e80 36
    dff12e80:  dff12e94 00000000 c05a363a dff12ed0   ........:6Z.....
    dff12e90:  00000001 dff12e98 0041fe3f ffffffff   ........?.A.....
    dff12ea0:  00000001 d5147800 00000000 def8abc0   .....x..........
    dff12eb0:  dff12ebc c05a4aa0 00000000 dff12ed0   .....JZ.........
    dff12ec0:  00000001 00000000 00000000 00000000   ................
    dff12ed0:  0808b353 00000000 dff12efc c0698220   S........... .i.
    dff12ee0:  dff12efc df7c6480 00000001 c046f99b   .....d|.......F.
    dff12ef0:  00000000 00000000 0808b352 dff12f68   ........R...h/..
    dff12f00:  c155a128 00000000 00000001 ffffffff   (.U.............
    crash&gt; rd -s dff12e80 36
    dff12e80:  dff12e94 00000000 sock_aio_write+83 dff12ed0 
    dff12e90:  00000001 dff12e98 0041fe3f ffffffff 
    dff12ea0:  00000001 d5147800 00000000 def8abc0 
    dff12eb0:  dff12ebc sys_recvfrom+207 00000000 dff12ed0 
    dff12ec0:  00000001 00000000 00000000 00000000 
    dff12ed0:  0808b353 00000000 dff12efc socket_file_ops 
    dff12ee0:  dff12efc df7c6480 00000001 do_sync_write+182 
    dff12ef0:  00000000 00000000 0808b352 dff12f68 
    dff12f00:  c155a128 00000000 00000001 ffffffff 
    crash&gt; rd -S dff12e80 36
    dff12e80:  [size-4096] 00000000 sock_aio_write+83 [size-4096] 
    dff12e90:  00000001 [size-4096] 0041fe3f ffffffff 
    dff12ea0:  00000001 [sock_inode_cache] 00000000 [filp]   
    dff12eb0:  [size-4096] sys_recvfrom+207 00000000 [size-4096] 
    dff12ec0:  00000001 00000000 00000000 00000000 
    dff12ed0:  0808b353 00000000 [size-4096] socket_file_ops 
    dff12ee0:  [size-4096] [filp]   00000001 do_sync_write+182 
    dff12ef0:  00000000 00000000 0808b352 [size-4096] 
    dff12f00:  [vm_area_struct] 00000000 00000001 ffffffff

  Read jiffies in hexadecimal and decimal format:

    crash&gt; rd jiffies
    c0213ae0:  0008cc3a                              :...

    crash&gt; rd -d jiffies
    c0213ae0:        577376

  Access the same memory in different sizes:

    crash&gt; rd -64 kernel_version
    c0226a6c:  35312d352e322e32                    2.2.5-15

    crash&gt; rd -32 kernel_version 2
    c0226a6c:  2e322e32 35312d35                     2.2.5-15

    crash&gt; rd -16 kernel_version 4
    c0226a6c:  2e32 2e32 2d35 3531                       2.2.5-15

    crash&gt; rd -8 kernel_version 8 
    c0226a6c:  32 2e 32 2e 35 2d 31 35                           2.2.5-15

  Read the range of memory from c009bf2c to c009bf60:

    crash&gt; rd c009bf2c -e c009bf60
    c009bf2c:  c009bf64 c01328c3 c009bf64 c0132838   d....(..d...8(..
    c009bf3c:  0000002a 00000004 c57d77e8 00000104   *........w}.....
    c009bf4c:  0000000b c009a000 7fffffff 00000000   ................
    c009bf5c:  00000000                              ....
</pre>

<h3 id="toc_0.0.28">repeat</h3>
<pre>
NAME
  repeat - repeat a command

SYNOPSIS
  repeat [-seconds] command

DESCRIPTION
  This command repeats a command indefinitely, optionally delaying a given
  number of seconds between each command execution.

    -seconds   The number of seconds to delay between command executions.
               This option must precede the command name to be executed.
 
  Command execution may be stopped with CTRL-C, or if scrolling is in effect,
  by entering "q".  This command is meant for use on a live system; it is
  hard to conceive of a reason to use it when debugging a crash dump.

EXAMPLES
  Display the value of jiffies once per second:

    crash&gt; repeat -1 p jiffies
    jiffies = $1 = 155551079
    jiffies = $2 = 155551180
    jiffies = $3 = 155551281
    jiffies = $4 = 155551382
    jiffies = $5 = 155551483
    jiffies = $6 = 155551584
    jiffies = $7 = 155551685
    jiffies = $8 = 155551786
    jiffies = $9 = 155551887
    jiffies = $10 = 155551988
    jiffies = $11 = 155552089
    jiffies = $12 = 155552190
    jiffies = $13 = 155552291
    jiffies = $14 = 155552392
    jiffies = $15 = 155552493
    jiffies = $16 = 155552594
    jiffies = $17 = 155552695
    jiffies = $18 = 155552796
    ...
</pre>

<h3 id="toc_0.0.29">runq</h3>
<pre>
NAME
  runq - run queue

SYNOPSIS
  runq [-t] [-g]

DESCRIPTION
  With no argument, this command displays the tasks on the run queues
  of each cpu.
 
   -t  Display the timestamp information of each cpu's runqueue, which is the
       rq.clock, rq.most_recent_timestamp or rq.timestamp_last_tick value,
       whichever applies; following each cpu timestamp is the last_run or 
       timestamp value of the active task on that cpu, whichever applies, 
       along with the task identification.
   -g  Display tasks hierarchically by task_group.  The task_group line shows
       the task_group address, the cfs_rq or rt_rq address, the task_group name
       (if any), and whether the task_group is throttled.

EXAMPLES
 Display the tasks on an O(1) scheduler run queue:

    crash&gt; runq
    CPU 0 RUNQUEUE: ffff880001cdb460
      CURRENT: PID: 2739   TASK: ffff8800320fa7e0  COMMAND: "bash"
      ACTIVE PRIO_ARRAY: ffff880001cdb4d8
         [115] PID: 2739   TASK: ffff8800320fa7e0  COMMAND: "bash"
               PID: 1776   TASK: ffff88003217d820  COMMAND: "syslogd"
      EXPIRED PRIO_ARRAY: ffff880001cdbdb8
         [no tasks queued]
    
    CPU 1 RUNQUEUE: ffff880001ce3460
      CURRENT: PID: 1779   TASK: ffff88003207a860  COMMAND: "klogd"
      ACTIVE PRIO_ARRAY: ffff880001ce34d8
         [115] PID: 1779   TASK: ffff88003207a860  COMMAND: "klogd"
      EXPIRED PRIO_ARRAY: ffff880001ce3db8
         [no tasks queued]
 
 Display the tasks on a CFS run queue:

    crash&gt; runq
    CPU 0 RUNQUEUE: ffff8800090436c0
      CURRENT: PID: 588    TASK: ffff88007e4877a0  COMMAND: "udevd"
      RT PRIO_ARRAY: ffff8800090437c8
         [no tasks queued]
      CFS RB_ROOT: ffff880009043740
         [118] PID: 2110   TASK: ffff88007d470860  COMMAND: "check-cdrom.sh"
         [118] PID: 2109   TASK: ffff88007f1247a0  COMMAND: "check-cdrom.sh"
         [118] PID: 2114   TASK: ffff88007f20e080  COMMAND: "udevd"
    
    CPU 1 RUNQUEUE: ffff88000905b6c0
      CURRENT: PID: 2113   TASK: ffff88007e8ac140  COMMAND: "udevd"
      RT PRIO_ARRAY: ffff88000905b7c8
         [no tasks queued]
      CFS RB_ROOT: ffff88000905b740
         [118] PID: 2092   TASK: ffff88007d7a4760  COMMAND: "MAKEDEV"
         [118] PID: 1983   TASK: ffff88007e59f140  COMMAND: "udevd"
         [118] PID: 2064   TASK: ffff88007e40f7a0  COMMAND: "udevd"
         [115] PID: 2111   TASK: ffff88007e4278a0  COMMAND: "kthreadd"
 
 Display run queue timestamp data:

    crash&gt; runq -t 
    CPU 0: 2680990637359
           2680986653330  PID: 28228  TASK: ffff880037ca2ac0  COMMAND: "loop"
    CPU 1: 2680940618478
           2680940618478  PID: 28167  TASK: ffff880078130040  COMMAND: "bash"
    CPU 2: 2680990763425
           2680986785772  PID: 28227  TASK: ffff8800787780c0  COMMAND: "loop"
    CPU 3: 2680990954469
           2680986059540  PID: 28226  TASK: ffff880078778b00  COMMAND: "loop"
 
 Display tasks hierarchically by task_group:

  crash&gt; runq -g 
  CPU 0
    CURRENT: PID: 14734  TASK: ffff88010626f500  COMMAND: "sh"
    ROOT_TASK_GROUP: ffffffff81ed93e0  RT_RQ: ffff880028216808
       [  0] TASK_GROUP: ffff88022c6bbc00 RT_RQ: ffff880139fc9800 (THROTTLED)
            [  0] PID: 14750  TASK: ffff88013a4dd540  COMMAND: "rtloop99"
            [  1] PID: 14748  TASK: ffff88013bbca040  COMMAND: "rtloop98"
            [  1] TASK_GROUP: ffff88012b0fb400 RT_RQ: ffff880089029000 
                  [  1] PID: 14752  TASK: ffff880088abf500  COMMAND: "rtloop98"
            [ 54] PID: 14749  TASK: ffff880037a4e080  COMMAND: "rtloop45"
            [ 98] PID: 14746  TASK: ffff88012678c080  COMMAND: "rtloop1"
    ROOT_TASK_GROUP: ffffffff81ed93e0  CFS_RQ: ffff8800282166e8
       [120] PID: 14740  TASK: ffff88013b1e6080  COMMAND: "sh"
       [120] PID: 14738  TASK: ffff88012678d540  COMMAND: "sh"
       [120] PID: 14734  TASK: ffff88010626f500  COMMAND: "sh" [CURRENT]
       TASK_GROUP: ffff884052bc9800 CFS_RQ: ffff8831e4a1b000 (THROTTLED)
          [120] PID: 14732  TASK: ffff88013bbcb500  COMMAND: "sh"
          [120] PID: 14728  TASK: ffff8800b3496080  COMMAND: "sh"
          [120] PID: 14730  TASK: ffff880037833540  COMMAND: "sh"
       TASK_GROUP: ffff884058f1d000 CFS_RQ: ffff88120a101600 (THROTTLED)
          [120] PID: 14726  TASK: ffff880138d42aa0  COMMAND: "sh"
  ...
 
  crash&gt; runq -g
  CPU 0
    CURRENT: PID: 2948   TASK: ffff88022af2a100  COMMAND: "bash"
    INIT_TASK_GROUP: ffffffff81e1a780  RT_RQ: ffff880028216148
       [no tasks queued]
    INIT_TASK_GROUP: ffffffff81e1a780  CFS_RQ: ffff880028216028
       [120] PID: 2948   TASK: ffff88022af2a100  COMMAND: "bash" [CURRENT]
       TASK_GROUP: ffff88012b880800  CFS_RQ: ffff88012c5d1000  &lt;libvirt&gt;
          TASK_GROUP: ffff88012c078000  CFS_RQ: ffff88012c663e00  &lt;qemu&gt;
             TASK_GROUP: ffff88022c7f4c00  CFS_RQ: ffff88012bb56000  &lt;guest2&gt;
                TASK_GROUP: ffff88022b621400  CFS_RQ: ffff88012b012000  &lt;vcpu0&gt;
                   [120] PID: 3248   TASK: ffff88012a9d4100  COMMAND: "qemu-kvm"
   ...
</pre>

<h3 id="toc_0.0.30">search</h3>
<pre>
NAME
  search - search memory

SYNOPSIS
  search [-s start] [ -[kKV] | -u | -p | -t ] [-e end | -l length] [-m mask]
         [-x count] -[cwh] [value | (expression) | symbol | string] ...

DESCRIPTION
  This command searches for a given value within a range of user virtual, kernel
  virtual, or physical memory space.  If no end nor length value is entered, 
  then the search stops at the end of user virtual, kernel virtual, or physical
  address space, whichever is appropriate.
 
  An optional mask value may be entered to mask off "don't care" bits.

    -s start  Start the search at this hexadecimal user or kernel virtual 
              address, physical address, or kernel symbol.  The start address
              must be appropriate for the memory type specified; if no memory
              type is specified, the default is kernel virtual address space.
          -k  If no start address is specified, start the search at the base
              of kernel virtual address space.  This option is the default.
          -K  Same as -k, except that mapped kernel virtual memory that was
              allocated by vmalloc(), module memory, or virtual mem_map regions
              will not be searched.
          -V  Same as -k, except that unity-mapped kernel virtual memory and
              mapped kernel-text/static-data (x86_64 and ia64) will not be
              searched.
          -u  If no start address is specified, start the search at the base
              of the current context's user virtual address space.  If a start
              address is specified, then this option specifies that the start
              address is a user virtual address.
          -p  If no start address is specified, start the search at the base
              of physical address space.  If a start address is specified,
              then this option specifies that the start address is a physical 
              address.
          -t  Search only the kernel stack pages of every task.  If one or more
              matches are found in a task's kernel stack, precede the output
              with a task-identifying header.
      -e end  Stop the search at this hexadecimal user or kernel virtual
              address, kernel symbol, or physical address.  The end address
              must be appropriate for the memory type specified.
   -l length  Length in bytes of address range to search.
     -m mask  Ignore the bits that are set in the hexadecimal mask value.
          -c  Search for character string values instead of unsigned longs.  If
              the string contains any space(s), it must be encompassed by double
              quotes.
          -w  Search for unsigned hexadecimal ints instead of unsigned longs.
              This is only meaningful on 64-bit systems in order to search both
              the upper and lower 32-bits of each 64-bit long for the value.
          -h  Search for unsigned hexadecimal shorts instead of unsigned longs.
    -x count  Display the memory contents before and after any found value.  The
              before and after memory context will consist of "count" memory
              items of the same size as the "value" argument.  This option is
              not applicable with the -c option.
       value  Search for this hexadecimal long, unless modified by the -c, -w, 
              or -h options.
(expression)  Search for the value of this expression; the expression value must
              not overflow the designated size when -h or -w are used; not
              applicable when used with the -c option.
      symbol  Search for this symbol value; the symbol value must not overflow
              the designated size when -h or -w are used; not applicable when 
              used with the -c option.
      string  Search for character string values; if the string contains any 
              space(s), it must be encompassed by double quotes; only applicable
              with the -c option.
 
  If -k, -K, -V, -u, -p or -t are not used, then the search defaults to kernel
  virtual address space.  The starting address must be long-word aligned. 
  Address ranges that start in user space and end in kernel space are not
  accepted.

EXAMPLES
  Search the current context's address space for all instances of 0xdeadbeef:

    crash&gt; search -u deadbeef
    81aba5c: deadbeef
    81abaa8: deadbeef
    bfffc698: deadbeef
    bffff390: deadbeef

  Search all kernel memory above the kernel text space for all instances
  of 0xabcd occurring in the lower 16-bits of each 32-bit word: 

    crash&gt; search -s _etext -m ffff0000 abcd
    c071481c: abcd
    c0c2b0fc: 804abcd
    c0cf5e74: 7489abcd
    c17c0b44: c012abcd
    c1dac730: 3dbeabcd
    c226d0e8: ffffabcd
    c23ed5dc: abcd
    c3022544: 3dbeabcd
    c3069b58: 3dbeabcd
    c3e86e84: aabcd
    c3e88ed0: aabcd
    c3e8ee5c: aabcd
    c3e9df50: aabcd
    c3e9e930: aabcd
    c440a778: 804abcd
    c486eb44: 3dbeabcd
    c578f0fc: 804abcd
    c6394f90: 8ababcd
    c65219f0: 3abcd
    c661399c: abcd
    c68514ac: 8abcd
    c7e036bc: 3dbeabcd
    c7e12568: 5abcd
    c7e1256c: 5abcd

  Search the 4K page at c532c000 for all instances of 0xffffffff:

    crash&gt; search -s c532c000 -l 4096 ffffffff
    c532c33c: ffffffff
    c532c3fc: ffffffff

  Search the static kernel data area for all instances of c2d400eb:

    crash&gt; search -s _etext -e _edata c2d400eb
    c022b550: c2d400eb
    c022b590: c2d400eb
    c022b670: c2d400eb
    c022b6e0: c2d400eb
    c022b7b0: c2d400eb
    c022b7e0: c2d400eb
    c022b8b0: c2d400eb

  Search physical memory for all instances of 0xbabe occurring in the
  upper 16 bits of each 32-bit word:

    crash&gt; search -p babe0000 -m ffff
    2a1dc4: babe671e
    2b6928: babe3de1
    2f99ac: babe0d54
    31843c: babe70b9
    3ba920: babeb5d7
    413ce4: babe7540
    482747c: babe2600
    48579a4: babe2600
    4864a68: babe2600
    ...

  Search physical memory for all instances of 0xbabe occurring in the
  upper 16 bits of each 32-bit word on a 64-bit system:

    crash&gt; search -p babe0000 -m ffff -w
    102e248: babe1174
    11d2f90: babe813d
    122d3ad70: babe6b27
    124d8cd30: babe3dc8
    124d8eefc: babef981
    124d8f060: babe3dc8
    124d8f17c: babefc81
    ...

  Search kernel memory for all instances of 32-bit value 0xbabe1174
  on a 64-bit system:

    crash&gt; search -k -w babe1174
    ffff88000102e248: babe1174
    ffffffff8102e248: babe1174

  Search kernel memory for two strings:

    crash&gt; search -k -c "can't allocate memory" "Failure to"
    ffff8800013ddec1: can't allocate memory for key lists..&lt;3&gt;%s %s: error con
    ffff8801258be748: Failure to install fence: %d..&lt;3&gt;[drm:%s] *ERROR* Failed
    ffff880125f07ec9: can't allocate memory..&lt;3&gt;ACPI: Invalid data..Too many d
    ffffffff813ddec1: can't allocate memory for key lists..&lt;3&gt;%s %s: error con

  Search the kernel stacks of all tasks for those that contain the inode
  address ffff81002c0a3050:

    crash&gt; search -t ffff81002c0a3050
    PID: 4876   TASK: ffff81003e9f5860  CPU: 7   COMMAND: "automount"
    ffff8100288fbe98: ffff81002c0a3050
    
    PID: 4880   TASK: ffff81003ce967a0  CPU: 0   COMMAND: "automount"
    ffff81002c0fbdd8: ffff81002c0a3050
    ffff81002c0fbe78: ffff81002c0a3050

  When a kernel symbol or an (expression) is used an argument, both the
  resultant value and the input string are displayed:

    crash&gt; search anon_inode_inode (__down_interruptible+191)
    ffff81000222a728: ffffffff80493d60 (anon_inode_inode)
    ffff810005a1e918: ffffffff800649d6 (__down_interruptible+191)
    ffff810005a1e9d0: ffffffff800649d6 (__down_interruptible+191)
    ffff810005a1eb48: ffffffff800649d6 (__down_interruptible+191)
    ffff81000b409c60: ffffffff80493d60 (anon_inode_inode)
    ffff81000c155b98: ffffffff80493d60 (anon_inode_inode)
    ffff8100194fac70: ffffffff80493d60 (anon_inode_inode)
    ffff81001daa1008: ffffffff80493d60 (anon_inode_inode)
    ffff810028b95830: ffffffff800649d6 (__down_interruptible+191)
    ffff81002cea0c70: ffffffff80493d60 (anon_inode_inode)
    ffff810031327268: ffffffff80493d60 (anon_inode_inode)
    ffff810031327270: ffffffff800649d6 (__down_interruptible+191)
    ffff810034b1ccd0: ffffffff800649d6 (__down_interruptible+191)
    ffff8100399565a8: ffffffff80493d60 (anon_inode_inode)
    ffff81003a278cd0: ffffffff800649d6 (__down_interruptible+191)
    ffff81003cc23e08: ffffffff800649d6 (__down_interruptible+191)
</pre>

<h3 id="toc_0.0.31">set</h3>
<pre>
NAME
  set - set a process context or internal crash variable

SYNOPSIS
  set [[-a] [pid | taskp] | [-c cpu] | -p] | [crash_variable [setting]] | -v

DESCRIPTION
  This command either sets a new context, or gets the current context for
  display.  The context can be set by the use of:

      pid  a process PID.
    taskp  a hexadecimal task_struct pointer.
       -a  sets the pid or task as the active task on its cpu (dumpfiles only).
   -c cpu  sets the context to the active task on a cpu (dumpfiles only).
       -p  sets the context to the panic task, or back to the crash task on
           a live system.
       -v  display the current state of internal crash variables.

  If no argument is entered, the current context is displayed.  The context
  consists of the PID, the task pointer, the CPU, and task state.  The task
  state shows the bits found in both the task_struct state and exit_state
  fields.
  
  This command may also be used to set internal crash variables.  If no value
  argument is entered, the current value of the crash variable is shown.  These
  are the crash variables, acceptable arguments, and purpose:

          scroll  on | off     controls output scrolling.
          scroll  less         /usr/bin/less as the output scrolling program.
          scroll  more         /bin/more as the output scrolling program.
          scroll  CRASHPAGER   use CRASHPAGER environment variable as the
                               output scrolling program.
           radix  10 | 16      sets output radix to 10 or 16.
         refresh  on | off     controls internal task list refresh.
       print_max  number       set maximum number of array elements to print.
         console  device-name  sets debug console device.
           debug  number       sets crash debug level.
            core  on | off     if on, drops core when the next error message
                               is displayed.
            hash  on | off     controls internal list verification.
          silent  on | off     turns off initialization messages; turns off
                               crash prompt during input file execution. 
                               (scrolling is turned off if silent is on)
            edit  vi | emacs   set line editing mode (from .crashrc file only).
        namelist  filename     name of kernel (from .crashrc file only).
   zero_excluded  on | off     controls whether excluded pages from a dumpfile
                               should return zero-filled memory.
       null-stop  on | off     if on, gdb's printing of character arrays will
                               stop at the first NULL encountered.
             gdb  on | off     if on, the crash session will be run in a mode
                               where all commands will be passed directly to
                               gdb, and the command prompt will change to 
                               "gdb&gt;"; when running in this mode, native crash
                               commands may be executed by preceding them with
                               the "crash" directive.
           scope  text-addr    sets the text scope for viewing the definition
                               of data structures; the "text-addr" argument
                               must be a kernel or module text address, which
                               may be expressed symbolically or as a hexadecimal
                               value.
 
  Internal variables may be set in four manners:

    1. entering the set command in $HOME/.crashrc.
    2. entering the set command in .crashrc in the current directory.
    3. executing an input file containing the set command.
    4. during runtime with this command.

  During initialization, $HOME/.crashrc is read first, followed by the
  .crashrc file in the current directory.  Set commands in the .crashrc file
  in the current directory override those in $HOME/.crashrc.  Set commands 
  entered with this command or by runtime input file override those
  defined in either .crashrc file.  Multiple set command arguments or argument
  pairs may be entered in one command line.

EXAMPLES
  Set the current context to task c2fe8000:

    crash&gt; set c2fe8000
         PID: 15917
     COMMAND: "bash"
        TASK: c2fe8000  
         CPU: 0
       STATE: TASK_INTERRUPTIBLE

  Set the context back to the panicking task:

    crash&gt; set -p
         PID: 698
     COMMAND: "gen12"
        TASK: f9d78000
         CPU: 2
       STATE: TASK_RUNNING (PANIC)

  Turn off output scrolling:

    crash&gt; set scroll off
    scroll: off (/usr/bin/less)
 
  Show the current state of crash internal variables:

    crash&gt; set -v
            scroll: on (/usr/bin/less)
             radix: 10 (decimal)
           refresh: on
         print_max: 256
           console: /dev/pts/2
             debug: 0
              core: off
              hash: on
            silent: off
              edit: vi
          namelist: vmlinux
     zero_excluded: off
         null-stop: on
               gdb: off
             scope: (not set)
 
  Show the current context:

    crash&gt; set
         PID: 1525
     COMMAND: "bash"
        TASK: c1ede000
         CPU: 0
       STATE: TASK_INTERRUPTIBLE
</pre>

<h3 id="toc_0.0.32">sig</h3>
<pre>
NAME
  sig - task signal handling

SYNOPSIS
  sig [[-l] | [-s sigset]] | [-g] [pid | taskp] ...

DESCRIPTION
  This command displays signal-handling data of one or more tasks.  Multiple
  task or PID numbers may be entered; if no arguments are entered, the signal
  handling data of the current context will be displayed.  The default display
  shows:
 
    1.  A formatted dump of the "sig" signal_struct structure referenced by
        the task_struct.  For each defined signal, it shows the sigaction
        structure address, the signal handler, the signal sigset_t mask 
        (also expressed as a 64-bit hexadecimal value), and the flags.
    2.  Whether the task has an unblocked signal pending.
    3.  The contents of the "blocked" and "signal" sigset_t structures
        from the task_struct/signal_struct, both of which are represented 
        as a 64-bit hexadecimal value.
    4.  For each queued signal, private and/or shared, if any, its signal
        number and associated siginfo structure address.
 
  The -l option lists the signal numbers and their name(s).  The -s option
  translates a 64-bit hexadecimal value representing the contents of a
  sigset_t structure into the signal names whose bits are set.
 
        pid  a process PID.
      taskp  a hexadecimal task_struct pointer.
         -g  displays signal information for all threads in a task's 
             thread group.
         -l  displays the defined signal numbers and names.
  -s sigset  translates a 64-bit hexadecimal value representing a sigset_t
             into a list of signal names associated with the bits set.

EXAMPLES
  Dump the signal-handling data of PID 8970:

    crash&gt; sig 8970
    PID: 8970   TASK: f67d8560  CPU: 1   COMMAND: "procsig"
    SIGNAL_STRUCT: f6018680  COUNT: 1
     SIG SIGACTION  HANDLER       MASK       FLAGS   
     [1]  f7877684  SIG_DFL 0000000000000000 0 
     [2]  f7877698  SIG_DFL 0000000000000000 0 
    ...
     [8]  f7877710  SIG_DFL 0000000000000000 0 
     [9]  f7877724  SIG_DFL 0000000000000000 0 
    [10]  f7877738  804867a 0000000000000000 80000000 (SA_RESETHAND)
    [11]  f787774c  SIG_DFL 0000000000000000 0 
    [12]  f7877760  804867f 0000000000000000 10000004 (SA_SIGINFO|SA_RESTART)
    [13]  f7877774  SIG_DFL 0000000000000000 0 
    ...
    [31]  f78778dc  SIG_DFL 0000000000000000 0 
    [32]  f78778f0  SIG_DFL 0000000000000000 0 
    [33]  f7877904  SIG_DFL 0000000000000000 0 
    [34]  f7877918  804867f 0000000000000000 10000004 (SA_SIGINFO|SA_RESTART)
    [35]  f787792c  SIG_DFL 0000000000000000 0 
    [36]  f7877940  SIG_DFL 0000000000000000 0 
    ...
    [58]  f7877af8  SIG_DFL 0000000000000000 0 
    [59]  f7877b0c  SIG_DFL 0000000000000000 0 
    [60]  f7877b20  SIG_DFL 0000000000000000 0 
    [61]  f7877b34  SIG_DFL 0000000000000000 0 
    [62]  f7877b48  SIG_DFL 0000000000000000 0 
    [63]  f7877b5c  SIG_DFL 0000000000000000 0 
    [64]  f7877b70  804867f 0000000000000000 10000004 (SA_SIGINFO|SA_RESTART)
   SIGPENDING: no
      BLOCKED: 8000000200000800
   PRIVATE_PENDING
       SIGNAL: 0000000200000800
     SIGQUEUE:  SIG  SIGINFO 
                 12  f51b9c84
                 34  f51b9594
   SHARED_PENDING
       SIGNAL: 8000000000000800
     SIGQUEUE:  SIG  SIGINFO 
                 12  f51b9188
                 64  f51b9d18
                 64  f51b9500
    
  Dump the signal-handling data for all tasks in the thread group containing
  PID 2578:

    crash&gt; sig -g 2578
    PID: 2387   TASK: f617d020  CPU: 0   COMMAND: "slapd"
    SIGNAL_STRUCT: f7dede00  COUNT: 6
    SIG SIGACTION  HANDLER       MASK       FLAGS
    [1]  c1f60c04   a258a7 0000000000000000 10000000 (SA_RESTART)
    [2]  c1f60c18   a258a7 0000000000000000 10000000 (SA_RESTART)
    [3]  c1f60c2c  SIG_DFL 0000000000000000 0
    [4]  c1f60c40  SIG_DFL 0000000000000000 0
    [5]  c1f60c54   a258a7 0000000000000000 10000000 (SA_RESTART)
    [6]  c1f60c68  SIG_DFL 0000000000000000 0
    [7]  c1f60c7c  SIG_DFL 0000000000000000 0
    [8]  c1f60c90  SIG_DFL 0000000000000000 0
    [9]  c1f60ca4  SIG_DFL 0000000000000000 0
   [10]  c1f60cb8   a25911 0000000000000000 10000000 (SA_RESTART)
   ...
   [64]  c1f610f0  SIG_DFL 0000000000000000 0
   SHARED_PENDING
       SIGNAL: 0000000000000000
     SIGQUEUE: (empty)
     
     PID: 2387   TASK: f617d020  CPU: 0   COMMAND: "slapd"
     SIGPENDING: no
        BLOCKED: 0000000000000000
     PRIVATE_PENDING
         SIGNAL: 0000000000000000
       SIGQUEUE: (empty)
    
     PID: 2392   TASK: f6175aa0  CPU: 0   COMMAND: "slapd"
     SIGPENDING: no
        BLOCKED: 0000000000000000
     PRIVATE_PENDING
         SIGNAL: 0000000000000000
       SIGQUEUE: (empty)
    
     PID: 2523   TASK: f7cd4aa0  CPU: 1   COMMAND: "slapd"
     SIGPENDING: no
        BLOCKED: 0000000000000000
     PRIVATE_PENDING
         SIGNAL: 0000000000000000
       SIGQUEUE: (empty)
    
     ...
    
  Translate the sigset_t mask value, cut-and-pasted from the signal handling
  data from signals 1 and 10 above:
 
    crash&gt; sig -s 800A000000000201
    SIGHUP SIGUSR1 SIGRTMAX-14 SIGRTMAX-12 SIGRTMAX
 
  List the signal numbers and their names:
 
    crash&gt; sig -l
     [1] SIGHUP
     [2] SIGINT
     [3] SIGQUIT
     [4] SIGILL
     [5] SIGTRAP
     [6] SIGABRT/SIGIOT
     [7] SIGBUS
     [8] SIGFPE
     [9] SIGKILL
    [10] SIGUSR1
    [11] SIGSEGV
    [12] SIGUSR2
    [13] SIGPIPE
    [14] SIGALRM
    [15] SIGTERM
    [16] SIGSTKFLT
    [17] SIGCHLD/SIGCLD
    [18] SIGCONT
    [19] SIGSTOP
    [20] SIGTSTP
    [21] SIGTTIN
    [22] SIGTTOU
    [23] SIGURG
    [24] SIGXCPU
    [25] SIGXFSZ
    [26] SIGVTALRM
    [27] SIGPROF
    [28] SIGWINCH
    [29] SIGIO/SIGPOLL
    [30] SIGPWR
    [31] SIGSYS
    [32] SIGRTMIN
    [33] SIGRTMIN+1
    [34] SIGRTMIN+2
    [35] SIGRTMIN+3
    [36] SIGRTMIN+4
    [37] SIGRTMIN+5
    [38] SIGRTMIN+6
    [39] SIGRTMIN+7
    [40] SIGRTMIN+8
    [41] SIGRTMIN+9
    [42] SIGRTMIN+10
    [43] SIGRTMIN+11
    [44] SIGRTMIN+12
    [45] SIGRTMIN+13
    [46] SIGRTMIN+14
    [47] SIGRTMIN+15
    [48] SIGRTMIN+16
    [49] SIGRTMAX-15
    [50] SIGRTMAX-14
    [51] SIGRTMAX-13
    [52] SIGRTMAX-12
    [53] SIGRTMAX-11
    [54] SIGRTMAX-10
    [55] SIGRTMAX-9
    [56] SIGRTMAX-8
    [57] SIGRTMAX-7
    [58] SIGRTMAX-6
    [59] SIGRTMAX-5
    [60] SIGRTMAX-4
    [61] SIGRTMAX-3
    [62] SIGRTMAX-2
    [63] SIGRTMAX-1
    [64] SIGRTMAX
</pre>

<h3 id="toc_0.0.33">*</h3>
<pre>
NAME
  * - pointer-to short-cut

SYNOPSIS
  * (struct or union command arguments)

DESCRIPTION
  This command is a short-cut command that replaces the requirement to enter
  "struct" or "union" command names.  For details on the arguments to
  those commands, enter "help struct" or "help union".

EXAMPLES
  Dump the page structure at address c02943c0:
 
    crash&gt; *page c02943c0
    struct page {
      next = 0xc0fae740, 
      prev = 0xc0018fb0, 
      inode = 0x0, 
      offset = 0x3f000, 
      next_hash = 0xc02d6310, 
      count = {
        counter = 0x1
      }, 
      flags = 0x310, 
      wait = 0xc02943d8, 
      pprev_hash = 0x0, 
      buffers = 0x0
    }
</pre>

<h3 id="toc_0.0.34">struct</h3>
<pre>
NAME
  struct - structure contents

SYNOPSIS
  struct struct_name[.member[,member]][-o][-l offset][-rfuxdp]
         [address | symbol][:cpuspec] [count | -c count]

DESCRIPTION
  This command displays either a structure definition, or a formatted display
  of the contents of a structure at a specified address.  When no address is
  specified, the structure definition is shown along with the structure size.
  A structure member may be appended to the structure name in order to limit
  the scope of the data displayed to that particular member; when no address
  is specified, the member's offset and definition are shown.

    struct_name  name of a C-code structure used by the kernel.
        .member  name of a structure member; to display multiple members of a
                 structure, use a comma-separated list of members.
             -o  show member offsets when displaying structure definitions; 
                 if used with an address or symbol argument, each member will
                 be preceded by its virtual address.
      -l offset  if the address argument is a pointer to a structure member that
                 is contained by the target data structure, typically a pointer
                 to an embedded list_head, the offset to the embedded member may
                 be entered in either of the following manners:
                   1. in "structure.member" format.
                   2. a number of bytes. 
             -r  raw dump of structure data.
             -f  address argument is a dumpfile offset.
             -u  address argument is a user virtual address in the current
                 context.
             -x  override default output format with hexadecimal format.
             -d  override default output format with decimal format.
             -p  if a structure member is a pointer value, show the member's
                 data type on the output line; and on the subsequent line(s),
                 dereference the pointer, display the pointer target's symbol
                 value in brackets if appropriate, and if possible, display the
                 target data; requires an address argument.
        address  hexadecimal address of a structure; if the address points
                 to an embedded list_head structure contained within the
                 target data structure, then the "-l" option must be used.
         symbol  symbolic reference to the address of a structure.
       :cpuspec  CPU specification for a per-cpu address or symbol:
                   :             CPU of the currently selected task.
                   :a[ll]        all CPUs.
                   :#[-#][,...]  CPU list(s), e.g. "1,3,5", "1-3",
                                 or "1,3,5-7,10".
          count  count of structures to dump from an array of structures;
                 if used, this must be the last argument entered.
       -c count  "-c" is only required if "count" is not the last argument
                 entered or if a negative number is entered; if a negative
                 value is entered, the (positive) "count" structures that
                 lead up to and include the target structure will be displayed.

  Structure data, sizes, and member offsets are shown in the current output
  radix unless the -x or -d option is specified.
 
  Please note that in the vast majority of cases, the "struct" command
  name may be dropped; if the structure name does not conflict with any crash
  or gdb command name, then the "struct_name[.member]" argument will be
  recognized as a structure name, and this command automatically executed.
  See the NOTE below.

EXAMPLES
  Display the vm_area_struct at address c1e44f10:

    crash&gt; struct vm_area_struct c1e44f10
    struct vm_area_struct {
      vm_mm = 0xc2857750,
      vm_start = 0x8048000, 
      vm_end = 0x80a5000, 
      vm_next = 0xc1e44a10,
      vm_page_prot = {
        pgprot = 0x25      
      },
      vm_flags = 0x1875,
      vm_avl_height = 0x2,   
      vm_avl_left = 0xc30fe200,
      vm_avl_right = 0xc30fed00,
      vm_next_share = 0x0,       
      vm_pprev_share = 0xc1e44a30,
      vm_ops = 0xc0215ca0,
      vm_offset = 0x0,       
      vm_file = 0xc0bfdc70,
      vm_pte = 0   
    }

  Display the definition and size of a vm_area_struct structure.  This first
  example below displays just the structure and size.  The second example
  uses the -o option to also display member offsets.  Both examples were
  run with the output radix set to 10 (decimal):

    crash&gt; struct vm_area_struct
    struct vm_area_struct {
        struct mm_struct *vm_mm;
        long unsigned int vm_start;
        long unsigned int vm_end;
        struct vm_area_struct *vm_next;
        pgprot_t vm_page_prot;
        short unsigned int vm_flags;
        short int vm_avl_height;
        struct vm_area_struct *vm_avl_left;
        struct vm_area_struct *vm_avl_right;
        struct vm_area_struct *vm_next_share;
        struct vm_area_struct **vm_pprev_share;
        struct vm_operations_struct *vm_ops;
        long unsigned int vm_offset;
        struct file *vm_file;
        long unsigned int vm_pte;
    }
    SIZE: 56

    crash&gt; struct vm_area_struct -o
    struct vm_area_struct {
       [0] struct mm_struct *vm_mm;
       [4] long unsigned int vm_start;
       [8] long unsigned int vm_end;
      [12] struct vm_area_struct *vm_next;
      [16] pgprot_t vm_page_prot;
      [20] short unsigned int vm_flags;
      [22] short int vm_avl_height;
      [24] struct vm_area_struct *vm_avl_left;
      [28] struct vm_area_struct *vm_avl_right;
      [32] struct vm_area_struct *vm_next_share;
      [36] struct vm_area_struct **vm_pprev_share;
      [40] struct vm_operations_struct *vm_ops;
      [44] long unsigned int vm_offset;
      [48] struct file *vm_file;
      [52] long unsigned int vm_pte;
    }
    SIZE: 56

  Display the definition and offset of the pgd member of an mm_struct:

    crash&gt; struct mm_struct.pgd
    struct mm_struct {
       [80] pgd_t *pgd;
    }

  Display the pgd member of the mm_struct at address ffff810022e7d080:

    crash&gt; struct mm_struct.pgd ffff810022e7d080
      pgd = 0xffff81000e3ac000

  Display the pgd_t pointed to by the mm_struct.pgd pointer above, forcing
  the output to be expressed in hexadecimal:

    crash&gt; mm_struct.pgd ffff810022e7d080 -px
      pgd_t *pgd = 0xffff81000e3ac000
      -&gt; {
           pgd = 0x2c0a6067
         }

  Display the thread_info structure pointed to by the thread_info
  member of the task_struct at ffff8100181190c0:

    crash&gt; task_struct.thread_info ffff8100181190c0 -p
      struct thread_info *thread_info = 0xffff810023c06000
      -&gt; {
           task = 0xffff8100181190c0,
           exec_domain = 0xffffffff802f78e0,
           flags = 128,
           status = 1,
           cpu = 3,
           preempt_count = 0,
           addr_limit = {
             seg = 18446604435732824064
           },
           restart_block = {
             fn = 0xffffffff80095a52 &lt;do_no_restart_syscall&gt;,
             arg0 = 0,
             arg1 = 0,
             arg2 = 0,
             arg3 = 0
           }
         }

  Display the flags and virtual members of 4 contigous page structures
  in the mem_map page structure array:

    crash&gt; page.flags,virtual c101196c 4
      flags = 0x8000,
      virtual = 0xc04b0000
    
      flags = 0x8000,
      virtual = 0xc04b1000
    
      flags = 0x8000,
      virtual = 0xc04b2000
    
      flags = 0x8000,
      virtual = 0xc04b3000
 
  Display the array of tcp_sl_timer structures declared by tcp_slt_array[]:

    crash&gt; struct tcp_sl_timer tcp_slt_array 4
    struct tcp_sl_timer {
      count = {
        counter = 0x0       
      },
      period = 0x32,      
      last = 0x1419e4,  
      handler = 0xc0164854  &lt;tcp_syn_recv_timer&gt;
    }
    struct tcp_sl_timer {
      count = {
        counter = 0x2       
      },
      period = 0x753,     
      last = 0x14a6df,  
      handler = 0xc01645b0  &lt;tcp_keepalive&gt;
    }
    struct tcp_sl_timer {
      count = {
        counter = 0x0       
      },
      period = 0x2ee,     
      last = 0x143134,  
      handler = 0xc016447c  &lt;tcp_twkill&gt;
    }
    struct tcp_sl_timer {
      count = {
        counter = 0x0       
      },
      period = 0x64,      
      last = 0x143198,  
      handler = 0xc0164404  &lt;tcp_bucketgc&gt;
    }
 
  Without using the "struct" command name, display the the "d_child" 
  list_head member from a dentry structure:

    crash&gt; dentry.d_child 0xe813cb4
      d_child = {
        next = 0x3661344,
        prev = 0xdea4bc4
      },
 
  Display the child dentry structure referenced by the "next" pointer above.
  Since the "next" address of 0x3661344 above is a pointer to an embedded
  list_head structure within the child dentry structure, the -l option
  is required:

    crash&gt; dentry -l dentry.d_child 0x3661344
    struct dentry {
      d_count = {
        counter = 1
      }, 
      d_flags = 0, 
      d_inode = 0xf9aa604, 
      d_parent = 0x11152b1c, 
      d_hash = {
        next = 0x11fb3fc0, 
        prev = 0x11fb3fc0
      }, 
      d_lru = {
        next = 0x366133c, 
        prev = 0x366133c
      }, 
      d_child = {
        next = 0x36613cc, 
        prev = 0xe813cd4
      }, 
      d_subdirs = {
        next = 0x366134c, 
        prev = 0x366134c
      }, 
      d_alias = {
        next = 0xf9aa614, 
        prev = 0xf9aa614
      }, 
      d_mounted = 0, 
      d_name = {
        name = 0x3661384 "boot.log", 
        len = 8, 
        hash = 1935169207
      }, 
      d_time = 1515870810, 
      d_op = 0x0, 
      d_sb = 0x11fc9c00, 
      d_vfs_flags = 0, 
      d_fsdata = 0x0, 
      d_extra_attributes = 0x0, 
      d_iname = "boot.log\000"
    }
 
  Display the virtual address of each member of the task_struct at
  ffff8100145d2080:

    crash&gt; task_struct -o ffff8100145d2080
    struct task_struct {
      [ffff8100145d2080] volatile long int state;
      [ffff8100145d2088] struct thread_info *thread_info;
      [ffff8100145d2090] atomic_t usage;
      [ffff8100145d2098] long unsigned int flags;
      [ffff8100145d20a0] int lock_depth;
      [ffff8100145d20a4] int load_weight;
      [ffff8100145d20a8] int prio;
      [ffff8100145d20ac] int static_prio;
      [ffff8100145d20b0] int normal_prio;
      [ffff8100145d20b8] struct list_head run_list;
      [ffff8100145d20c8] struct prio_array *array;
    ...
 
  For an example of displaying per-cpu variables, consider the
  struct hd_struct.dkstats member, which is a percpu pointer to
  a disk_stats structure:

    crash&gt; struct hd_struct.dkstats 
    struct hd_struct {
      [1232] struct disk_stats *dkstats;
    }

 Taking an hd_struct at address ffff8802450e2848, display all
 of the per-cpu disk_stats structures that it references:
 
    crash&gt; struct hd_struct.dkstats ffff8802450e2848
      dkstats = 0x60fdb48026c8
    crash&gt; struct disk_stats 0x60fdb48026c8:a
    [0]: ffffe8fefe6026c8
    struct disk_stats {
      sectors = {451376, 80468}, 
      ios = {6041, 971}, 
      merges = {386, 390}, 
      ticks = {194877, 56131}, 
      io_ticks = 12371, 
      time_in_queue = 309163
    }
    [1]: ffffe8fefe8026c8
    struct disk_stats {
      sectors = {0, 0}, 
      ios = {0, 0}, 
      merges = {7, 242}, 
      ticks = {0, 0}, 
      io_ticks = 23, 
      time_in_queue = 581
    }
    [2]: ffffe8fefea026c8
    struct disk_stats {
      sectors = {0, 0}, 
      ios = {0, 0}, 
      merges = {4, 112}, 
      ticks = {0, 0}, 
      io_ticks = 11, 
      time_in_queue = 305
    }
    [3]: ffffe8fefec026c8
    struct disk_stats {
      sectors = {0, 0}, 
      ios = {0, 0}, 
      merges = {5, 54}, 
      ticks = {0, 0}, 
      io_ticks = 17, 
      time_in_queue = 41
    }
 

NOTE
  If the structure name does not conflict with any crash command name, the
  "struct" command may be dropped.  Accordingly, the examples above could
  also have been accomplished like so:

    crash&gt; vm_area_struct c1e44f10
    crash&gt; vm_area_struct
    crash&gt; vm_area_struct -o
    crash&gt; mm_struct.pgd ffff810022e7d080
    crash&gt; mm_struct.pgd
    crash&gt; tcp_sl_timer tcp_slt_array 4

  Lastly, the short-cut "*" pointer-to command may also be used to negate
  the need to enter the "struct" command name (enter "help *" for details).
</pre>

<h3 id="toc_0.0.35">swap</h3>
<pre>
NAME
  swap - swap device information

SYNOPSIS
  swap  

DESCRIPTION
  This command displays information for each configured swap device.

EXAMPLE
  crash&gt; swap
  SWAP_INFO_STRUCT    TYPE       SIZE       USED    PCT  PRI  FILENAME
  ffff880153d45f40  PARTITION  7192568k   1200580k  16%   -1  /dev/dm-1
</pre>

<h3 id="toc_0.0.36">sym</h3>
<pre>
NAME
  sym - translate a symbol to its virtual address, or vice-versa 

SYNOPSIS
  sym [-l] | [-M] | [-m module] | [-p|-n] | [-q string] | [symbol | vaddr]

DESCRIPTION
  This command translates a symbol to its virtual address, or a static 
  kernel virtual address to its symbol -- or to a symbol-plus-offset value,
  if appropriate.  Additionally, the symbol type is shown in parentheses, 
  and if the symbol is a known text value, the file and line number are shown.

              -l  dumps all symbols and their values.
              -M  dumps the current set of module symbols.
       -m module  dumps the current set of symbols for a specified module.
              -p  display the target symbol and the previous symbol.
              -n  display the target symbol and the next symbol.
       -q string  searches for all symbols containing "string".
          symbol  a kernel text or data symbol.
           vaddr  a kernel virtual address.
 
  If the "symbol", "vaddr" or "string" argument resolves to a module
  symbol, then the module name will be displayed in brackets following the
  symbol value.

EXAMPLES
  Translate data symbol jiffies to its value, and vice-versa:

    crash&gt; sym jiffies
    c0213ae0 (D) jiffies

    crash&gt; sym c0213ae0
    c0213ae0 (D) jiffies

  Translate a text address to its symbolic value and source file:

    crash&gt; sym c0109944
    c0109944 (T) system_call+0x34  ../linux-2.2.5/arch/i386/kernel/signal.c: 723

  Dump the whole symbol table:

    crash&gt; sym -l
    c0100000 (T) _stext
    c0100000 (A) _text
    c0100000 (t) startup_32
    c0100000 (T) stext
    c01000a4 (t) checkCPUtype
    c0100139 (t) is486
    c0100148 (t) is386
    c01001b1 (t) L6
    c01001b3 (t) ready
    c01001b4 (t) check_x87
    c01001da (t) setup_idt
    c01001f7 (t) rp_sidt
    c0100204 (T) stack_start
    c010020c (t) int_msg
    c0100220 (t) ignore_int
    c0100242 (t) idt_descr
    c0100244 (T) idt
    c010024a (t) gdt_descr
    c010024c (T) gdt
    c0101000 (T) swapper_pg_dir
    c0102000 (T) pg0
    c0103000 (T) empty_bad_page
    c0104000 (T) empty_bad_page_table
    c0105000 (T) empty_zero_page
    ...

  Find all symbols containing the string "pipe":

    crash&gt; sym -q pipe
    c010ec60 (T) sys_pipe  
    c012f660 (t) pipe_read  
    c012f7b8 (t) pipe_write  
    c012f9c0 (t) pipe_lseek  
    c012f9d0 (t) bad_pipe_r  
    c012f9dc (t) bad_pipe_w  
    c012f9e8 (t) pipe_ioctl  
    c012fa18 (t) pipe_poll  
    c012fb00 (t) pipe_release  
    c012fb48 (t) pipe_read_release  
    c012fb5c (t) pipe_write_release  
    c012fb70 (t) pipe_rdwr_release  
    c012fba0 (t) pipe_read_open  
    c012fbb0 (t) pipe_write_open  
    c012fbc0 (t) pipe_rdwr_open  
    c012fbec (t) get_pipe_inode  
    c012fcc4 (T) do_pipe  
    c023a920 (D) read_pipe_fops  
    c023a960 (D) write_pipe_fops  
    c023a9a0 (D) rdwr_pipe_fops  
    c023a9e0 (D) pipe_inode_operations  

  Dump the symbols of the uart401 module, both before, and then after,
  the complete set of symbols are loaded with the "mod -s" command:

    crash&gt; sym -m uart401
    c8032000 MODULE START: uart401
    c8032138 (?) uart401intr  
    c803235c (?) attach_uart401  
    c8032638 (?) probe_uart401  
    c80326d4 (?) unload_uart401  
    c8033770 MODULE END: uart401
    crash&gt; mod -s uart401
     MODULE   NAME         SIZE  OBJECT FILE
    c8032000  uart401      6000  /lib/modules/2.2.14/misc/uart401.o
    crash&gt; sym -m uart401
    c8032000 MODULE START: uart401
    c8032050 (t) my_notifier_call  
    c8032084 (t) uart401_status  
    c8032098 (t) uart401_cmd  
    c80320a8 (t) uart401_read  
    c80320bc (t) uart401_write  
    c80320cc (t) uart401_input_loop  
    c8032138 (T) uart401intr  
    c8032168 (t) uart401_open  
    c80321c8 (t) uart401_close  
    c80321f4 (t) uart401_out  
    c80322ac (t) uart401_start_read  
    c80322b4 (t) uart401_end_read  
    c80322bc (t) uart401_kick  
    c80322c4 (t) uart401_buffer_status  
    c80322cc (t) enter_uart_mode  
    c803235c (T) attach_uart401  
    c803259c (t) reset_uart401  
    c8032638 (T) probe_uart401  
    c80326d4 (T) unload_uart401  
    c8032760 (T) init_module
    c80327cc (T) cleanup_module  
    c8032b00 (d) sound_notifier  
    c8032b0c (d) detected_devc  
    c8032b20 (d) std_synth_info  
    c8032bc0 (d) std_midi_synth  
    c8033600 (d) uart401_operations  
    c80336c4 (D) io  
    c80336c8 (D) irq  
    c80336e0 (b) hw_info.508  
    c8033770 MODULE END: uart401

  Display the value of jiffies, along with the next and previous symbols:

    crash&gt; sym -np jiffies
    c023027c (D) prof_shift
    c0230280 (D) jiffies 
    c02302a0 (D) task

  Translate a symbol value to its name and module:

    crash&gt; sym f88878d1
    f88878d1 (t) ext3_readdir [ext3]
    crash&gt;
</pre>

<h3 id="toc_0.0.37">sys</h3>
<pre>
NAME
  sys - system data

SYNOPSIS
  sys [-c [name|number]] config

DESCRIPTION
  This command displays system-specific data.  If no arguments are entered,
  the same system data shown during crash invocation is shown.

    -c [name|number]  If no name or number argument is entered, dump all
                      sys_call_table entries.  If a name string is entered,
                      search the table for all entries containing the string.
                      If a number is entered, the table entry associated with
                      that number is displayed.  If the current output radix
                      has been set to 16, the system call numbers will be 
                      displayed in hexadecimal.
    config            If the kernel was configured with CONFIG_IKCONFIG, then
                      dump the in-kernel configuration data.
    -panic            Panic a live system.  Requires write permission to
                      /dev/mem.  Results in the crash context causing an
                      "Attempted to kill the idle task!" panic.  (The dump
                      will indicate that the crash context has a PID of 0).

EXAMPLES
  Display essential system information:

    crash&gt; sys
          KERNEL: vmlinux.4
        DUMPFILE: lcore.cr.4
            CPUS: 4
            DATE: Mon Oct 11 18:48:55 1999
          UPTIME: 10 days, 14:14:39
    LOAD AVERAGE: 0.74, 0.23, 0.08
           TASKS: 77
        NODENAME: test.mclinux.com
         RELEASE: 2.2.5-15smp
         VERSION: #24 SMP Mon Oct 11 17:41:40 CDT 1999
         MACHINE: i686  (500 MHz)
          MEMORY: 1 GB

  Dump the system configuration data (if CONFIG_IKCONFIG):

    crash&gt; sys config
    #
    # Automatically generated make config: don't edit
    # Linux kernel version: 2.6.16
    # Mon Apr 10 07:58:06 2006
    #
    CONFIG_X86_64=y
    CONFIG_64BIT=y
    CONFIG_X86=y
    CONFIG_SEMAPHORE_SLEEPERS=y
    CONFIG_MMU=y
    CONFIG_RWSEM_GENERIC_SPINLOCK=y
    CONFIG_GENERIC_CALIBRATE_DELAY=y
    CONFIG_X86_CMPXCHG=y
    CONFIG_EARLY_PRINTK=y
    CONFIG_GENERIC_ISA_DMA=y
    CONFIG_GENERIC_IOMAP=y
    CONFIG_ARCH_MAY_HAVE_PC_FDC=y
    CONFIG_DMI=y
    ...

  Dump the system call table:

    crash&gt; sys -c
    NUM  SYSTEM CALL                FILE AND LINE NUMBER
      0  sys_ni_syscall             ../kernel/sys.c: 48
      1  sys_exit                   ../kernel/exit.c: 404
      2  sys_fork                   ../arch/i386/kernel/process.c: 771
      3  sys_read                   ../fs/read_write.c: 117
      4  sys_write                  ../fs/read_write.c: 146
      5  sys_open                   ../fs/open.c: 754
      6  sys_close                  ../fs/open.c: 839
      7  sys_waitpid                ../kernel/exit.c: 503
      8  sys_creat                  ../fs/open.c: 789
      9  sys_link                   ../fs/namei.c: 1213
     10  sys_unlink                 ../fs/namei.c: 1074
     11  sys_execve                 ../arch/i386/kernel/process.c: 806
    ...

  Find the system call number of the select system call:

    crash&gt; sys -c select
    NUM  SYSTEM CALL                FILE AND LINE NUMBER
     65  sys_select                 ../fs/select.c: 259
 
    If the current output radix has been set to 16, the system call numbers
    will be displayed in hexadecimal.
</pre>

<h3 id="toc_0.0.38">task</h3>
<pre>
NAME
  task - task_struct and thread_info contents

SYNOPSIS
  task [-R member[,member]] [-dx] [pid | taskp] ...

DESCRIPTION
  This command dumps a formatted display of the contents of a task's
  task_struct and thread_info structures.  Multiple task or PID numbers
  may be entered; if no arguments are entered, the task_struct and
  thread_info structures of the current context are displayed.  The -R option,
  which may also be invoked indirectly via "foreach task", pares the output
  down to one or more structure members.
 
        pid  a process PID.
      taskp  a hexadecimal task_struct pointer.
  -R member  a comma-separated list of one or more task_struct and/or
             thread_info structure members.
         -x  override default output format with hexadecimal format.
         -d  override default output format with decimal format.

EXAMPLES
  Dump the task_struct and thread_info structures of the current context
  in hexadecimal format:

    crash&gt; task -x
    PID: 3176   TASK: f2451550  CPU: 1   COMMAND: "memtest"
    struct task_struct {
      state = 0x0, 
      stack = 0xf05b6000, 
      usage = {
        counter = 0x2
      }, 
      flags = 0x402040, 
      ptrace = 0x0, 
      lock_depth = 0xffffffff, 
      prio = 0x78, 
      static_prio = 0x78, 
      normal_prio = 0x78, 
      rt_priority = 0x0, 
    ...
      perf_event_ctxp = {0x0, 0x0}, 
      memcg_batch = {
        do_batch = 0x0, 
        memcg = 0x0, 
        bytes = 0x0, 
        memsw_bytes = 0x0
      }
    }
    
    struct thread_info {
      task = 0xf2451550, 
      exec_domain = 0xc0a60860, 
      flags = 0x88, 
      status = 0x0, 
      cpu = 0x1, 
      preempt_count = 0x4010000, 
      addr_limit = {
        seg = 0xc0000000
      }, 
      restart_block = {
    ...
 
  Display the ngroups and groups task_struct members for PID 2958:

    crash&gt; task -R ngroups,groups 2958
    PID: 2958   TASK: c6718000  CPU: 0   COMMAND: "bash"
      ngroups = 6, 
      groups = {504, 8, 9, 1000, 1007, 1006, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
 
  NOTE: When this command is invoked directly (i.e., not from "foreach"), it
  is not necessary to include the "-R" before the task_struct/thread_info
  member name(s).
</pre>

<h3 id="toc_0.0.39">timer</h3>
<pre>
NAME
  timer - timer queue data

SYNOPSIS
  timer [-r]

DESCRIPTION
  This command displays the timer queue entries, both old- and new-style,
  in chronological order.  In the case of the old-style timers, the
  timer_table array index is shown; in the case of the new-style timers, 
  the timer_list address is shown.  On later kernels, the timer data is
  per-cpu.

    -r  Display hrtimer timer queue entries, both old- and new-style, in
        chronological order.  In the case of the old-style hrtimers, the
        expiration time is a single value; in the new-style hrtimers, the
        expiration time is a range.

EXAMPLES
    crash&gt; timer
    JIFFIES
      68102
    EXPIRES  TIMER_LIST/TABLE  FUNCTION
      68346      c0241934      c01775d4  &lt;tcp_sltimer_handler&gt;
      68379      c0241204      c01696d8  &lt;dev_do_watchdog&gt;
      68523      c7fcdfc0      c0112d6c  &lt;process_timeout&gt;
      68718      c7fd8edc      c018719c  &lt;irlmp_discovery_timer_expired&gt;
      68723   timer_table[2]   c01c707c  &lt;rs_timer&gt;
      68742      c20c1f7c      c0112d6c  &lt;process_timeout&gt;
      68742      c20c1f7c      c0112d6c  &lt;process_timeout&gt;
      68742      c20c1f7c      c0112d6c  &lt;process_timeout&gt;
      68752      c7fd1fc4      c0112d6c  &lt;process_timeout&gt;
      68752      c7fd1fc4      c0112d6c  &lt;process_timeout&gt;
      68989      c0241d40      c0168060  &lt;neigh_periodic_timer&gt;
      69028      c2533f7c      c0112d6c  &lt;process_timeout&gt;
      69134      c22dd868      c0181948  &lt;unix_destroy_timer&gt;
      71574      c0241430      c0169ea4  &lt;rt_check_expire&gt;
      72179      c7fb1c48      c01cb9a0  &lt;vortex_timer&gt;
      73144      c1b17f10      c0112d6c  &lt;process_timeout&gt;
      73259      c17a5f10      c0112d6c  &lt;process_timeout&gt;
     112929      c203ff10      c0112d6c  &lt;process_timeout&gt;
     372010      c2323f7c      c0112d6c  &lt;process_timeout&gt;
     372138      c2191f10      c0112d6c  &lt;process_timeout&gt;
    8653052      c1f13f10      c0112d6c  &lt;process_timeout&gt;
 
  Display the timer queue on a 2-cpu system:

    crash&gt; timer
    TVEC_BASES[0]: c1299be0
     JIFFIES
    18256298
     EXPIRES  TIMER_LIST  FUNCTION
    18256406   cd5ddec0   c01232bb  &lt;process_timeout&gt;
    18256677   ceea93e0   c011e3cc  &lt;it_real_fn&gt;
    18256850   ceea7f64   c01232bb  &lt;process_timeout&gt;
    18258751   cd1d4f64   c01232bb  &lt;process_timeout&gt;
    18258792   cf5782f0   c011e3cc  &lt;it_real_fn&gt;
    18261266   c03c9f80   c022fad5  &lt;rt_check_expire&gt;
    18262196   c02dc2e0   c0233329  &lt;peer_check_expire&gt;
    18270518   ceb8bf1c   c01232bb  &lt;process_timeout&gt;
    18271327   c03c9120   c0222074  &lt;flow_cache_new_hashrnd&gt;
    18271327   c03ca580   c0233ace  &lt;ipfrag_secret_rebuild&gt;
    18272532   c02d1e18   c0129946  &lt;delayed_work_timer_fn&gt;
    18276518   c03c9fc0   c022fd40  &lt;rt_secret_rebuild&gt;
    18332334   ceea9970   c011e3cc  &lt;it_real_fn&gt;
    18332334   cfb6a840   c011e3cc  &lt;it_real_fn&gt;
    18665378   cec25ec0   c01232bb  &lt;process_timeout&gt;
    TVEC_BASES[1]: c12a1be0
     JIFFIES
    18256298
     EXPIRES  TIMER_LIST  FUNCTION
    18256493   c02c7d00   c013dad5  &lt;wb_timer_fn&gt;
    18256499   c12a2db8   c0129946  &lt;delayed_work_timer_fn&gt;
    18277900   ceebaec0   c01232bb  &lt;process_timeout&gt;
    18283769   cf739f64   c01232bb  &lt;process_timeout&gt;
    18331902   cee8af64   c01232bb  &lt;process_timeout&gt;
 
  Display a new-style hrtimer queue:

    crash&gt; timer -r
    CPU: 0  HRTIMER_CPU_BASE: c1e03fc0
      CLOCK: 0  HRTIMER_CLOCK_BASE: c1e03fc4  [ktime_get_real]
      (empty)
    
      CLOCK: 1  HRTIMER_CLOCK_BASE: c1e03ff0  [ktime_get]
         CURRENT
      322894000000
       SOFTEXPIRES     EXPIRES    HRTIMER   FUNCTION
      322895000000  322895000000  c1e04080  c04833e0  &lt;tick_sched_timer&gt;
      324022213609  324022213609  c1e041c0  c04b17d0  &lt;watchdog_timer_fn&gt;
      326766922781  326766972781  f3a45f44  c0477ed0  &lt;hrtimer_wakeup&gt;
      364516801997  364516851997  f43bbf44  c0477ed0  &lt;hrtimer_wakeup&gt;
 
      CLOCK: 2  HRTIMER_CLOCK_BASE: c1e0401c  [ktime_get_boottime]
      (empty)
    
    CPU: 1  HRTIMER_CPU_BASE: c1e43fc0
      CLOCK: 0  HRTIMER_CLOCK_BASE: c1e43fc4  [ktime_get_real]
      (empty)
    
      CLOCK: 1  HRTIMER_CLOCK_BASE: c1e43ff0  [ktime_get]
         CURRENT
      322894000000
       SOFTEXPIRES     EXPIRES    HRTIMER   FUNCTION
      322895062500  322895062500  c1e44080  c04833e0  &lt;tick_sched_timer&gt;
      324087213609  324087213609  c1e441c0  c04b17d0  &lt;watchdog_timer_fn&gt;
      381034500892  381034550892  f3a1bea0  c0477ed0  &lt;hrtimer_wakeup&gt;
 
      CLOCK: 2  HRTIMER_CLOCK_BASE: c1e4401c  [ktime_get_boottime]
      (empty)
    ...
 
  Display an old-style hrtimer queue:

    crash&gt; timer -r
    CPU: 0
      CLOCK: 0  HRTIMER_BASE: ca00dae0  [ktime_get_real]
      (empty)
    
      CLOCK: 1  HRTIMER_BASE: ca00db0c  [ktime_get]
           CURRENT
      1480537567000000
           EXPIRES      HRTIMER   FUNCTION
      1480997557052703  f79c4944  c0427d18  &lt;it_real_fn&gt;
      1481009329944302  cdcbaf6c  c0436a1e  &lt;hrtimer_wakeup&gt;
      1481026181758643  ea01cf6c  c0436a1e  &lt;hrtimer_wakeup&gt;
      1481497068511094  f79a6244  c0427d18  &lt;it_real_fn&gt;
      1481589831928489  f7af6944  c0427d18  &lt;it_real_fn&gt;
      1481592731187337  f64ed784  c0427d18  &lt;it_real_fn&gt;
    
    CPU: 1
      CLOCK: 0  HRTIMER_BASE: ca0148c4  [ktime_get_real]
      (empty)
    
      CLOCK: 1  HRTIMER_BASE: ca0148f0  [ktime_get]
           CURRENT
      1480537567000000
           EXPIRES      HRTIMER   FUNCTION
      1481017523822478  ca3b15c4  c0427d18  &lt;it_real_fn&gt;
      1481238077723188  f5f35f6c  c0436a1e  &lt;hrtimer_wakeup&gt;
      1481492107740948  f5dadf6c  c0436a1e  &lt;hrtimer_wakeup&gt;
      1482936527251241  ca1becc4  c0427d18  &lt;it_real_fn&gt;
      1482936545249010  f7d42e84  c0427d18  &lt;it_real_fn&gt;
      1492850155229325  ea01ef6c  c0436a1e  &lt;hrtimer_wakeup&gt;
    ...
</pre>

<h3 id="toc_0.0.40">tree</h3>
<pre>
NAME
  tree - display radix tree or red-black tree

SYNOPSIS
  tree -t [radix|rbtree] [-r offset] [-s struct[.member[,member]] -[x|d]]
          [-o offset] [-p] [-N] start

DESCRIPTION
  This command dumps the contents of a radix tree or a red-black tree.
  The arguments are as follows:

    -t type  The type of tree to dump; the type string can be either 
             "radix" or "rbtree", although only the first two characters
             are required.
  -r offset  If the "start" argument is the address of a data structure that
             contains the radix_tree_root or rb_root structure, then this is
             the offset to that structure member.  If the offset is non-zero,
             then this option is required.  The offset may be entered in either
             of two manners:
               1. In "structure.member" format.
               2. A number of bytes.
  -o offset  For red-black trees only, the offset of the rb_node within its 
             containing data structure; if the offset is non-zero, then this
             option is required.  The offset may be entered in either of two
             manners:
               1. In "structure.member" format.
               2. A number of bytes.
             This option is not applicable to radix trees.
  -s struct  For each entry in a tree, format and print it as this type of data
             structure; use the "struct.member" format in order to display a
             particular member of the structure.  To display multiple members
             of a structure, use a comma-separated list of members.
         -x  Override default output format with hexadecimal format.
         -d  Override default output format with decimal format.
         -p  Display the node's position information, showing the relationship
             between it and the root.  For red-black trees, a position that
             indicates "root/l/r" means that the node is the right child
             of the left child of the root node.  For radix trees, the height
             and slot index values are shown with respect to the root.
 
  The meaning of the "start" argument, which can be expressed either in
  hexadecimal format or symbolically, depends upon whether the -N option
  is prepended:
 
      start  The address of a radix_tree_root or rb_root structure, or the
             address of a structure containing the radix_tree_root or rb_root
             structure; if the latter, then the "-r offset" option must be
             used if the member offset of the root structure is non-zero.
               
   -N start  The address of the structure radix_tree_node or rb_node, bypassing
             the radix_tree_root or rb_root that points to it.


EXAMPLES
  The vmap_area_root is a standalone rb_root structure.  Display the 
  virtual addresses of each vmap_area in its red-black tree:

    crash&gt; whatis vmap_area_root
    struct rb_root vmap_area_root;
    crash&gt; tree -t rbtree -o vmap_area.rb_node vmap_area_root
    ffff880128c508c0
    ffff88012cb68140
    ffff88012c9afec0
    ffff88012d65c440
    ...

  Display the vmap_area's va_start and va_end members of each of
  the entries above expressing the vmap_area.rb_node offset as a
  number of bytes:

    crash&gt; tree -t rbtree -o 24 vmap_area_root -s vmap_area.va_start,va_end
    ffff880128c508c0
      va_start = 0xffffc90014900000
      va_end = 0xffffc90014921000
    ffff88012cb68140
      va_start = 0xffffc900110c0000
      va_end = 0xffffc900110d1000
    ffff88012c9afec0
      va_start = 0xffffc90000640000
      va_end = 0xffffc90000642000
    ffff88012d65c440
      va_start = 0xffffc90000620000
      va_end = 0xffffc90000622000
    ...

  Alternatively, use the -N option with the rb_node address contained
  in the vmap_area_root structure:

    crash&gt; p vmap_area_root
    vmap_area_root = $8 = {
      rb_node = 0xffff880128c508d8
    }
    crash&gt; tree -t rbtree -o vmap_area.rb_node -N 0xffff880128c508d8
    ffff880128c508c0
    ffff88012cb68140
    ffff88012c9afec0
    ffff88012d65c440
 
  Display the virtual address of each vm_area_struct in the red-black
  tree that has its root inside an mm_struct located at ffff880128b5a300.
  The vm_area_struct.vm_rb rb_node member has an offset of 0x38 bytes:

    crash&gt; tree -t rbtree -r mm_struct.mm_rb ffff880128b5a300 -o 0x38
    ffff88012a0de080
    ffff880123e3ac78
    ffff880123e3a700
    ffff88012b2837c8
    ...
    ffff880128c02ed0
    ffff8801292e7958
    ffff880123e3a318
    ffff880123e3ad40
 
  Add the -p option to the command above to show position information:

    crash&gt; tree -t rbtree -r mm_struct.mm_rb ffff880128b5a300 -o 0x38 -p
    ffff88012a0de080
      position: root
    ffff880123e3ac78
      position: root/l
    ffff880123e3a700
      position: root/l/l
    ffff88012b2837c8
      position: root/l/l/l
    ...
    ffff880128c02ed0
      position: root/r/r/l/r
    ffff8801292e7958
      position: root/r/r/l/r/r
    ffff880123e3a318
      position: root/r/r/r
    ffff880123e3ad40
      position: root/r/r/r/r

  Display a list of the page structs in the radix tree of an address_space
  structure located at ffff88012d364de0:

    crash&gt; tree -t radix -r address_space.page_tree ffff88012d364de0
    ffffea00040d12c0
    ffffea00040d9a60
    ffffea00040d9b08
    ffffea000407eda8
    ffffea0004084288
    ...
    ffffea000407bc70
    ffffea00040baf48
    ffffea0004043f48
    ffffea000407de58
 
  Add the -p option to the command above to show position information:

    crash&gt; tree -t radix -r address_space.page_tree ffff88012d364de0 -p
    ffffea00040d12c0
      position: root/0/0
    ffffea00040d9a60
      position: root/0/1
    ffffea00040d9b08
      position: root/0/2
    ffffea000407eda8
      position: root/0/3
    ffffea0004084288
      position: root/0/4
    ...
    ffffea000407bc70
      position: root/3/25
    ffffea00040baf48
      position: root/3/26
    ffffea0004043f48
      position: root/3/27
    ffffea000407de58
      position: root/3/28

  Alternatively, take the address of the radix_tree_node from the
  radix_tree_root structure in the address_space structure above,
  and display the tree with the -N option:

    crash&gt; struct address_space.page_tree ffff88012d364de0
      page_tree = {
        height = 0x2, 
        gfp_mask = 0x20, 
        rnode = 0xffff8801238add71
      }
    crash&gt; tree -t radix -N 0xffff8801238add71
    ffffea00040d12c0
    ffffea00040d9a60
    ffffea00040d9b08
    ffffea000407eda8
    ffffea0004084288
    ffffea00040843a0
    ...
 
  Using the same radix tree as above, display the flags and _count
  members of each page struct in the list, and force the output format
  to be hexadecimal:

    crash&gt; tree -t radix -N 0xffff8801238add71 -s page.flags,_count -x
    ffffea00040d12c0
      flags = 0x4000000002006c
      _count = {
        counter = 0x7
      }
    ffffea00040d9a60
      flags = 0x4000000002006c
      _count = {
        counter = 0x7
      }
    ffffea00040d9b08
      flags = 0x4000000002006c
      _count = {
        counter = 0x7
      }
    ffffea000407eda8
      flags = 0x4000000002006c
      _count = {
        counter = 0x7
      }
    ...
</pre>

<h3 id="toc_0.0.41">union</h3>
<pre>
NAME
  union - union contents

SYNOPSIS
  union union_name[.member[,member]] [-o][-l offset][-rfuxdp]
         [address | symbol][:cpuspec] [count | -c count]

DESCRIPTION
  This command displays either a union definition, or a formatted display
  of the contents of a union at a specified address.  When no address is
  specified, the union definition is shown along with the union size.
  A union member may be appended to the structure name in order to limit
  the scope of the data displayed to that particular member; when no address
  is specified, the member's offset (always 0) and definition are shown.

     union_name  name of a C-code union used by the kernel.
        .member  name of a union member; to display multiple members of a
                 union, use a comma-separated list of members.
             -o  show member offsets when displaying union definitions; the
                 offset is always 0 unless used with an address or symbol
                 argument, in which case each member will be preceded by its
                 virtual address.
      -l offset  if the address argument is a pointer to a list_head structure
                 that is embedded in the target union structure, the offset
                 to the list_head member may be entered in either of the
                 following manners:
                   1. in "structure.member" format.
                   2. a number of bytes. 
             -r  raw dump of union data.
             -f  address argument is a dumpfile offset.
             -x  override default output format with hexadecimal format.
             -d  override default output format with decimal format.
             -p  if a union member is a pointer value, show the member's
                 data type on the output line; and on the subsequent line(s),
                 dereference the pointer, display the pointer target's symbol
                 value in brackets if appropriate, and if possible, display the
                 target data; requires an address argument.
             -u  address argument is a user virtual address in the current
                 context.
        address  hexadecimal address of a union; if the address points
                 to an embedded list_head structure contained within the
                 target union structure, then the "-l" option must be used.
         symbol  symbolic reference to the address of a union.
       :cpuspec  CPU specification for a per-cpu address or symbol:
                   :             CPU of the currently selected task.
                   :a[ll]        all CPUs.
                   :#[-#][,...]  CPU list(s), e.g. "1,3,5", "1-3",
                                or "1,3,5-7,10".
          count  count of unions to dump from an array of unions; if used,
                 this must be the last argument entered.
       -c count  "-c" is only required if "count" is not the last argument
                 entered or if a negative number is entered; if a negative
                 value is entered, the (positive) "count" structures that
                 lead up to and include the target structure will be displayed.

  Union data, sizes, and member offsets are shown in the current output radix
  unless the -x or -d option is specified.
 
  Please note that in the vast majority of cases, the "union" command
  name may be dropped; if the union name does not conflict with any crash
  or gdb command name, then the "union_name[.member]" argument will be
  recognized as a union name, and this command automatically executed.
  See the NOTE below.

EXAMPLES

  Display the bdflush_param union definition, and then an instance of it:

    crash&gt; union bdflush_param
    union bdflush_param {
        struct {
            int nfract;
            int ndirty;
            int nrefill;
            int nref_dirt;
            int dummy1;
            int age_buffer;
            int age_super;
            int dummy2;
            int dummy3;
        } b_un;
        unsigned int data[9];
    }
    
    SIZE: 36  (0x24)
 
    crash&gt; union bdflush_param bdf_prm
    union bdflush_param {
      b_un = {
        nfract = 40, 
        ndirty = 500, 
        nrefill = 64, 
        nref_dirt = 256, 
        dummy1 = 15, 
        age_buffer = 3000, 
        age_super = 500, 
        dummy2 = 1884, 
        dummy3 = 2
      }, 
      data = {40, 500, 64, 256, 15, 3000, 500, 1884, 2}
    }

NOTE
  If the union name does not conflict with any crash command name, the
  "union" command may be dropped.  Accordingly, the examples above could
  also have been accomplished like so:

    crash&gt; bdflush_param
    crash&gt; bdflush_param bdf_prm
 
  Lastly, the short-cut "*" (pointer-to) command may also be used to negate
  the need to enter the "union" command name (enter "help *" for details).
</pre>

<h3 id="toc_0.0.42">vm</h3>
<pre>
NAME
  vm - virtual memory

SYNOPSIS
  vm [-p | -P vmaddr | -v | -m | -x | -d | [-R reference] | [-f vm_flags]]
     [pid | taskp] ... 

DESCRIPTION
  This command displays basic virtual memory information of a context,
  consisting of a pointer to its mm_struct and page dirctory, its RSS and 
  total virtual memory size; and a list of pointers to each vm_area_struct,
  its starting and ending address, vm_flags value, and file pathname.  If no
  arguments are entered, the current context is used.  Additionally, the -p 
  option translates each virtual page of each VM area to its physical address.
  The -R option, typically invoked from "foreach vm", searches for references
  to a supplied number, address, or filename argument, and prints only the
  essential information leading up to and including the reference.  
  Alternatively, the -m or -v options may be used to dump the task's mm_struct
  or all of its vm_area_structs respectively.  The -p, -v, -m, -R and -f
  options are all mutually exclusive.

            -p  translate each virtual page to its physical address, or if
                the page is not mapped, its swap device and offset, or
                filename and offset.
     -P vmaddr  similar to -p, but only translate the pages belonging to the
                specified VM area of a context.
  -R reference  search for references to this number or filename.
            -m  dump the mm_struct assocated with the task.
            -v  dump all of the vm_area_structs associated with the task.
            -x  override the default output format for the -m or -v options
                with hexadecimal format.
            -d  override the default output format for the -m or -v options
                with decimal format.
   -f vm_flags  translate the bits of a FLAGS (vm_flags) value.
           pid  a process PID.
         taskp  a hexadecimal task_struct pointer.

EXAMPLES
  Display the virtual memory data of the current context:

    crash&gt; vm
    PID: 30986  TASK: c0440000  CPU: 0   COMMAND: "bash"
       MM       PGD       RSS    TOTAL_VM
    c303fe20  c4789000    88k      1728k
      VMA      START      END     FLAGS  FILE
    c0d1f540   8048000   80ad000  1875   /bin/bash
    c0d1f400   80ad000   80b3000  1873   /bin/bash
    c0d1f880   80b3000   80ec000    77
    c0d1f0c0  40000000  40012000   875   /lib/ld-2.1.1.so
    c0d1f700  40012000  40013000   873   /lib/ld-2.1.1.so
    c0d1fe00  40013000  40014000    77
    c0d1f580  40014000  40016000    73
    c0d1f280  4001a000  4004b000    75   /usr/lib/libncurses.so.4.2
    c0d1f100  4004b000  40054000    73   /usr/lib/libncurses.so.4.2
    c0d1f600  40054000  40057000    73
    c0d1f9c0  40057000  40059000    75   /lib/libdl-2.1.1.so
    c0d1f800  40059000  4005a000    73   /lib/libdl-2.1.1.so
    c0d1fd00  4005a000  40140000    75   /lib/libc-2.1.1.so
    c0d1fe40  40140000  40145000    73   /lib/libc-2.1.1.so
    c0d1f780  40145000  40148000    73
    c0d1f140  40148000  40150000    75   /lib/libnss_files-2.1.1.so
    c0d1fa80  40150000  40151000    73   /lib/libnss_files-2.1.1.so
    c0d1fb00  40151000  4015a000    75   /lib/libnss_nisplus-2.1.1.so
    c5f754e0  4015a000  4015b000    73   /lib/libnss_nisplus-2.1.1.so
    c0d1fec0  4015b000  4016d000    75   /lib/libnsl-2.1.1.so
    c5f75460  4016d000  4016e000    73   /lib/libnsl-2.1.1.so
    c5f75420  4016e000  40170000    73
    c5f753e0  40170000  40178000    75   /lib/libnss_nis-2.1.1.so
    c5f753a0  40178000  40179000    73   /lib/libnss_nis-2.1.1.so
    c0d1f240  bfffc000  c0000000   177

  Display the virtual memory data along with page translations for PID 386:

    crash&gt; vm -p 386
    PID: 386    TASK: c11cc000  CPU: 0   COMMAND: "atd"
       MM       PGD       RSS    TOTAL_VM
    c7e30560  c10e5000    104k     1112k
      VMA      START      END     FLAGS  FILE
    c0fbe6a0   8048000   804b000  1875   /usr/sbin/atd
     VIRTUAL  PHYSICAL
     8048000  20e1000
     8049000  17c6000
     804a000  1f6f000
      VMA      START      END     FLAGS  FILE
    c61e0ba0   804b000   804d000  1873   /usr/sbin/atd
     VIRTUAL  PHYSICAL
     804b000  254d000
     804c000  6a9c000
      VMA      START      END     FLAGS  FILE
    c61e04e0   804d000   8050000    77   
     VIRTUAL  PHYSICAL
     804d000  219d000
     804e000  2617000
     804f000  SWAP: /dev/sda8  OFFSET: 24225
      VMA      START      END     FLAGS  FILE
    c61e0720  40000000  40012000   875   /lib/ld-2.1.1.so
     VIRTUAL  PHYSICAL
    40000000  FILE: /lib/ld-2.1.1.so  OFFSET: 0
    40001000  FILE: /lib/ld-2.1.1.so  OFFSET: 1000
    40002000  FILE: /lib/ld-2.1.1.so  OFFSET: 2000
    40003000  FILE: /lib/ld-2.1.1.so  OFFSET: 3000
    40004000  FILE: /lib/ld-2.1.1.so  OFFSET: 4000
    40005000  FILE: /lib/ld-2.1.1.so  OFFSET: 5000
    ...
 
  Although the -R option is typically invoked from "foreach vm", it can be
  executed directly.  This example displays all VM areas with vm_flags of 75:

    crash&gt; vm -R 75
    PID: 694    TASK: c0c76000  CPU: 1   COMMAND: "crash"
       MM       PGD      RSS    TOTAL_VM
    c6c43110  c0fe9000  8932k    10720k 
      VMA       START      END   FLAGS  FILE
    c322c0d0  40019000  4004a000    75  /usr/lib/libncurses.so.4.2
    c67537c0  40056000  40071000    75  /lib/libm-2.1.1.so
    c6753d00  40072000  40074000    75  /lib/libdl-2.1.1.so
    c6753540  40075000  40081000    75  /usr/lib/libz.so.1.1.3
    c6753740  40085000  4016b000    75  /lib/libc-2.1.1.so
 
  One reason to use -R directly is to pare down the output associated with
  the -p option on a task with a huge address space.  This example displays
  the page data associated with virtual address 40121000:

    crash&gt; vm -R 40121000
    PID: 694    TASK: c0c76000  CPU: 0   COMMAND: "crash"
       MM       PGD      RSS    TOTAL_VM
    c6c43110  c0fe9000  8928k    10720k 
      VMA       START      END   FLAGS  FILE
    c6753740  40085000  4016b000    75  /lib/libc-2.1.1.so
    VIRTUAL   PHYSICAL
    40121000  FILE: /lib/libc-2.1.1.so  OFFSET: 9c000
 
  Display the mm_struct for PID 4777:

    crash&gt; vm -m 4777
    PID: 4777   TASK: c0896000  CPU: 0   COMMAND: "bash"
    struct mm_struct {
      mmap = 0xc6caa1c0, 
      mmap_avl = 0x0, 
      mmap_cache = 0xc6caabc0, 
      pgd = 0xc100a000, 
      count = {
        counter = 0x1
      }, 
      map_count = 0x14, 
      mmap_sem = {
        count = {
          counter = 0x1
        }, 
        waking = 0x0, 
        wait = 0x0
      }, 
      context = 0x0, 
      start_code = 0x8048000, 
      end_code = 0x809c6f7, 
      start_data = 0x0, 
      end_data = 0x80a2090, 
      start_brk = 0x80a5420, 
      brk = 0x80b9000, 
      start_stack = 0xbffff9d0, 
      arg_start = 0xbffffad1, 
      arg_end = 0xbffffad7, 
      env_start = 0xbffffad7, 
      env_end = 0xbffffff2, 
      rss = 0xf6, 
      total_vm = 0x1a3, 
      locked_vm = 0x0, 
      def_flags = 0x0, 
      cpu_vm_mask = 0x0, 
      swap_cnt = 0x23d,
      swap_address = 0x0, 
      segments = 0x0
    }
 
  Display all of the vm_area_structs for task c47d4000:

    crash&gt; vm -v c47d4000
    PID: 4971   TASK: c47d4000  CPU: 1   COMMAND: "login"
    struct vm_area_struct {
      vm_mm = 0xc4b0d200, 
      vm_start = 0x8048000, 
      vm_end = 0x804d000, 
      vm_next = 0xc3e3abd0, 
      vm_page_prot = {
        pgprot = 0x25
      }, 
      vm_flags = 0x1875, 
      vm_avl_height = 0x1, 
      vm_avl_left = 0x0, 
      vm_avl_right = 0x0, 
      vm_next_share = 0x0, 
      vm_pprev_share = 0xc3e3abf0, 
      vm_ops = 0xc02392a0, 
      vm_offset = 0x0, 
      vm_file = 0xc1e23660, 
      vm_pte = 0x0
    }
    struct vm_area_struct {
      vm_mm = 0xc4b0d200, 
      vm_start = 0x804d000, 
      vm_end = 0x804e000, 
      vm_next = 0xc3e3a010, 
      vm_page_prot = {
        pgprot = 0x25
      }, 
      vm_flags = 0x1873, 
      vm_avl_height = 0x2, 
      vm_avl_left = 0xc3e3a810, 
      vm_avl_right = 0xc3e3a010, 
      vm_next_share = 0xc3e3a810, 
      vm_pprev_share = 0xc3699c14
      ...
 
  Translate a FLAGS value:

    crash&gt; vm -f 3875
    3875: (READ|EXEC|MAYREAD|MAYWRITE|MAYEXEC|DENYWRITE|EXECUTABLE|LOCKED)
 
  Display the page translations of the VM area at address f5604f2c:

    crash&gt; vm -P f5604f2c
    PID: 5508   TASK: f56a9570  CPU: 0   COMMAND: "crond"
      VMA       START      END    FLAGS  FILE
    f5604f2c    f5b000    f67000 8000075  /lib/libnss_files-2.12.so
    VIRTUAL   PHYSICAL
    f5b000    3fec1000
    f5c000    3d3a4000
    f5d000    FILE: /lib/libnss_files-2.12.so  OFFSET: 2000
    f5e000    FILE: /lib/libnss_files-2.12.so  OFFSET: 3000
    f5f000    FILE: /lib/libnss_files-2.12.so  OFFSET: 4000
    f60000    3fd31000
    f61000    3fd32000
    f62000    FILE: /lib/libnss_files-2.12.so  OFFSET: 7000
    f63000    FILE: /lib/libnss_files-2.12.so  OFFSET: 8000
    f64000    3ff35000
    f65000    FILE: /lib/libnss_files-2.12.so  OFFSET: a000
    f66000    FILE: /lib/libnss_files-2.12.so  OFFSET: b000
</pre>

<h3 id="toc_0.0.43">vtop</h3>
<pre>
NAME
  vtop - virtual to physical

SYNOPSIS
  vtop [-c [pid | taskp]] [-u|-k] address ...

DESCRIPTION
  This command translates a user or kernel virtual address to its physical
  address.  Also displayed is the PTE translation, the vm_area_struct data
  for user virtual addresses, the mem_map page data associated with the
  physical page, and the swap location or file location if the page is
  not mapped.  The -u and -k options specify that the address is a user
  or kernel virtual address; -u and -k are not necessary on processors whose
  virtual addresses self-define themselves as user or kernel.  User addresses
  are translated with respect to the current context unless the -c option
  is used.  Kernel virtual addresses are translated using the swapper_pg_dir
  as the base page directory unless the -c option is used.
 
   -u                 The address is a user virtual address; only required
                      on processors with overlapping user and kernel virtual
                      address spaces.
   -k                 The address is a kernel virtual address; only required
                      on processors with overlapping user and kernel virtual
                      address spaces.
   -c [pid | taskp]   Translate the virtual address from the page directory
                      of the specified PID or hexadecimal task_struct pointer.
                      However, if this command is invoked from "foreach vtop",
                      the pid or taskp argument should NOT be entered; the
                      address will be translated using the page directory of
                      each task specified by "foreach".
   address            A hexadecimal user or kernel virtual address.

EXAMPLES
  Translate user virtual address 80b4000:

    crash&gt; vtop 80b4000
    VIRTUAL   PHYSICAL
    80b4000   660f000
    
    PAGE DIRECTORY: c37f0000
      PGD: c37f0080 =&gt; e0d067
      PMD: c37f0080 =&gt; e0d067
      PTE: c0e0d2d0 =&gt; 660f067
     PAGE: 660f000
 
      PTE    PHYSICAL  FLAGS
    660f067   660f000  (PRESENT|RW|USER|ACCESSED|DIRTY)
    
      VMA      START      END      FLAGS  FILE
    c773daa0   80b4000   810c000    77
    
      PAGE    PHYSICAL   INODE     OFFSET  CNT FLAGS
    c0393258   660f000         0     17000  1  uptodate
    
  Translate kernel virtual address c806e000, first using swapper_pg_dir
  as the page directory base, and secondly, using the page table base
  of PID 1359:

    crash&gt; vtop c806e000
    VIRTUAL   PHYSICAL
    c806e000  2216000
    
    PAGE DIRECTORY: c0101000
      PGD: c0101c80 =&gt; 94063
      PMD: c0101c80 =&gt; 94063
      PTE: c00941b8 =&gt; 2216063
     PAGE: 2216000
 
      PTE    PHYSICAL  FLAGS
    2216063   2216000  (PRESENT|RW|ACCESSED|DIRTY)
    
      PAGE    PHYSICAL   INODE     OFFSET  CNT FLAGS
    c02e9370   2216000         0         0  1  
    
    crash&gt; vtop -c 1359 c806e000
    VIRTUAL   PHYSICAL
    c806e000  2216000
    
    PAGE DIRECTORY: c5caf000
      PGD: c5cafc80 =&gt; 94063
      PMD: c5cafc80 =&gt; 94063
      PTE: c00941b8 =&gt; 2216063
     PAGE: 2216000
    
      PTE    PHYSICAL  FLAGS
    2216063   2216000  (PRESENT|RW|ACCESSED|DIRTY)
 
      PAGE    PHYSICAL   INODE     OFFSET  CNT FLAGS
    c02e9370   2216000         0         0  1  
    
  Determine swap location of user virtual address 40104000:

    crash&gt; vtop 40104000
    VIRTUAL   PHYSICAL
    40104000  (not mapped)
    
    PAGE DIRECTORY: c40d8000
      PGD: c40d8400 =&gt; 6bbe067
      PMD: c40d8400 =&gt; 6bbe067
      PTE: c6bbe410 =&gt; 58bc00  
 
     PTE      SWAP     OFFSET
    58bc00  /dev/sda8   22716
    
      VMA      START      END     FLAGS  FILE
    c7200ae0  40104000  40b08000    73   
 
    SWAP: /dev/sda8  OFFSET: 22716
</pre>

<h3 id="toc_0.0.44">waitq</h3>
<pre>
NAME
  waitq - list tasks queued on a wait queue

SYNOPSIS
  waitq  [ symbol ] | [ struct.member struct_addr ] | [ address ]

DESCRIPTION
  This command walks the wait queue list displaying the tasks which 
  are blocked on the specified wait queue.  The command differentiates
  between the old- and new-style wait queue structures used by the kernel.
  It can be invoked with the following argument types:
 
                     symbol  a global symbol of a wait queue.
  struct.member struct_addr  a structure name and wait queue member combination
                             followed by the structure's hexadecimal address.
                    address  a hexadecimal wait queue pointer.

EXAMPLES

  Find out if any tasks are blocked on the "buffer_wait" wait queue:

    crash&gt; waitq buffer_wait
    wait queue "buffer_wait" (c02927f0) is empty
 
  See who is blocked on the "wait_chldexit" queue of task c5496000:

    crash&gt; waitq task_struct.wait_chldexit c5496000
    PID: 30879  TASK: c5496000  CPU: 0   COMMAND: "bash"
 
  Display the task list waiting on a known task queue:

    crash&gt; waitq c3534098
    PID: 13691  TASK: c3534000  CPU: 1   COMMAND: "bash"
</pre>

<h3 id="toc_0.0.45">whatis</h3>
<pre>
NAME
  whatis - search symbol table for data or type information

SYNOPSIS
  whatis [struct | union | typedef | symbol] 

DESCRIPTION
  This command displays the definition of structures, unions, typedefs or
  text/data symbols.

    struct  a structure name. The output is the same as if the "struct"
            command was used.
     union  a union name. The output is the same as if the "union" command
            was used.
   typedef  a typedef name. If the typedef translates to a structure or union
            the output is the same as if the "struct" or "union" command
            was used. If the typedef is a primitive datatype, the one-line
            declaration is displayed.
    symbol  a kernel symbol.  

EXAMPLES
   Display the definition of a linux_binfmt structure:

    crash&gt; whatis linux_binfmt
    struct linux_binfmt {
      struct linux_binfmt  *next;
      struct module  *module;
      int (*load_binary) ();
      int (*load_shlib) ();
      int (*core_dump) ();
    };
    
  Since a kmem_bufctl_t is typedef'd to be a kmem_bufctl_s structure, the
  output of the following two commands is identical:

    crash&gt; whatis kmem_bufctl_s
    struct kmem_bufctl_s {
      union {
        struct kmem_bufctl_s  *buf_nextp;
        kmem_slab_t *buf_slabp;
        void *buf_objp;
      } u;
    };
    
    crash&gt; whatis kmem_bufctl_t
    struct kmem_bufctl_s {
      union {
        struct kmem_bufctl_s *buf_nextp;
        kmem_slab_t *buf_slabp;
        void *buf_objp;
      } u;
    };
    SIZE: 4  (0x4)
    
  Display the type data of sys_read() and jiffies text and data symbols:

    crash&gt; whatis sys_read
    ssize_t sys_read(unsigned int, char *, size_t);
 
    crash&gt; whatis jiffies
    long unsigned int jiffies;

  Display definition of a kdev_t typedef:

    crash&gt; whatis kdev_t
    typedef short unsigned int kdev_t;
    SIZE: 2  (0x2)
</pre>

<h3 id="toc_0.0.46">wr</h3>
<pre>
NAME
  wr - write memory

SYNOPSIS
  wr [-u|-k|-p] [-8|-16|-32|-64] [address|symbol] value

DESCRIPTION
  This command modifies the contents of memory.  The starting address may be
  entered either symbolically or by address.  The default modification size 
  is the size of a long data type.  Write permission must exist on the
  /dev/mem.  When writing to memory on a live system, this command should 
  obviously be used with great care.

       -u  address argument is a user virtual address.
       -k  address argument is a kernel virtual address.
       -p  address argument is a physical address.
       -8  write data in an 8-bit value.
      -16  write data in a 16-bit value.
      -32  write data in a 32-bit values (default on 32-bit machines).
      -64  write data in a 64-bit values (default on 64-bit machines).
  address  address to write.  The address is considered virtual unless the
           -p option is used.  If a virtual address is specified, the
           -u or -k options are necessary only if the address space cannot
           be determined from the address value itself.  If a user virtual
           address is specified, the address space of the current context
           implied.  The address must be expressed in hexadecimal format.
   symbol  symbol of starting address to write.
    value  the value of the data to write.

EXAMPLES
  Turn on a debug flag:

    crash&gt; wr my_debug_flag 1
</pre>

</body>
</html>
