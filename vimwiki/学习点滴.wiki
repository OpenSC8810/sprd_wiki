----
=== 抓log命令 ===
{{{
makesure all log output：
	adb shell slogctl off
kernel log:
	adb shell cat /proc/kmsg | tee kernel.txt
user log:
	adb shell logcat -v time | tee user.txt
kernel log level:
        cat /proc/sys/kernel/printk
        可以修改这里面的值
}}}

=== push到system/bin下 ===
{{{
adb root
adb remount
adb push xxx system/bin
}}}

=== CP－AP交互 ===
{{{
以下是7710发送AT命令的行走路径：
工具 => pcclient => engservice => modemclient => phoneserver => MUX(AP) => MUX(CP) => CP侧处理

AP侧相关文件：
MUX： kernel/drivers/char/ts0710_mux.c   ==>  ts0710_recv_data
phoneserver: /vendor/sprd/proprietories-source/phoneserver
modemclient: /device/sprd/common/apps/engineeringmodel/engcs/eng_modemclient.c
pcclient: /device/sprd/common/apps/engineeringmodel/engcs/eng_pcclient.c
engserver: /device/sprd/common/apps/engineeringmodel/engcs/engservice.c

CP侧相关文件：
MUX: PS/atc/source/c/atc_mux.c     ==>  ATC_Write
     PS/stack/was/wdt_mgr\wdt_mux\src\data_mga_sdio_carrier_dl.c    ==>  DTMGR_Do_Sido_transfer
}}}

=== eng_modemclient.c ===
{{{
/device/sprd/common/apps/engineeringmodel/engcs/eng_modemclient.c
eng_modem2server  从phonserver读取内容
其中一个是从"/dev/CHNPTYT13"读取内容，该通道在engclient.h里定义
}}}

=== logcat -b radio ===
{{{
查看ril相关的打印
}}}

----
=== sprdroid4.3 open ===
{{{
如果open以O_CREAT方式找开，后面需要加权限，如0660
}}}

=== samsung kernel base ===
{{{
http://wikiserver.spreadtrum.com/Projects/SoftwareSystem/wiki/cai_20130807_logan_tw_make_boot
}}}

----
=== LCD分频计算方式 ===
{{{
原始频率为384M，dpi使用时需要分频
假设需要的帧率为fps，则1s传输的像素为(hsync+hbp+hfp+width)*(vsync+vbp+vfp+height)*fps
分频比dividor=384M/((hsync+hbp+hfp+width)*(vsync+vbp+vfp+height)*fps)
信息都在lcd_xxx.c里定义
}}}

----
=== lookat命令 ===
{{{
查看内存、寄存器的内容，如
lookat -l2 0x20900220
-l2：显示的个数
0x20900220：地址
}}}

=== LCD寄存器 ===
{{{
0x20900220 ： 分频值
0x21000000 - 0x21000110 ： DISPC寄存器
0x60100000 - 0x60100070 ： DSI寄存器
}}}

----
=== 编译器对齐问题 ===
{{{
现有数据结构如下
typedef struct bmp_header {
	/* Header */
	char signature[2];
	__u32	file_size;
	__u32	reserved;
	__u32	data_offset;
	/* InfoHeader */
	__u32	size;
	__u32	width;
	__u32	height;
	__u16	planes;
	__u16	bit_count;
	__u32	compression;
	__u32	image_size;
	__u32	x_pixels_per_m;
	__u32	y_pixels_per_m;
	__u32	colors_used;
	__u32	colors_important;
	/* ColorTable */

} __attribute__ ((packed)) bmp_header_t;

typedef struct bmp_image {
	bmp_header_t header;
	/* We use a zero sized array just as a placeholder for variable
	   sized array */
	bmp_color_table_entry_t color_table[0];
} bmp_image_t;

这是lcd.c里lcd_display_bitmap出错的代码
	width = le32_to_cpu (bmp->header.width);

以下是在4.1环境下的反汇编代码
8f80bbe0:	e5d02013 	ldrb	r2, [r0, #19]
8f80bbe4:	e3a04001 	mov	r4, #1	; 0x1
8f80bbe8:	e5d01012 	ldrb	r1, [r0, #18]
8f80bbec:	e5d0a017 	ldrb	sl, [r0, #23]
8f80bbf0:	e5dc5004 	ldrb	r5, [ip, #4]
8f80bbf4:	e1811402 	orr	r1, r1, r2, lsl #8
其中r0为数据结构bmp_image_t的地址

以下是4.3的反汇编代码
8f80b87c:	e5935012 	ldr	r5, [r3, #18]
其中r3为数据结构bmp_image_t的地址
可见，ldr取的是非4字节对齐地址，alignment出错

然后进行一些测试，发现用4.7编译器时，如果加上-march=armv7-a这个编译选项时，就不会进行优化
}}}

=== android工具链 ===
{{{
4.1版本：
/prebuilt/linux-x86/toolchain/arm-eabi-4.4.3/bin/
 
4.3版本：
/prebuilts/gcc/linux-x86/arm/arm-eabi-4.7/bin
 
反编译，要用上面对应的工具链进行，
反编译u-boot，可以用arm-eabi-objdump -D u-boot
}}}

=== git更新仓库 ===
{{{
git pull
}}}

=== 抓取LCD framebuffer内容 ===
{{{
adb shell gsnap /data/1.jpg /dev/graphics/fb0
}}}

----
=== add board ===
{{{
http://wikiserver.spreadtrum.com/SoftwareSystem/wiki/add_board-renwei-4%E6%9C%887
}}}

=== 调试工具和方法汇总 ===
{{{
http://wikiserver.spreadtrum.com/Projects/SoftwareSystem/wiki/mengya_130423_debug
}}}

----
=== service list ===
{{{
列举手机启动的服务
}}}

=== getprop xxx ===
{{{
获取某个属性值
}}}

=== FPGA启动 ===
{{{
1、开电源
2、下载ap和cp端的bitfile。下载完时，会亮各自的灯
3、按reset键
4、开trace32，运行AP脚本，如果要切到CP，刚运行CP的脚本
}}}

=== gpio配置 ===
{{{
http://10.0.64.31/AP-Android/wiki/PinGpioUserGuide
}}}

=== board配置 ===
{{{
u-boot: http://review.source.spreadtrum.com/gerrit/#/c/70198/
device: http://review.source.spreadtrum.com/gerrit/#/c/70197/
kernel: http://review.source.spreadtrum.com/gerrit/#/c/70200/
vendor: http://review.source.spreadtrum.com/gerrit/#/c/70195/
}}}

=== 服务器 ===
{{{
http://wikiserver.spreadtrum.com/Projects/SoftwareSystem/wiki/B2G%E9%A1%B9%E7%9B%AE%E5%8F%AF%E5%88%A9%E7%94%A8%E7%9A%84%E8%B5%84%E6%BA%90
ssh huafang@10.0.0.180
服务器端的目录被挂载在~/server上
}}}

----
=== 文档 ===
{{{
git clone gitosis@sprdroid.git.spreadtrum.com.cn:doc
}}}

=== repo升级 ===
{{{
http://10.0.64.31/AP-Android/wiki/UpdateRepoNew
}}}

----
=== fastboot ===
{{{
1. sudo adb reboot bootloader
2. sudo fastboot flash <partition> <image>
3. sudo fastboot reboot
可参考 http://10.0.64.31/AP-Android/wiki/How%20to%20use%20Android%20fastboot%20tool
}}}

=== slogctl ===
{{{
slogctl off，将slog关闭，否则kmsg显示不正常
}}}

----
=== 更新某个仓库 ===
{{{
1. repo sync
repo sync framework/base
该命令可以在任意目录
2. git pull
git pull korg sprdroid4.1
该命令必须在仓库所在的目录
korg可以在.git/config里查remote标签，sprdroid4.1可以在manifest.xml里查
或者git branch -a里的信息
}}}

----
=== 如何编译三星的kernel ===
{{{
http://wikiserver.spreadtrum.com/Projects/SoftwareSystem/wiki/samsung%20kernel%20build
}}}

----
=== defconfig文件 ===
{{{
生成defconfig：kdconfig => kuconfig
生成临时的defconfig文件:kmconfig
}}}

----
=== 列出指定后缀的文件列表 ===
{{{
在源代码的根目录下执行以下命令
find . -wholename ./out -prune -o -wholename ./.repo -prune -o -type f -regextype posix-extended -iregex ".*\.(h|c|cpp|java|mk|cc)$" -o -type f -iname "makefile" > filelist.txt
说明：
排除./out和.repo这两个目录
查找以.h/c/cpp/java/mk/cc为后缀，或是makefile文件
}}}

----
=== 内核代码规范 ===
{{{
http://10.0.64.31/AP-Android/wiki/LinuxProgrammingDesignGuide
}}}

=== Linux Device Driver ===
{{{
http://10.0.64.31/AP-Android/wiki/Device%20driver
}}}

=== Linux 3.10 ===
{{{
http://kernelnewbies.org/Linux_3.10
http://kernelnewbies.org/Linux_3.10-DriversArch
}}}

----
=== linux mount上海 外传内共享目录的方法 ===
{{{
sudo mount -t cifs -o username=你的用户名,password=你的密码,domain=tsn,uid=$(id -u),gid=$(id -g) //10.0.0.165/To_Internal ~/to_internal
}}}

=== 服务器 ===
{{{
http://wikiserver.spreadtrum.com/Projects/SoftwareSystem/wiki/mengya_110810_visit_win
}}}

----
=== OpenGrok ===
{{{
天津  http://10.5.2.45:8080/
我的  http://10.0.33.7:8080/source
}}}

----
=== 客户版本发布 ===
{{{
http://10.0.64.31/AP-Android/wiki/MocorSmartReleaseNotes
}}}

----
=== 用BeyondCompare做差分包 ===
{{{
BeyondCompare对比两个目录，列出所有不一样的文件
选择所要做差分包的文件，右击鼠标，选择"Copy to Folder"
分别对old和new目录做一次，就可以生成差分包
}}}

----
=== 连接服务器 ===
{{{
ssh本机：
ssh spreadtrum\\hua.fang@10.0.33.5

挂载远程机器目录到本地：
sshfs -o allow_other huafang@10.0.0.180:/home3/huafang ~/server_ss

挂载远程机器硬盘到本地：
sudo mount -t cifs -o username=hua.fang,password=12abAB,uid=$(id -u),gid=$(id -g) //10.0.0.165/thinclient ~/net_folder/n_folder
}}}

----
=== 切换到tag ===
{{{
repo forall -c "git checkout <TAG_name>"
}}}

----
=== 修改CP基址和大小 ===
{{{
u-boot部分：
****  include/configs/sp8830ssw.h  ****
#define FIXNV_SIZE            (2*128 * 1024)
#define PRODUCTINFO_SIZE      (16 * 1024)
#define MODEM_SIZE            (0x800000)
#define TDDSP_SIZE            (0x2e0000)
#define WDSP_SIZE             (0x200000)
#define RUNTIMENV_SIZE        (3*128 * 1024)

#define PHYS_OFFSET_ADDR              0x80000000
#define TD_CP_OFFSET_ADDR             0x8000000      /*128*/
#define TD_CP_SDRAM_SIZE              0x2100000      /*33M*/
#define WCDMA_CP_OFFSET_ADDR          0x8000000      /*128M*/
#define WCDMA_CP_SDRAM_SIZE           0x2100000      /*33M*/
//#define WCN_CP_OFFSET_ADDR          0x14000000     /*320M*/
//#define WCN_CP_SDRAM_SIZE           0x400000       /*4M*/
****************************************

****  property/normal_mode.h  ****
#define TDDSP_ADR       0x88020000
#define TDFIXNV_ADR     0x88340000
#define TDRUNTIMENV_ADR 0x88380000
#define TDMODEM_ADR     0x88400000
#define WDSP_ADR        0x88020000
#define WFIXNV_ADR      0x88240000
#define WRUNTIMENV_ADR  0x88280000
#define WMODEM_ADR      0x88300000
****************************************

kernel部分：
****  arch/arm/mach-sc/include/mach/__hardware-sc8830.h  ****
#define SIPC_SMEM_ADDR        (CONFIG_PHYS_OFFSET + 120 * SZ_1M)

#define CPT_START_ADDR        (CONFIG_PHYS_OFFSET + 128 * SZ_1M)
#define CPT_TOTAL_SIZE        (SZ_1M * 33) 
#define CPT_RING_ADDR         (CPT_START_ADDR + CPT_TOTAL_SIZE - SZ_4K)
#define CPT_RING_SIZE         (SZ_4K)
#define CPT_SMEM_SIZE         (SZ_1M + SZ_256K)

#define CPW_START_ADDR        (CONFIG_PHYS_OFFSET + 128 * SZ_1M)
#define CPW_TOTAL_SIZE        (SZ_1M * 33) 
#define CPW_RING_ADDR         (CPW_START_ADDR + CPW_TOTAL_SIZE - SZ_4K)
#define CPW_RING_SIZE         (SZ_4K)
#define CPW_SMEM_SIZE         (SZ_1M + SZ_256K)

#define WCN_START_ADDR        (CONFIG_PHYS_OFFSET + 320 * SZ_1M)
#define WCN_TOTAL_SIZE        0x281000//(SZ_1M * 5)
#define WCN_RING_ADDR         (WCN_START_ADDR + WCN_TOTAL_SIZE - SZ_4K)
#define WCN_RING_SIZE         (SZ_4K)
#define WCN_SMEM_SIZE         (SZ_512K + SZ_256K)
****************************************

****  arch/arm/mach-sc/devices-sc8830.c  ****
static int native_tdmodem_start(void *arg)
{
      u32 state;
      u32 value;
      u32 cp1data[3] = {0xe59f0000, 0xe12fff10, CPT_START_ADDR + 0x400000};
      memcpy((void *)(SPRD_IRAM1_BASE + 0x1800), cp1data, sizeof(cp1data));
....
}

static struct cproc_init_data sprd_cproc_td_pdata = {
	       .devname      = "cpt",
	       .base         = CPT_START_ADDR,
	       .maxsz        = CPT_TOTAL_SIZE,
	       .start        = native_tdmodem_start,
	       .stop         = native_tdmodem_stop,
	       .wdtirq               = IRQ_CP1_WDG_INT,
	       .segnr        = 4,
	       .segs         = {
	              {
	                     .name  = "modem",
	                     .base  = CPT_START_ADDR + 0x400000,
	                     .maxsz = 0x00800000,
	              },
	              {
	                     .name  = "dsp",
	                     .base  = CPT_START_ADDR + 0x20000,
	                     .maxsz = 0x002E0000,
	              },
	              {
	                     .name  = "fixnv",
	                     .base  = CPT_START_ADDR + 0x340000,
	                     .maxsz = 0x40000,
	              },
	              {
	                     .name  = "runtimenv",
	                     .base  = CPT_START_ADDR + 0x380000,
	                     .maxsz = 0x60000,
	              },
	       },
};
****************************************
}}}

----
=== 拉分支 ===
{{{
给summer.duan发邮件，让她拉分支。
分支信息：
1) 开发分支名称：
2）开发分支从哪个分支拉出：
3) 开发分支起始点： 
4）开发分支功能描述：
5）开发分支项目Lead：
6）开发分支生命周期：
7）开发分支验收标准：
}}}

----
=== DS-5 ===
{{{
http://wikiserver.spreadtrum.com/Projects/SoftwareSystem/wiki/%E4%BD%BF%E7%94%A8DS-5%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7
http://10.0.64.31/AP-Android/attachment/wiki/DebugTools/DS-5%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA.odt
}}}

----
=== SS SDK git ===
{{{
repo init -b Samsung_Kernel_Base -u gitosis@10.0.0.160:SSKernel/manifest.git --repo-url=gitosis@10.0.0.160:tools/newrepo.git
}}}

----
=== 烧image ===
{{{
1. 从手机里提取image
手机里运行命令
dd if=/dev/block/platform/sprd-sdhci.3/by-name/KERNEL of=/data/temp.img
再adb pull /data/temp.img .

2. 往手机里烧image
运行命令
adb push xxx/boot.img /data
手机里运行
dd if=/data/boot.img of=/dev/block/platform/sprd-sdhci.3/by-name/KERNEL
}}}

----
=== 通过adb发AT命令 ===
{{{
1. 找到对应的SIPC通道，
在vendor/sprd/open-source/apps/engmode/eng_pcclient.c的at_chan变量里找
static void eng_get_modem_int(char* type, char* at_chan, char* diag_chan, char* log_chan)
{
    char property_name[32] = {0};

    sprintf(property_name,"%s%s%s","ro.modem.",type,".tty");
    property_get(property_name, at_chan, "not_find");
    ENG_LOG("%s %s at_chan:%s", __FUNCTION__,property_name,at_chan);

    if(strcmp(type,"wcn") != 0 && 0 != strcmp(at_chan, "not_find")){
        strcat(at_chan, "31"); // channel31 is reserved for eng at
    }   
}
ro.modem.type.tty定义在device/sprd/scx35l_coreprimelite/system.prop里
ro.modem.tl.tty=/dev/stty_lte
2. 发AT命令
监听回应：cat /dev/stty_lte31 &
发AT命令：echo "AT\r" > /dev/stty_lte31
}}}


----
=== sysdump搜log ===
{{{
strings sysdump.core.01_0x80000000-0x87ffffff_dump.lst > a.txt
搜索"Modules linked"，上下就是sysdump时的打印
}}}

----
=== samsung doc ===
{{{
\\hw06\HW_Doc\2 Function\10 T1\SAMSUNG
}}}

----
=== 公共盘 ===
{{{
\\shnas2\Dept_Folder\FPD          ----用来存放临时文件及log等，记得经常清空
P:\PLD\Samsung                    ----用来存放项目相关的文档、patch、binary、Tools等
}}}

----
=== light sleep ===
{{{
echo any_wake_lock > /sys/power/wake_lock
然后等灭屏后，电流大约到20mA左右就说明进入light sleep

echo 1 > /sys/module/cpuidle_scx35/parameters/cpuidle_debug
可打开light sleep调试信息
}}}

----
=== CSFB多形态命名方案建议 ===
{{{
总体命名：CCD5
 
约定：
第1位：CSFB类多形态业务
第2位：所对应的运营商（CMCC（中移）, CUCC（联通）, Oversea（海外），Public（公开市场）……)
第3位：所采用卡/待数（Single, dual, triple…）
第4位：所采用mode数（3mode, 4mode, 5mode…）
第5/6位：补充定义说明（特定模定义/双通定义/Volte定义等（顺序为TDD，FDD,  Active，Volte，RCS，默认为第5补充位，若有歧义按此顺序加第6位补充）
 
含义范例：CSFB for CMCC(or CUCC/Oversea) + Dual Sim (or Single Sim)+ 5mode（or 3/4mode）+ Active（双通，若无A则默认为单通）
 
扩展示例：
CCS3  （针对单卡，Single sim， 3mode；）
CCD3F （3mode默认是TDD 3mode；针对FDD 3mode，第5位加F；单卡同 ）
CUD4 （针对CUCC  4模）
CCD5A （5mode双通）
CCD5V （增加Volte支持）
COD4   (针对海外运营商)
CPD3   (针对公开市场3mode)
……
}}}

----
=== Power Management ===
[[http://10.0.64.31/AP-Android/wiki/Power%20Management|Power Management]]

=== 快速编译 ===
[[http://wikiserver.spreadtrum.com/Projects/SoftwareSystem/wiki/%E5%B7%A5%E7%A8%8B%E5%BF%AB%E9%80%9F%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC|快速编译]]</BR>
[[local:files/build.patch|不用搜所有Android.mk的patch]]

----
=== parse log ===
[[http://10.0.64.31/AP-Android/wiki/parse_log|parse log]]</BR>
[[http://10.0.64.31/AP-Android/wiki/DebugTools|debug tools]]

----
=== WIKI format ===
[[http://wikiserver.spreadtrum.com/Projects/SoftwareSystem/wiki/WikiFormatting|WikiFormat]]

----
=== cp log ===
{{{
GED cp LOG：
*#*#83781#*#*打开debug页面，将arm log的开关打开
插入usb口，打开logel、channel server工具，选uart

如果用uart输出，需要配置cp代码，将口设为com1
}}}

----
=== modify modem size ===
[[http://bugzilla.spreadtrum.com/bugzilla/show_bug.cgi?id=354198|modify modem size sample]]

----
=== 芯片失效分析手段 ===
{{{
降频：
ddr频率降为200m
cpu频率降为600m

升压：
vddarm：1.2v
vddcore：1.2v

关DVFS
关DFS
关cpu core
}}}

----
=== 各sdhci涵义 ===
{{{
sdhci0: t卡
sdhci1: wifi
sdhci2: 缺省
sdhci3: emmc
}}}

----
=== 校准模式mount sdcard，打开adb，抓slog ===
{{{
on cali
    mount_all /etc/recovery.fstab
#   start recovery
    start slog
    trigger adb_enable

service slog /system/bin/slog -t
    class main
    user root

由于校准模式时，engpc会占用diag口，slog工具无法使用，所以cp的log会不抓取
}}}

=== sdb安装及使用 ===
{{{
http://wikiserver.spreadtrum.com/Projects/SoftwareSystem/wiki/sdb%E5%AE%89%E8%A3%85%E4%B8%8E%E4%BD%BF%E7%94%A8
}}}

----
=== cp reset ===
{{{
1.ap patch：
http://review.source.spreadtrum.com/gerrit/#/c/147209/
http://review.source.spreadtrum.com/gerrit/#/c/147208/

2.cp patch：
bug里面有：
http://bugzilla.spreadtrum.com/bugzilla/show_bug.cgi?id=367641

里面有个提交：
Comment 31 cmadmin 2014-11-19 11:11:16 CST
}}}

----
=== 关闭kernel console ===
{{{
一般，u-boot传给kernel的cmd是console=ttyS1,115200n8 no_console_suspend
可以配成console=null，将console关闭
}}}

=== 配置bus monitor ===
{{{
以下是AHB的bus monitor的配置
+       {
+               uint32 addr[] = {
+                       0x20f00000,
+                       0x21000000,
+                       0x21100000
+               };
+
+               int i = 0;
+
+               REG32(0x20e00000) |= (7<<14);
+
+               for (i = 0; i < 3; i++) {
+                       REG32(addr[i]) = 0;                         // 启动状态
+                       REG32(addr[i]+4) = 0;
+                       REG32(addr[i]+8) = 0x80000000;              // 监测的最小地址
+                       REG32(addr[i]+0xc) = 0xa0000000;            // 监测的最大地址
+                       REG32(addr[i]+0x10) = 0;
+                       REG32(addr[i]+0x14) = 0;
+                       REG32(addr[i]+0x18) = 0;                    // 监测的最小值
+                       REG32(addr[i]+0x1c) = 0xffffffff;           // 监测的最大值
+                       REG32(addr[i]+0x20) = 0;
+                       REG32(addr[i]+0x24) = 0;
+                       REG32(addr[i]+0x28) = 0;
+                       REG32(addr[i]+0x2c) = 0;
+                       REG32(addr[i]+0x30) = 0;
+                       REG32(addr[i]+0x34) = 0;
+                       REG32(addr[i]) = 0x1;
+
+               }
+       }
将REG32(addr[i])配成0x20000000，将bus monitor状态清除
}}}

=== reserve memory调试 ===
{{{
代码：kernel/mm/memblock.c
打开配置形状：CONFIG_MEMBLOCK_RESERVE_DEBUG

或者，
diff --git a/mm/memblock.c b/mm/memblock.c
index e178a33..7a762d7 100644
--- a/mm/memblock.c
+++ b/mm/memblock.c
@@ -35,7 +35,7 @@ struct memblock memblock __initdata_memblock = {
        .current_limit          = MEMBLOCK_ALLOC_ANYWHERE,
 };
 
-int memblock_debug __initdata_memblock;
+int memblock_debug __initdata_memblock = 1;
 static int memblock_can_resize __initdata_memblock;
 static int memblock_memory_in_slab __initdata_memblock = 0;
 static int memblock_reserved_in_slab __initdata_memblock = 0;
@@ -555,11 +555,13 @@ int __init_memblock memblock_reserve(phys_addr_t base, phys_addr_t size)
 {
        struct memblock_type *_rgn = &memblock.reserved;
 
+printk("~~~~~~~~~~~~\n");
        memblock_dbg("memblock_reserve: [%#016llx-%#016llx] %pF\n",
                     (unsigned long long)base,
                     (unsigned long long)base + size,
                     (void *)_RET_IP_);
 
+dump_stack();
        return memblock_add_region(_rgn, base, size, MAX_NUMNODES);
 }
 #else
}}}

=== u-boot printf ===
{{{
u-boot/common/console.c
}}}

----
=== DDR频点 ===
{{{
lpddr2支持：    200 384 400 466
lpddr3支持：192 200 384 400 500 640
}}}

----
=== Power Management ===
{{{
http://10.0.64.31/AP-Android/wiki/Power%20Management
}}}

----
=== 打印64位数 ===
{{{
printk("%llu", u64);
printk("%lld", l64);
}}}

=== interactive调频过多 ===
{{{
换成interactive的governor，打开kernel log后，CPU调频速度过快，可以减少采样率来规避此问题
echo 100000 > /sys/devices/system/cpu/cpufreq/interactive/timer_rate
}}}

=== RTC/alarm ===
{{{
硬件上只有一个RTC，最后一次的设置时间会最终生效（kernel/drivers/rtc/rtc-sprd.c）
alarm驱动会调用RTC，该驱动有一个队列，可以保证存在多个alarm，将最快到达的时间设置给RTC（kernel/kernel/time/alarmtimer.c，在set_real_alarm里）
ktime_to_ms将ktime结构转换成ms
参考资料：http://www.embedu.org/Column/Column468.htm
}}}

----
=== 校准模式下保存armlog到t卡 ===
{{{
device/sprd/scx35/recovery/init.rc

on property:ro.bootmode=cali
   setprop ro.config.engcplog.enable 1
}}}

----
=== check current ddr freq ===
{{{
adb shell cat /d/clk/clk_summary | grep clk_emc?

get the value and divide by 2

e.g,
$ adb shell cat /d/clk/clk_summary | grep clk_emc
       clk_emc                  0           0            768000000 

then the current ddr frequence is 384M
}}}

----
=== 寄存器虚拟地址映射 ===
{{{
调用地址映射的接口：
290 MACHINE_START(SCPHONE, "sc8830")
293     .map_io     = sci_map_io,            // 这个接口
300 MACHINE_END

实现映射接口的文件：
kernel/arch/arm/mach-sc/io-sc8830.c

183 void __init sci_map_io(void)
184 {
185     iotable_init(sprd_io_desc, ARRAY_SIZE(sprd_io_desc));
186     sc_init_chip_id();
187 }   

这个io数组：
 39 static struct map_desc sprd_io_desc[] __initdata = {
 40     SPRD_DEVICE(CORE),
 41     SPRD_DEVICE(MDAR),
180 };  

这些地址定义的地方：kernel/arch/arm/mach-sc/include/mach/__hardware-sc9630.h

 40 #define SPRD_CORE_BASE          SCI_IOMAP(0x10000)
 41 #define SPRD_CORE_PHYS          0x12000000
 42 #define SPRD_CORE_SIZE          SZ_64K
}}}

----
=== DCXO/TCXO/VC-TCXO ===
{{{
精准度：DCXO < TCXO < VC-TCXO

DCXO:
就是一个二氧化硅的晶体，外面会有电容电阻组成的振荡电路，精准度是最差的
TCXO:
将振荡电路封装在芯片内部
VC-TCXO:
高精度的振荡器，但对温度相对敏感
}}}

----
=== cpu升频升压 ===
{{{
cpu每档都有对应的vddarm电压值
现在每次步进为250mv，每档所需的时间大概在10ms左右

如下，从1.2g到768m，需要大概40ms左右
[  334.175262] c0 cpufreq_scx35: --xing-- set 768000 khz for cpu0
[  334.181274] c0 regu: @@@dcdc_set_voltage: regu 0xdf328128 (vddarm) 975000 = 900000 +75000uV(trim 0x18)
[  334.190582] c0 regu: @@@dcdc_set_voltage: regu 0xdf328128 (vddarm) 950000 = 900000 +50000uV(trim 0x10)
[  334.199890] c0 regu: @@@dcdc_set_voltage: regu 0xdf328128 (vddarm) 925000 = 900000 +25000uV(trim 0x8)
[  334.209106] c0 regu: @@@dcdc_set_voltage: regu 0xdf328128 (vddarm) 900000 = 900000 +0uV(trim 0x0)
[  334.217987] c0 cpufreq_scx35: 1200000 --> 768000, real=768000, index=2
}}}

----
=== 截取文件内容命令/提取cp的内存 ===
{{{
dd if=sysdump.core.01_0x80000000-0xafffffff_dump.lst of=temp.mem bs=1048576 skip=150 count=64
- bs: 读写单位
- skip: 跳过多少单位
- count: 读多少单位

步骤：
1、7s reset将DDR里的内容dump到T卡（注：7s reset dump出来的文件只有一个，文件名为sysdump.core.01_0x80000000-0xafffffff_dump.lst）
2、将dump出来的文件拷到某文件夹下
3、进入控制台，cd命令切到该目录
4、运行如下命令，会在同目录下生成cp.mem
dd if=sysdump.core.01_0x80000000-0xafffffff_dump.lst of=cp.mem bs=1048576 skip=150 count=64
}}}

----
=== getevent ===
{{{
获取input event列表：getevent命令， getevent -lt /dev/input/event1可看到event1里的相关信息
}}}

----
=== 模拟重启modem ===
{{{
setprop persist.sys.sprd.modemreset 1
echo "AT+SPATASSERT=1\r" > /dev/stty_lte31
}}}

----
=== 屏幕横竖屏设置 ===
{{{
device/sprd/scx35_tsharkgoyave/system.prop

 # SPRD: add support hwrotation
 ro.sf.hwrotation=270
}}}

----
=== 校准模式下抓armlog ===
{{{
=== device/sprd/scx35/recovery/init.rc ===
on property:ro.bootmode=cali
   setprop ro.config.engcplog.enable 0
==>
on property:ro.bootmode=cali
   setprop ro.config.engcplog.enable 1

=== device/sprd/scx35l_coreprimelite/init.recovery.board.rc ===
#on cali
#       mount_all /etc/recovery.fstab
#       start recovery
#       start slog
#       trigger adb_enable
==>
on cali
       mount_all /etc/recovery.fstab
#       start recovery
#       start slog
#       trigger adb_enable
}}}

=== 看adc通道的值 ===
{{{
lookat -s 0x1 0x40038304 && lookat -s 0x17 0x40038300 && lookat -l25 0x40038300

lookat -s 0x1 0x40038304：
设置adc通道，及大小量程

lookat -s 0x17 0x40038300：
使能adc

lookat -l25 0x40038300：
看adc值，主要看0x4003834c的值
}}}

=== sharkl查看arm7的log ===
{{{
将串口切给arm7
lookat -s 0x285580 0x402a0008
}}}

----
=== 看light sleep的log ===
{{{
./sys/module/cpuidle_scx35/parameters/cpuidle_debug
}}}

----
=== a-die chip id ===
{{{
chipid由两部分组成：ANA_REG_GLB_CHIP_ID_HIGH/ANA_REG_GLB_CHIP_ID_LOW
ANA_REG_GLB_CHIP_ID_HIGH的16位再加上ANA_REG_GLB_CHIP_ID_LOW的高4位，组成chip id
ANA_REG_GLB_CHIP_ID_LOW的低12位为版本号

拿chipid的代码在kernel/arch/arm/mach-sc/arch_misc.c
sci_get_ana_chip_id/sci_get_ana_chip_ver
}}}

----
=== WPA ===
{{{
WPA这路电由ps来控制，在ldo_sleep.c里，不能配置成sleep power down，否则dsp会有问题
}}}

----
=== vi显示^M ===
{{{
用命令打开文件
:e ++ff=unix <file_name>

set fileformats=unix设置为unix格式
}}}

----
=== enable engpc ===
{{{
persist.sys.engpc.disable : 控制engpc的开关

工程模式里，需要去掉slog里所有的选项，然后才能使能engservice
}}}

----
=== 开启/关闭服务 ===
{{{
c代码：
property_set("ctl.start", "engpc");
property_set("ctl.stop", "engpc");

adb shell:
setprop ctl.start engpc
setprop ctl.stop engpc
}}}

=== kernel error code ===
{{{
kernel/include/uapi/asm-generic/errno-base.h

4#define	EPERM		 1	/* Operation not permitted */
5#define	ENOENT		 2	/* No such file or directory */
6#define	ESRCH		 3	/* No such process */
7#define	EINTR		 4	/* Interrupted system call */
8#define	EIO		 5	/* I/O error */
9#define	ENXIO		 6	/* No such device or address */
10#define	E2BIG		 7	/* Argument list too long */
11#define	ENOEXEC		 8	/* Exec format error */
12#define	EBADF		 9	/* Bad file number */
13#define	ECHILD		10	/* No child processes */
14#define	EAGAIN		11	/* Try again */
15#define	ENOMEM		12	/* Out of memory */
16#define	EACCES		13	/* Permission denied */
17#define	EFAULT		14	/* Bad address */
18#define	ENOTBLK		15	/* Block device required */
19#define	EBUSY		16	/* Device or resource busy */
20#define	EEXIST		17	/* File exists */
21#define	EXDEV		18	/* Cross-device link */
22#define	ENODEV		19	/* No such device */
23#define	ENOTDIR		20	/* Not a directory */
24#define	EISDIR		21	/* Is a directory */
25#define	EINVAL		22	/* Invalid argument */
26#define	ENFILE		23	/* File table overflow */
27#define	EMFILE		24	/* Too many open files */
28#define	ENOTTY		25	/* Not a typewriter */
29#define	ETXTBSY		26	/* Text file busy */
30#define	EFBIG		27	/* File too large */
31#define	ENOSPC		28	/* No space left on device */
32#define	ESPIPE		29	/* Illegal seek */
33#define	EROFS		30	/* Read-only file system */
34#define	EMLINK		31	/* Too many links */
35#define	EPIPE		32	/* Broken pipe */
36#define	EDOM		33	/* Math argument out of domain of func */
37#define	ERANGE		34	/* Math result not representable */
}}}

----
=== 工具前缀 ===
{{{
arm: arm-eabi-
arm64: aarch64-linux-android-
}}}

=== selinux开关 ===
{{{
1、
关闭：setenforce 0
开启：setenforce 1
当前状态：getenforce

2、
service权限控制，以engpc为例
device/sprd/scx35/sepolicy/engpc.te

需要打开对某文件节点的权限，先看该文件节点是哪个操作对象，如
    shell@scx35_sp7731gea_hd:/sys/power # ls -Z
-rw-rw---- system   system            u:object_r:sysfs:s0 state
-rw-rw---- radio    system            u:object_r:sysfs_wake_lock:s0 wake_lock
-rw-rw---- radio    system            u:object_r:sysfs_wake_lock:s0 wake_unlock
若想对state进行操作，则需要加
allow engpc sysfs:file write;
}}}

=== wifi document ===
{{{
\\10.0.0.166\Public_Folder\PLD\Samsung\SC7730S_Tshark\Pikea_marlin\files\wifi\wifi
}}}

----
=== ANA_REG_GLB_PWR_WR_PROT_VALUE ===
{{{
ANA_REG_GLB_PWR_WR_PROT_VALUE需要根据spec来设置相应的值，如果设置完正确的值后，就可以修改ANA_REG_GLB_LDO_DCDC_PD，否则无法修改
改完后，再将ANA_REG_GLB_PWR_WR_PROT_VALUE设回0
}}}

----
=== 打印函数名 ===
{{{
printk("%pF\n", printk);
}}}

----
=== 生成manifest.xml ===
{{{
repo manifest -o ~/manifest.xml -r
}}}

=== linux driver加载顺序 ===
{{{
1、根据init的级别  －－  可以改注册init_func的级别
2、根据编译顺序  －－  可以改makefile里的编译顺序
}}}

----
=== panic后不重启 ===
{{{
kernel/drivers/platform/sprd/sys_reset.c

diff --git a/drivers/platform/sprd/sys_reset.c b/drivers/platform/sprd/sys_reset.c
index 1f6bc43..f08594c 100755
--- a/drivers/platform/sprd/sys_reset.c
+++ b/drivers/platform/sprd/sys_reset.c
@@ -19,6 +19,7 @@ void sprd_set_reboot_mode(const char *cmd)
 {
        if(cmd)
                printk("sprd_set_reboot_mode:cmd=%s\n",cmd);
+while(1);
        if (cmd && !(strncmp(cmd, "recovery", 8))) {
                sci_adi_raw_write(ANA_RST_STATUS, HWRST_STATUS_RECOVERY);
        } else if (cmd && !strncmp(cmd, "alarm", 5)) {
}}}

=== recovery用jigbox串口 ===
{{{
cmdline里加上控制台的配置

diff --git a/board/spreadtrum/ss_sharklt8/ss_sharklt8.c b/board/spreadtrum/ss_sharklt8/ss_sharklt8.c
index 7a3e34e..4cc86ce 100755
--- a/board/spreadtrum/ss_sharklt8/ss_sharklt8.c
+++ b/board/spreadtrum/ss_sharklt8/ss_sharklt8.c
@@ -169,8 +169,8 @@ void fdt_fixup_chosen_bootargs_board(char *buf, int calibration_mode)
         * so in samsung board .dts, we remove the "console=ttyS1,115200n8" in chosen node by default.
         * so in normal mode, we need to append console
         */
-       if (!calibration_mode) {
+//     if (!calibration_mode) {
                p += sprintf(p, " console=ttyS1,115200n8 no_console_suspend ");
-       }
+//     }
 }
}}}

----
=== pr_debug ===
{{{
echo 'file sprdfb_main.c +p' > /sys/kernel/debug/dynamic_debug/control
}}}

----
=== printk文件节点实现 ===
{{{
实现文件：kernel/kernel/sysctl.c

237static struct ctl_table sysctl_base_table[] = {
238	{
239		.procname	= "kernel",
240		.mode		= 0555,
241		.child		= kern_table,
242	},
243	{
244		.procname	= "vm",
245		.mode		= 0555,
246		.child		= vm_table,
247	},
248	{
249		.procname	= "fs",
250		.mode		= 0555,
251		.child		= fs_table,
252	},
253	{
254		.procname	= "debug",
255		.mode		= 0555,
256		.child		= debug_table,
257	},
258	{
259		.procname	= "dev",
260		.mode		= 0555,
261		.child		= dev_table,
262	},
263	{ }
264};


1683int __init sysctl_init(void)
1684{
1685	struct ctl_table_header *hdr;
1686
1687	hdr = register_sysctl_table(sysctl_base_table);
1688	kmemleak_not_leak(hdr);
1689	return 0;
1690}
}}}

----
=== 编译器 ===
{{{
arm32：arm-eabi-
arm64：aarch64-linux-android-
}}}

----
=== EMMC和DDR性能测试 ===
{{{
EMMC用bonnie
命令：bonnie -d /data -s 2000
说明：测试数据的大小一般为DDR的2倍，最大为2g
举例：
shell@scx35l64_ss_sharklt8:/ # bonnie -d /data -s 2000                         
File '/data/Bonnie.12726', size: 2097152000
Writing with putc()...done
Rewriting...done
Writing intelligently...done
Reading with getc()...done
Reading intelligently...done
Seeker 1...Seeker 2...Seeker 3...start 'em...done...done...done...
              -------Sequential Output-------- ---Sequential Input-- --Random--
              -Per Char- --Block--- -Rewrite-- -Per Char- --Block--- --Seeks---
Machine    MB K/sec %CPU K/sec %CPU K/sec %CPU K/sec %CPU K/sec %CPU  /sec %CPU
         2000  7024 98.0 28532 56.0 12100 25.6  8860 98.7 67623 30.2 2288.3 40.6
}}}

----
=== 查看dfs是否起作用 ===
{{{
看0x30000108是否有变化

shell@scx35l_sharkl_j1poplte_old:/ # lookat 0x30000108                         
0x03060b0c
shell@scx35l_sharkl_j1poplte_old:/ # lookat 0x30000108                         
0x060a0d10
}}}

----
=== /proc/sysrq-trigger ===
{{{

/proc/sysrq-trigger该文件能做些什么事情呢？ 

# 立即重新启动计算机 （Reboots the kernel without first unmounting file systems or syncing disks attached to the system）
echo "b" > /proc/sysrq-trigger

# 立即关闭计算机（shuts off the system）
echo "o" > /proc/sysrq-trigger

# 导出内存分配的信息 （可以用/var/log/message 查看）（Outputs memory statistics to the console） 
echo "m" > /proc/sysrq-trigger

# 导出当前CPU寄存器信息和标志位的信息（Outputs all flags and registers to the console）
echo "p" > /proc/sysrq-trigger

# 导出线程状态信息 （Outputs a list of processes to the console）
echo "t" > /proc/sysrq-trigger

# 故意让系统崩溃 （ Crashes the system without first unmounting file systems or syncing disks attached to the system）
echo "c" > /proc/sysrq-trigger

# 立即重新挂载所有的文件系统 （Attempts to sync disks attached to the system）
echo "s" > /proc/sysrq-trigger

# 立即重新挂载所有的文件系统为只读 （Attempts to unmount and remount all file systems as read-only）
echo "u" > /proc/sysrq-trigger

呵呵，此外还有两个，类似于强制注销的功能
e — Kills all processes except init using SIGTERM
i — Kills all processes except init using SIGKILL
}}}

----
=== module_param_named ===
{{{
#define module_param(name, type,perm) \
module_param_named(name, name, type, perm)

通过命令"modinfo-p${modulename}"可以得知一个模块有哪些参数可以使用。
同时，对于已经加载到内核里的模块，它们的模块参数会列举在/sys/module/${modulename}/parameters/目录下面，
可以使用"echo -n ${value} > /sys/module/${modulename}/parameters/${parm}"这样的命令去修改。
}}}

----
=== chip_sleep ===
{{{
chip_sleep信号是指ap是否已经进入睡眠
xtl_buf_en0/1是可以配置的，选定的子系统是否已经进入睡眠

vdd18进lp后，负载只有5ma
vdd18是否进lp，只受chip_sleep信号影响，不受xtl影响
但如果进lp后，cp唤醒，vdd18不会被唤醒，可能导致负载不够而荡机
}}}

----
=== spl加打印函数 ===
{{{

#define UART1_TX_BUF_ADDR 0X70100000
#define UART1_TX_BUF_CNT ((REG32(0x70100000 + 0xc)>>8)&0xff)
void spl_print(const unsigned char *string)
{
    unsigned char *s1 = NULL;

    s1 = string;

    while (*s1 != NULL)
    {    
        //wait until uart1 tx fifo empty
        while(UART1_TX_BUF_CNT != 0);

        //put out char by uart1 tx fifo
        REG32(UART1_TX_BUF_ADDR) = *s1; 
        s1++;
    }    
}
}}}

----
=== SharkLT8 FLATMEM ===
{{{
默认是SPARSEMEM，需要加以下内容才能在menu config里看到FLATMEM的配置

diff --git a/arch/arm64/Kconfig b/arch/arm64/Kconfig
index fc2af5d..7b5ac60 100755
--- a/arch/arm64/Kconfig
+++ b/arch/arm64/Kconfig
@@ -558,6 +558,9 @@ config ARCH_SPARSEMEM_ENABLE
 config ARCH_SPARSEMEM_DEFAULT
        def_bool ARCH_SPARSEMEM_ENABLE
 
+config ARCH_FLATMEM_ENABLE
+       def_bool y
+
 config ARCH_SELECT_MEMORY_MODEL
        def_bool ARCH_SPARSEMEM_ENABLE
}}}

=== persist.radio.ssda.testmode含义 ===
{{{
packages/apps/EngineerMode/src/com/sprd/engineermode/telephony/TelephonyManagerSprd.java

64    public static enum RadioFeatures {
65        SVLET, TD_LTE, LTE_FDD, TD_LTE_AND_LTE_FDD, // TD-LTE/LTE-FDD
66        LTE_FDD_AND_W_AND_GSM_CSFB, // LTE-FDD/W/GSM-CSFB
67        TD_LTE_AND_W_AND_GSM_CSFB, // TD-LTE/W/GSM-CSFB
68        TD_LTE_AND_LTE_FDD_AND_W_AND_GSM_CSFB, // TD-LTE/LTE-FDD/W/GSM-CSFB
69        TD_LTE_AND_TD_AND_GSM_CSFB, // TD-LTE/TD/GSM-CSFB
70        TD_LTE_AND_LTE_FDD_AND_TD_AND_GSM_CSFB, // TD-LTE/LTE-FDD/TD/GSM-CSFB
71        TD_LTE_AND_LTE_FDD_AND_W_AND_TD_AND_GSM_CSFB, // TD-LTE/LTE-FDD/W/TD/GSM-CSFB
72        GSM_ONLY, // GSM
73        WCDMA_ONLY, // WCDMA
74        TD_ONLY, // TD
75        TD_AND_GSM, // T/G
76        WCDMA_AND_GSM, // W/G
77        NONE
78    };
}}}

=== persist.radio.ssda.mode ===
{{{
packages/apps/EngineerMode/src/com/sprd/engineermode/telephony/TelephonyManagerSprd.java

60    public static enum RadioCapbility {
61        NONE, TDD_SVLTE, FDD_CSFB, TDD_CSFB, CSFB
62    };
}}}

----
=== boot core1 on SharkLT8 ===
{{{
上电流程如下：
1. 跑在64bit:
1）设置CPU1为64bit模式
0x50820034的bit1 = 1

2）设置启动地址
0x50820024 = 启动地址

3）上电（和你的寄存器配置一样，只是不需要配置REG_AP_AHB_CA7_RST_SET）
+        val = BITS_PD_CA7_C3_PWR_ON_DLY(4) | BITS_PD_CA7_C3_PWR_ON_SEQ_DLY(4) | BITS_PD_CA7_C3_ISO_ON_DLY(4);
+        sci_glb_write(REG_PMU_APB_PD_CA7_C1_CFG, val, -1UL);
+
+        val = (BIT_PD_CA7_C3_AUTO_SHUTDOWN_EN | __raw_readl(REG_PMU_APB_PD_CA7_C1_CFG)) &~(BIT_PD_CA7_C3_FORCE_SHUTDOWN);
+       printf("maryxiao####### val 0x%x\n", val);
+        sci_glb_write(REG_PMU_APB_PD_CA7_C1_CFG, val, -1UL);



2. 跑在32bit:
32位上电流程只能用于debug，如下：
1）设置CPU1为32bit模式
0x50820034的bit1 = 0

2）CPU1上电（和64位一样）
+        val = BITS_PD_CA7_C3_PWR_ON_DLY(4) | BITS_PD_CA7_C3_PWR_ON_SEQ_DLY(4) | BITS_PD_CA7_C3_ISO_ON_DLY(4);
+        sci_glb_write(REG_PMU_APB_PD_CA7_C1_CFG, val, -1UL);
+
+        val = (BIT_PD_CA7_C3_AUTO_SHUTDOWN_EN | __raw_readl(REG_PMU_APB_PD_CA7_C1_CFG)) &~(BIT_PD_CA7_C3_FORCE_SHUTDOWN);
+       printf("maryxiao####### val 0x%x\n", val);
+        sci_glb_write(REG_PMU_APB_PD_CA7_C1_CFG, val, -1UL);

3）等待CPU1进入WFE
查询0x20E03008的bit5，直至为1

4）设置CPU1启动标志
0x20E00014的bit1 = 1

5）设置启动地址
0x20E00018 = 启动地址
这里注意是0x20E00018，而不是1C，实际上1C、20、24三个寄存器已经不用了

6）通知CPU1开始执行
SEV
}}}

=== kernel boot cp ===
{{{
gerrit 提交如下：
http://review.source.spreadtrum.com/gerrit/#/c/185283/
http://review.source.spreadtrum.com/gerrit/#/c/185284/
http://review.source.spreadtrum.com/gerrit/#/c/185313/
http://review.source.spreadtrum.com/gerrit/#/c/187967/
}}}

----
=== 不输入密码执行sudo ===
{{{
echo <password> | sudo -S fastboot reboot
}}}

----
=== thread_info与sp关系 ===
{{{
sp = thread_info + 0x2000
即栈底是thread_info之后的2个page大小
}}}

=== SharkLT8 edap ===
{{{
edap:0x81410000
}}}

=== u-boot read/write EMMC ===
{{{
u-boot里读写EMMC：
int do_fs_file_read(char *mpart, char *filenm, void *buf, int len)

int do_raw_data_write(char *part, u32 updsz, u32 size, u32 off, char *buf)
int do_raw_data_read(char *part, u32 size, u32 off, char *buf)
// part：分区名
// updsz：total size
// size：write/read size
// off：offset
// buf：write/read buffer
}}}

=== u-boot read/write usb ===
{{{
u-boot里对usb的操作：
gs_open();
gs_write(buf, 20);
gs_read(buf, &count);
usb_trans_status

255 void cali_usb_debug(uint8_t *buf)
256 {
257     int i, ret;
258     for(i = 0; i<20; i++)
259     buf[i] = i+'a';
260     while(!usb_serial_configed)
261         usb_gadget_handle_interrupts();
262     printf("USB SERIAL CONFIGED\n");
263     gs_open();
264 #if WRITE_DEBUG
265     while(1){
266         ret = gs_write(buf, 20);
267         printf("func: %s waitting write done\n", __func__);
268         if(usb_trans_status)
269             printf("func: %s line %d usb trans with error %d\n", __func__, __LINE__, usb_trans_status);
270         usb_wait_trans_done(1);
271         printf("func: %s readly send %d\n", __func__, ret);
272     }
273 #else
274     while(1){
275         int count = 20;
276         usb_wait_trans_done(0);
277         if(usb_trans_status)
278             printf("func: %s line %d usb trans with error %d\n", __func__, __LINE__, usb_trans_status);
279         ret = gs_read(buf, &count);
280         printf("func: %s readly read %d\n", __func__, count);
281         if(usb_trans_status)
282             printf("func: %s line %d usb trans with error %d\n", __func__, __LINE__, usb_trans_status);
283         for(i = 0; i<count; i++)
284             printf("%c ", buf[i]);
285         printf("\n");
286     }
287 
288 #endif
289 }
}}}

=== git commit comment检查 ===
{{{
git commit时会检查comment是否合法，这个是通过git的hook来实现的
具体在仓库的.git/hooks目录下的commit-msg脚本，最终指向.repo/repo/hooks这个目录
}}}

=== sd card权限问题 ===
{{{
SS T8用主干后，发现t卡不能使用，需要修改权限ss_sharklt8_2731.mk:
STORAGE_ORIGINAL := true => STORAGE_ORIGINAL := false
}}}

=== nvitem header ===
{{{
手机里的nvitem有一个header，记录了当前nvitem的一些信息
在原始的nvitem.bin里，是没有这个header的，它在下载阶段由fdl2添加的

代码在：u-boot64/common/dloader/dl_emmc_operate.c
930 int _nv_img_check_and_write(uchar * partition, uint32_t size)
931 {   
937     uint8_t header_buf[EFI_SECTOR_SIZE];
938     nv_header_t *nv_header_p = NULL;
940     
946     memset(header_buf, 0x00, EFI_SECTOR_SIZE);
947     nv_header_p = header_buf;
948     nv_header_p->magic = NV_HEAD_MAGIC;
949     nv_header_p->len = size; 
950     nv_header_p->checksum = (uint32_t) fdl_calc_checksum(g_eMMCBuf, size);
951     nv_header_p->version = NV_VERSION;

其中nv_header_t定义在u-boot64/common/loader/loader_common.h
92typedef struct _NV_HEADER {
93    uint32_t magic;
94    uint32_t len;
95    uint32_t checksum;
96    uint32_t version;
97} nv_header_t;

nvitem服务在vendor/sprd/open-source/apps/nvitem/nvitem_fs.c这个文件里对这个header进行操作
353 BOOLEAN ramDisk_Write(RAMDISK_HANDLE handle, uint8* buf, uint32 size)
354 {
361     char header_buf[RAMNV_SECT_SIZE];
362     nv_header_t *header_ptr = NULL;
363 
368     memset(header_buf,0x00,RAMNV_SECT_SIZE);
369     header_ptr = header_buf;
370     header_ptr->magic = NV_HEAD_MAGIC;
371     header_ptr->len = size;
372     header_ptr->version = NV_VERSION;
373     header_ptr->checksum = (uint32)calc_checksum(buf,size);
}}}

=== 屏幕分辨率 ===
{{{
HD: 1280x720 (720p)
QHD:2560x1440
FHD:1920x1080 (1080p)
qHD:960x540
}}}
{{local:images/resolution.png}}

=== manifest提交 ===
{{{
pushfile.sh platform/manifest sprdroid5.1_prime_15a_GED
}}}

=== 查看分区大小 ===
{{{
查看分区被划分的大小：
cat /proc/partitions

查看分区上文件系统的大小：
df
df的大小是根据BoardConfig.mk里配置的，是文件系统的大小，而不是真正分区大小，它可能比分区小
}}}

=== 系统如何获得SN号 ===
{{{
这里的SN号，也就是adb devices显示的一串序列号

u-boot通过从miscdata分区读取SN号，如果该分区里没有SN号，就用默认的"0123456789ABCDEF"；
将SN号存入androidboot.serialno，以cmdline的形式传给kernel；
kernel将其解析为ro.boot.serialno，最后解析成ro.serialno。
所以，整个过程为：androidboot.XXX => ro.boot.XXX => ro.XXX

1、从miscdata分区读取sn号
324int fdt_fixup_serialno(void *fdt)
325{
326	char buf[64];
327	int str_len;
328	int ret;
329	memset(buf, 0, 64);
330
331	sprintf(buf, " androidboot.serialno=%s", get_product_sn());
332	str_len = strlen(buf);
333	buf[str_len] = '\0';
334	ret = fdt_chosen_bootargs_append(fdt, buf, 1);
335	return ret;
336}

51char *get_product_sn(void)
52{
53	SP09_PHASE_CHECK_T phase_check;
54
55	memset(serial_number_to_transfer, 0x0, SP09_MAX_SN_LEN);
56
57	strcpy(serial_number_to_transfer, "0123456789ABCDEF");
58	if (do_raw_data_read(PRODUCTINFO_FILE_PATITION, sizeof(phase_check), 0, (char *)&phase_check)) {
59		debugf("read miscdata error.\n");
60		return serial_number_to_transfer;
61	}
62
63	if ((phase_check.Magic == SP09_SPPH_MAGIC_NUMBER) && strlen(phase_check.SN1)) {
64		memcpy(serial_number_to_transfer, phase_check.SN1, SP09_MAX_SN_LEN);
65	}
66	return serial_number_to_transfer;
67}

2、kernel转换过程（system/core/init/init.c）
716static void import_kernel_nv(char *name, int for_emulator)
717{
736    if (!strcmp(name,"qemu")) {
737        strlcpy(qemu, value, sizeof(qemu));
738    } else if (!strncmp(name, "androidboot.", 12) && name_len > 12) {
739        const char *boot_prop_name = name + 12;
740        char prop[PROP_NAME_MAX];
741        int cnt;
742
743        cnt = snprintf(prop, sizeof(prop), "ro.boot.%s", boot_prop_name);
744        if (cnt < PROP_NAME_MAX)
745            property_set(prop, value);
746    }
747}

749static void export_kernel_boot_props(void)
750{
754    struct {
755        const char *src_prop;
756        const char *dest_prop;
757        const char *def_val;
758    } prop_map[] = {
759        { "ro.boot.serialno", "ro.serialno", "", },
760        { "ro.boot.mode", "ro.bootmode", "unknown", },
761        { "ro.boot.baseband", "ro.baseband", "unknown", },
762        { "ro.boot.bootloader", "ro.bootloader", "unknown", },
763    };
764
765    for (i = 0; i < ARRAY_SIZE(prop_map); i++) {
766        ret = property_get(prop_map[i].src_prop, tmp);
767        if (ret > 0)
768            property_set(prop_map[i].dest_prop, tmp);
769        else
770            property_set(prop_map[i].dest_prop, prop_map[i].def_val);
771    }
798}

3、把sn号写到usb的节点中
 on boot
     write /sys/class/android_usb/android0/iSerial $ro.serialno
}}}

=== miscdata分区 ===
{{{
该分区放的是裸数据，没有文件系统
主要产线用的信息，和SN号

其格式为：
55typedef struct _tagSP09_PHASE_CHECK {
56	uint32_t Magic;	// "SP09"
57	char SN1[SP09_MAX_SN_LEN];	// SN , SN_LEN=24
58	char SN2[SP09_MAX_SN_LEN];	// add for Mobile
59	int StationNum;		// the test station number of the testing
60	char StationName[SP09_MAX_STATION_NUM][SP09_MAX_STATION_NAME_LEN];
61	unsigned char Reserved[13];	//
62	unsigned char SignFlag;
63	char szLastFailDescription[SP09_MAX_LAST_DESCRIPTION_LEN];
64	unsigned short iTestSign;	// Bit0~Bit14 ---> station0~station 14
65	//if tested. 0: tested, 1: not tested
66	unsigned short iItem;	// part1: Bit0~ Bit_14 indicate test Station,1 : Pass,
67
68} SP09_PHASE_CHECK_T, *LPSP09_PHASE_CHECK_T;
}}}

=== 各分区描述 ===
[[local:files/分区描述.xlsx|分区描述.xlsx]]</BR>

=== 查看分支信息 ===
{{{
repo info .
}}}

=== 反汇编bin ===
{{{
arm-linux-objdump -D -b binary -m arm xxx.bin > xxx.asm
}}}

=== Android属性 ===
{{{
adb shell可以通过getprop/setprop来改属性值
C代码可以通过property_set来修改

ro开头的属性为只读，不能修改
persist开头的属性，会保存在/data/property/目录下，下次开机时还会存在该值
}}}

=== 预编译 ===
{{{
代码预编译，将宏展开
gcc -E -P xxxx.c
}}}

=== 定时周期timer ===
{{{
CP:
2.5s：do-idle
	飞行模式下会关闭
18.9s：dsp
	出现的场景：
	1）flight mode
	2）w standby only

AP:
30s：pm_print(kernel/drivers/platform/sprd/pm_debug_scx35.c)
30s：电量检测
40s：sprd_hotplug(kernel/drivers/cpuhotplug/sprd_hotplug.c)
5s：loopcheck
3s：slog

如果cp有周期性醒来，有可能开了log
}}}

=== 打开uart驱动的打印 ===
{{{
1、关于uart打开log方法如下：
在uart驱动文件，serial_sprd_dt.c
将private_data->debug_function_flag = 0;改为private_data->debug_function_flag = 1；
默认log就打开了
}}}

=== camera hal ===
{{{
camera 用hal3.0还是1.0，可以在device/sprd的system.prop里配
persist.sys.camera.camera_api=0                //用1.0
persist.sys.camera.camera_api=1                //用3.0
}}}

=== SharkL/SharkLS配置差异 ===
{{{
一、kernel
1. dts
 1）修改：
/include/ "scx35l-clocks.dtsi"
=>
/include/ "scx35l-sp9830iea-5m-clocks.dtsi"

 2）新增：
codecahb {
       compatible = "sprd,codecahb";
       reg = <0x62000000 0x1000>;
};

2. defconfig
 1）新增：
CONFIG_MACH_SP9830I=y

3. board-sharkls_z3lte.c
 1）__clock_init_early函数：
#if defined(CONFIG_MACH_SHARKLS_Z3LTE) 	164
»       sci_glb_set(REG_AON_APB_APB_EB1, BIT_CODEC_EB | 0);	165
#endif

 2）iotable_build函数：
ADD_SPRD_DEVICE("sprd,codecahb", CODECAHB);

 3）sc8830_pmu_init函数：
__raw_writel(__raw_readl(REG_AON_APB_APB_EB1) | BIT_CODEC_EB, REG_AON_APB_APB_EB1);


二、chipram
1. sharkls_z3lte.h
新增：
#define CONFIG_SP9830I

三、u-boot64
1. sharkls_z3lte.h
新增：
#define CONFIG_SP9830I

2. ldo_sleep.c
新增：
CHIP_REG_SET(REG_PMU_APB_PD_CODEC_TOP_CFG,
       BIT_PD_CODEC_TOP_AUTO_SHUTDOWN_EN
       BITS_PD_CODEC_TOP_PWR_ON_DLY(8)
       BITS_PD_CODEC_TOP_PWR_ON_SEQ_DLY(0)
       BITS_PD_CODEC_TOP_ISO_ON_DLY(4)
       0
);
}}}

=== 判断gsp/gpu合成 ===
{{{
命令：dumpsys SurfaceFlinger

显示的type
GSP：HWC
GPU：gles
}}}

=== ps代码 ===
{{{
system/core/toolbox/ps.c
}}}

=== LOG_TAG/log头 ===
{{{
#define LOG_TAG "SLOG"
}}}

=== 主动触发panic ===
{{{
echo "c" > /proc/sysrq-trigger

下面将sysrq.txt中的内容附加上一段，全部可以使用的command：
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
 'b'     - Will immediately reboot the system without syncing or unmounting
           your disks.

 'c' - Will perform a system crash by a NULL pointer dereference.
           A crashdump will be taken if configured.

 'd' - Shows all locks that are held.

 'e'     - Send a SIGTERM to all processes, except for init.

 'f' - Will call oom_kill to kill a memory hog process.

 'g' - Used by kgdb on ppc and sh platforms.

 'h'     - Will display help (actually any other key than those listed
           here will display help. but 'h' is easy to remember :-)

 'i'     - Send a SIGKILL to all processes, except for init.

 'j'     - Forcibly "Just thaw it" - filesystems frozen by the FIFREEZE ioctl.

 'k'     - Secure Access Key (SAK) Kills all programs on the current virtual
           console. NOTE: See important comments below in SAK section.

 'l'     - Shows a stack backtrace for all active CPUs.

 'm'     - Will dump current memory info to your console.

 'n'     - Used to make RT tasks nice-able

 'o'     - Will shut your system off (if configured and supported).

 'p'     - Will dump the current registers and flags to your console.

 'q'     - Will dump per CPU lists of all armed hrtimers (but NOT regular
           timer_list timers) and detailed information about all
           clockevent devices.

 'r'     - Turns off keyboard raw mode and sets it to XLATE.

 's'     - Will attempt to sync all mounted filesystems.

 't'     - Will dump a list of current tasks and their information to your
           console.

 'u'     - Will attempt to remount all mounted filesystems read-only.

 'v'     - Dumps Voyager SMP processor info to your console.

 'w'     - Dumps tasks that are in uninterruptable (blocked) state.

 'x'     - Used by xmon interface on ppc/powerpc platforms.

 'z'     - Dump the ftrace buffer

 '0'-'9' - Sets the console log level, controlling which kernel messages
           will be printed to your console. ('0', for example would make
           it so that only emergency messages like PANICs or OOPSes would
           make it to your console.)
}}}

=== arm7 memory layout on SharkL ===
{{{
基地址：0x50800000

0 ~ 0x53FF
CODE + RO
 
0x5400 ~ 0x57FF
DFS parameters (根据DSF调试结果决定是否使用此区域)
 
0x5800 ~ 0x58FF
AP state on crash (由于SharkL芯片bug，这个区域未使用)
 
0x5900 ~ 0x77FF
RW/ZI data
 
0x7800 ~ 0x7FFF
Stack defined in tx_illdb.s
}}}

=== 如何让arm7不睡(SharkLs) ===
{{{
arm7在进deep时会去polling 0x402b0178是否为0，将其改为1，可让其不睡
但前提是arm7是醒着的，所以先进deep，再退出来时设
}}}

=== Android ps代码 ===
{{{
system/core/toolbox/ps.c

Android的ps命令参数: -t -x -P -p -c [pid|name]
-t 显示进程下的线程列表
-x 显示进程耗费的用户时间和系统时间，格式:(u:0, s:0)，单位:秒(s)
-P 显示调度策略，通常是bg或fg，当获取失败将会是un和er
-p 显示进程的优先级和nice等级
-c 显示进程耗费的CPU时间 (可能不兼容Android 4.0以前的老版本系统)
[pid] 过滤指定的进程PID
[name] 过滤指定的进程NAME
}}}

=== apk签名 ===
{{{
生成signapk.jar
现在签名文件的目录，在build/target/product/security下，如果是userdebug的，直接在这个目录下，如果是user版本，则在release下

java -jar build/target/product/security/signapk.jar build/target/product/security/release/platform.x509.pem build/target/product/security/release/platform.pk8 ~/FTAT_1.89_user.apk ~/FTAT_1.89_user_signed.apk
}}}

=== CA5 clk ===
{{{
CA5的clk只能通过CA5来看，但cp会记到全局变量mcu_clk_ctl里
}}}

=== TW暗码 ===
{{{
USB端口选择：*#0808#
}}}

=== USB ===
{{{
SPRD用gser，三星用acm
/sys/class/android_usb/android0/functions：usb功能
/sys/class/android_usb/android0/f_acm/instances：acm端口实例数
sys.usb.config：功能列表（会被修改）
sys.usb.state：功能列表
persist.sys.usb.sport：acm端口数
}}}
