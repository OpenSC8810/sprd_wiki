%toc 目录

----
== architecture ==
{{local:images/sipc_architecture.png}}

----
== Interconnection between AP and CPs ==
{{{
1)      TD/LTE CSFB+GGE DSDS/DSDA
one instance of SIPC between AP and CA5;
one instance of SIPC between AP and ARM9_0;
 
2)      W/LTE CSFB+GGE DSDA
one instance of SIPC between AP and CA5;
one instance of SIPC between AP and ARM9_0;
one instance of SIPC between CA5 and ARM9_1;
 
To support DSDA, both of LTE and GGE modems keep active at the same time. Two modems have individual SIPC interfaces in AP , which makes it possible to create individual services for modem communications. 
 
The SIPC interfaces in user-land are,
}}}
|*MODULE*|*LTE*|*GGE*|*Comments*|
|RIL	|/dev/stty_lte[0~31]	|/dev/stty_gge[0~31]	|RIL communication fifo|
|DATA	|seth_lte[0~2]	|seth_gge[0~2]	|2G/3G data Ethernet|
|SOUND	|/dev/snd/..[Cx]	|/dev/snd/..[Cx]	|Sound card of play/record in call mode|
|DIAG	|/dev/slog_lte	|/dev/slog_gge	|Diag and Log communication|
|LOOP	|/dev/spipe_lte0	|/dev/spipe_gge0	|Loopback pipe|
|NV	|/dev/spipe_lte1	|/dev/spipe_gge1	|NV item data communications|
|ASSERT	|/dev/spipe_lte2	|/dev/spipe_gge2	|Modem assert notification and feedback|
|CHARGE	|/dev/spipe_lte3	|/dev/spipe_gge3	|Charge data communication|
|AUDIO	|/dev/spipe_lte4	|/dev/spipe_gge4	|VOIP|
|N/A	|/dev/spipe_lte5	|/dev/spipe_gge5	|Not used|
|AUDIO	|/dev/spipe_lte6	|/dev/spipe_gge6	|Audio VBC switch notification|
|N/A	|/dev/spipe_lte7	|/dev/spipe_gge7	|Not used|
|REF	|/dev/spipe_lte8	|/dev/spipe_gge8	|Refnotify|

----
== SMEM ==
{{local:images/smem.bmp}}

== SMSG ==
{{local:images/smsg.png}}

=== SIPC ID ===
{{{
29/* sipc processor ID definition */
30enum {
31	SIPC_ID_AP = 0,		/* Application Processor */
32	SIPC_ID_CPT,		/* TD processor */
33	SIPC_ID_CPW,		/* WCDMA processor */
34	SIPC_ID_WCN,		/* Wireless Connectivity */
35	SIPC_ID_GGE, 		/* Gsm Gprs Edge processor */
36	SIPC_ID_LTE, 		/* LTE processor */
37	SIPC_ID_PMIC,
38	SIPC_ID_NR,		/* total processor number */
39};
}}}

=== SIPC channel ===
{{{
42/* smsg channel definition */
43enum {
44	SMSG_CH_CTRL = 0,	/* some emergency control */
45	SMSG_CH_COMM,		/* general communication channel */
46	SMSG_CH_RPC_AP,		/* RPC server channel in AP side */
47	SMSG_CH_RPC_CP,		/* RPC server channel in CP side */
48	SMSG_CH_PIPE,		/* general pipe channel */                       // nv
49	SMSG_CH_PLOG,		/* pipe for debug log/dump */                    // log
50	SMSG_CH_TTY,		/* virtual serial for telephony */               // at
51	SMSG_CH_DATA0,		/* 2G/3G wirleless data */
52	SMSG_CH_DATA1,		/* 2G/3G wirleless data */
53	SMSG_CH_DATA2,		/* 2G/3G wirleless data */
54	SMSG_CH_VBC,		/* audio conrol channel */
55	SMSG_CH_PLAYBACK, 	/* audio playback channel */
56	SMSG_CH_CAPTURE,	/* audio capture channel */
57	SMSG_CH_MONITOR_AUDIO,	/* audio monitor channel */
58	SMSG_CH_CTRL_VOIP,	/* audio voip conrol channel */
59	SMSG_CH_PLAYBACK_VOIP, 	/* audio voip playback channel */
60	SMSG_CH_CAPTURE_VOIP,	/* audio voip capture channel */
61	SMSG_CH_MONITOR_VOIP,	/* audio voip monitor channel */
62	SMSG_CH_DATA3,		/* 2G/3G wirleless data */
63	SMSG_CH_DATA4,		/* 2G/3G wirleless data */
64	SMSG_CH_DATA5,		/* 2G/3G wirleless data */
65	SMSG_CH_DIAG,		/* pipe for debug log/dump */                    // diag
66	SMSG_CH_PM_CTRL, 	/* power management control */
67	SMSG_CH_DUAL_SIM_PLUG,	/* dual sim plug channel */
68	SMSG_CH_NR,		/* total channel number */
69};
}}}

=== msg 类型 ===
{{{
72/* smsg type definition */
73enum {
74	SMSG_TYPE_NONE = 0,
75	SMSG_TYPE_OPEN,		/* first msg to open a channel */
76	SMSG_TYPE_CLOSE,	/* last msg to close a channel */
77	SMSG_TYPE_DATA,		/* data, value=addr, no ack */
78	SMSG_TYPE_EVENT,	/* event with value, no ack */
79	SMSG_TYPE_CMD,		/* command, value=cmd */
80	SMSG_TYPE_DONE,		/* return of command */
81	SMSG_TYPE_SMEM_ALLOC,	/* allocate smem, flag=order */
82	SMSG_TYPE_SMEM_FREE,	/* free smem, flag=order, value=addr */
83	SMSG_TYPE_SMEM_DONE,	/* return of alloc/free smem */
84	SMSG_TYPE_FUNC_CALL,	/* RPC func, value=addr */
85	SMSG_TYPE_FUNC_RETURN,	/* return of RPC func */
86	SMSG_TYPE_DIE,
87	SMSG_TYPE_NR,		/* total type number */
88};
}}}

== SBUF ==
{{local:images/sbuf.png}}

== SBLOCK ==
{{local:images/sblock.PNG}}

=== sample code ===
==== write data ====
{{{
static ssize_t spool_write(struct file *filp,
		const char __user *buf, size_t count, loff_t *ppos)
{
	struct spool_sblock *sblock = filp->private_data;
	int timeout = -1;
	int ret = 0;
	int wrsize = 0;
	int pos = 0;
	struct sblock blk = {0};
	size_t len = count;

	if(filp->f_flags & O_NONBLOCK){
		timeout = 0;
	}

	do{
		if((ret = sblock_get(sblock->dst, sblock->channel, &blk, timeout)) < 0){
			printk(KERN_WARNING "spool_write: failed to get block!\n");
			return ret;
		}

		wrsize = (blk.length > len ? len : blk.length);
		pr_debug("spool_write: blk_len %d, count %d, wsize %d\n", blk.length, len, wrsize);
		if(copy_from_user(blk.addr, buf + pos, wrsize)){
			printk(KERN_WARNING "spool_write: failed to copy from user!\n");
			ret = -EFAULT;
		}else{
			blk.length = wrsize;
			len -= wrsize;
			pos += wrsize;
		}

		if(sblock_send(sblock->dst, sblock->channel, &blk)){
			pr_debug("spool_write: failed to send block!");
		}

		pr_debug("spool_write len= %u, ret= %d\n", len, ret);
	}while(len > 0 && ret == 0);

	return count - len;
}
}}}

==== read data ====
{{{
static ssize_t spool_read(struct file *filp,
		char __user *buf, size_t count, loff_t *ppos)
{
	struct spool_sblock *sblock = filp->private_data;
	int timeout = -1;
	int ret = 0;
	int rdsize = 0;
	struct sblock blk = {0};

	if (filp->f_flags & O_NONBLOCK) {
		timeout = 0;
	}

	if((ret = sblock_receive(sblock->dst, sblock->channel, &blk, timeout)) < 0){
		pr_debug("spool_read: failed to receive block!\n");
		return ret;
	}

	rdsize = blk.length > count ? count : blk.length;

	if(copy_to_user(buf, blk.addr, rdsize)){
		pr_debug("spool_read: failed to copy to user!\n");
		ret = -EFAULT;
	}else{
		ret = rdsize;
	}

	if(sblock_release(sblock->dst, sblock->channel, &blk)){
		pr_debug("failed to release block!\n");
	}

	return ret;
}
}}}

----
== 上层应用 ==
=== SIPC创建 ===
vendor/sprd/proprietories-source/phoneserver/channel_manager.c
{{{
1003 /*## operation initialize all channel manager's objects  according to phone server configuration  file*/
1004 static void channel_manager_init(void)
1005 {
1006     chnmng.me = &chnmng;
1007     chnmng.ops = &chnmng_operaton;
1008     sem_init(&chnmng.get_mux_lock, 0, 1);
1009 
1010     sem_init(&chnmng.array_lock, 0, 1);
1011     chnmng.block_count = 0;
1012 
1013     get_partial_wakeLock();
1014     chnmng_buffer_Init(chnmng.me);
1015     chnmng_cmux_Init(chnmng.me);
1016     chnmng_pty_Init(chnmng.me);
1017 
1018     setuid(AID_SYSTEM); /* switch user to system  */
1019 
1020     chnmng_start_thread(chnmng.me);
1021     release_wakeLock();
1022 }


  43 #define MUX_TD_DEV  "ro.modem.t.tty"
  44 #define MUX_W_DEV  "ro.modem.w.tty"
  45 #define MUX_L_DEV  "ro.modem.l.tty"
  46 #define MUX_TL_DEV  "ro.modem.tl.tty"
  47 #define MUX_LF_DEV  "ro.modem.lf.tty"

 749 /*## operation initialize all cmux objects*/
 750 static void chnmng_cmux_Init(struct channel_manager_t *const me)
 751 {   
 766     if(!strcmp(modem, "t")) {
 767         property_get(MUX_TD_DEV, prop, "/dev/ts0710mux");
 768     } else if(!strcmp(modem, "w")) {
 769         property_get(MUX_W_DEV, prop, "/dev/ts0710mux");
 770     } else if(!strcmp(modem, "l") ) {
 771         property_get(MUX_L_DEV, prop, "/dev/sdiomux");
 772         if(multiSimMode == 0) {
 773             chn_num = LTE_MUX_CHN_NUM ;
 774         }
 775     } else if(!strcmp(modem, "tl")) { 
 776         property_get(MUX_TL_DEV, prop, "/dev/sdiomux");
 777         if(multiSimMode == 0) { 
 778             chn_num = LTE_MUX_CHN_NUM ;
 779         }   
 780     } else if(!strcmp(modem, "lf")) {
 781         property_get(MUX_LF_DEV, prop, "/dev/sdiomux");
 782         if(multiSimMode == 0) {
 783             chn_num = LTE_MUX_CHN_NUM ;
 784         }   
 785     } else {
 786         PHS_LOGE("Wrong modem parameter");
 787         exit(-1);
 788     }   
 858 }       

}}}

=== 轮询5次CP无响应，发生Modem Blocked ===
vendor/sprd/proprietories-source/phoneserver/adapter.c
{{{
1719 int adapter_cmux_write(cmux_t * mux, char *buf, int len, int to)
1720 {   
1748     int err = thread_cond_timedwait(&mux->cond_timeout, &mux->mutex_timeout,
1749             &timeout); 
1750     if (err == ETIMEDOUT) {
1751         mux->cp_blked += 1;
1752         if(mux->cp_blked > BLOCKED_MAX_COUNT) {                                           // BLOCKED_MAX_COUNT = 5
1753             mux->cp_blked = 0;
1754             if(!strcmp(modem, "t")) {
1755                 ALOGD("TD modem AT no response");
1756                 strcpy(block_str, "TD Modem Blocked");
1757             } else if(!strcmp(modem, "w")) {
1758                 ALOGD("W modem AT no response");
1759                 strcpy(block_str, "W Modem Blocked");
1760             } else if(!strcmp(modem, "l")) {
1761                 ALOGD("L modem AT no response");
1762                 strcpy(block_str, "L Modem Blocked");
1763             } else if(!strcmp(modem, "tl")) {
1764                 ALOGD("TL modem AT no response");
1765                 strcpy(block_str, "TL Modem Blocked");
1766             } else if(!strcmp(modem, "lf")) {
1767                 ALOGD("LF modem AT no response");
1768                 strcpy(block_str, "LF Modem Blocked");
1769             } else {
1770                 PHS_LOGE("Wrong modem parameter2");
1771             exit(-1);
1772             } 
1773             if(soc_client > 0) {
1774                 res = write(soc_client, block_str, strlen(block_str)+1);                   // 发Modem Blocked消息给AP
1775                 ALOGD("write %d bytes to soc_client:%d to info modem is blocked",
1776                                      res, soc_client);
1777             }
1778         }   
1796     }       
1800             
1801     return ret;
1802 }
}}}

----
== 调试节点 ==
{{{
shell@scx35l64_ss_sharklt8:/d/sipc # ll
-r--r--r-- root     root            0 1970-01-01 08:00 sblock
-r--r--r-- root     root            0 1970-01-01 08:00 sbuf
-r--r--r-- root     root            0 1970-01-01 08:00 smem
-r--r--r-- root     root            0 1970-01-01 08:00 smsg
}}}


----
== channel & onwer
{{{
channel 4/value 0、1是nvitemd相关channel 4/value 2是assert相关，CP找andrew.yang，AP找zhiwei.fu
channel 4/value 8是refnotify，找zhongping.tan
channel 5、21 是log/diag通道，找xiaoyin.cao
channel 6/value 0-11是AT命令，CP侧找协议栈，AP找zhiwei.fu
channel 6/value 12 是VT通道 ，CP找shaohua.xia
channel 7、8、9、18、19、20是网络通道，找sally.he
channel 10-17 是audio相关，找peter.huang
channel 22是CP信令通道 ，未来将使用
}}}

----
== 附件 ==
[[local:files/multimedia_AudioHAL_ap_SIPC_introduction.ppt|multimedia_AudioHAL_ap_SIPC_introduction.ppt]]</BR>
[[local:files/Spreadtrum_InterProcessor_Communication_Design.docx|Spreadtrum_InterProcessor_Communication_Design.docx]]</BR>


